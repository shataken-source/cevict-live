# Cochran AI / DevOps Agent Integration Rules
# These rules instruct the AI assistant on how to use Cochran effectively

## Always Use Cochran (DevOps Agent API) for Operations

The DevOps Agent (Cochran) API runs on http://localhost:8471. ALWAYS delegate operations to Cochran instead of running commands directly. This saves tokens and allows async operations.

### When to Use Cochran

| Task | Use Cochran Endpoint | Why |
|------|---------------------|-----|
| Check git status | GET /git/status | Saves token streaming |
| Commit code | POST /git/commit | One call, async result |
| Push to GitHub | POST /git/push | No output streaming |
| Deploy to Vercel | POST /vercel/deploy | Returns URL when done |
| Check disk usage | GET /organize/disk-usage | Structured JSON |
| Find large files | GET /audit/large-files | No parsing needed |
| Check port status | GET /tools/port/{port} | Instant result |
| Kill stuck process | POST /tools/kill-process | Safe operation |
| Start/stop Cochran | POST /cochran/start, /cochran/stop | Self-management |
| Get refresher | GET /cochran/refresher | Context awareness |

### API Usage Pattern

```powershell
# Good: Call Cochran (returns JSON)
$result = Invoke-RestMethod http://localhost:8471/git/status
if ($result.clean) { "Working tree clean" }

# Bad: Running git directly (streams output, wastes tokens)
git status
```

### Critical Commands to ALWAYS Delegate

1. **Git Operations** - Always use /git/* endpoints
2. **Vercel Deploys** - Always use /vercel/deploy
3. **File Audits** - Always use /audit/* endpoints
4. **Port Management** - Always use /tools/port/*
5. **Cochran Management** - Always use /cochran/*

### Multi-Instance Coordination (Prevent Cascade Collisions)

Multiple Cascade instances can coordinate through Cochran to avoid working on the same files/branches simultaneously.

| Task | Use Cochran Endpoint | Purpose |
|------|---------------------|---------|
| Register activity | POST /cascade/heartbeat | Tell other instances what you're working on |
| Check other instances | GET /cascade/active | See who's working on what |
| Check for collisions | POST /cascade/check-collision | Detect if another instance is on same branch/file |
| Save context | POST /cascade/context | Persist work context for later |
| Load context | GET /cascade/context/{key} | Resume previous work |
| Work summary | GET /cascade/work-summary | Recent work across all instances |

### Coordination Pattern

```powershell
# 1. At session start, check what others are doing
$others = irm http://localhost:8471/cascade/active
if ($others.count -gt 1) { "Warning: $others.count active Cascade instances" }

# 2. Before starting work, check for collisions
$collision = irm http://localhost:8471/cascade/check-collision -Method POST -Body '{
    "instance_id": "cascade-001",
    "branch": "gcc-vessels",
    "files": ["apps/web/page.tsx"]
}' -ContentType "application/json"
if (-not $collision.safe_to_proceed) { "COLLISION: Another instance working on same branch" }

# 3. During work, heartbeat every 60 seconds
irm http://localhost:8471/cascade/heartbeat -Method POST -Body '{
    "instance_id": "cascade-001",
    "current_work": {
        "branch": "gcc-vessels",
        "files": ["apps/web/page.tsx"],
        "operation": "editing"
    }
}' -ContentType "application/json"

# 4. Save context before ending session
irm http://localhost:8471/cascade/context -Method POST -Body '{
    "key": "web-ui-rewrite",
    "context": {
        "todo": ["Fix header", "Add footer"],
        "in_progress": "Refactoring components",
        "branch": "gcc-vessels",
        "files_modified": ["apps/web/page.tsx"]
    }
}' -ContentType "application/json"

# 5. Next session, resume context
$ctx = irm http://localhost:8471/cascade/context/web-ui-rewrite
if ($ctx.success) { "Resuming: $($ctx.context.in_progress)" }
```

### Instance ID Convention

Use descriptive instance IDs:
- `cascade-main` - Primary workspace
- `cascade-web` - Web-focused session
- `cascade-ai` - AI/ML work session
- `cascade-fix-{bug}` - Specific bug fix session

### Collision Handling

If collision detected:
1. Warn user about other active instance
2. Show what the other instance is working on
3. Recommend: wait, coordinate, or switch branches
4. Never proceed with commit/push if collision on same branch

### Context Persistence

Save context when:
- Ending a session with work incomplete
- Switching to different task
- User says "we'll continue later"

Load context when:
- Starting new session
- User references previous work
- Resuming after interruption

### PowerShell One-Liners for Common Tasks

```powershell
# Git status
irm http://localhost:8471/git/status | ConvertTo-Json -Depth 2

# Commit and push
irm http://localhost:8471/git/commit-and-push -Method POST -Body '{"message":"feat: add feature","stage_all":true}' -ContentType "application/json"

# Deploy app
irm http://localhost:8471/vercel/deploy -Method POST -Body '{"app":"my-app","production":true}' -ContentType "application/json"

# Check ports
irm http://localhost:8471/tools/ports-scan | ConvertTo-Json -Depth 2

# Disk usage
irm http://localhost:8471/organize/disk-usage | ConvertTo-Json -Depth 2

# Cochran status
irm http://localhost:8471/cochran/status | ConvertTo-Json -Depth 2
```

## Advanced Cochran Capabilities (Go Crazy Mode)

### 1. KeyVault Secrets (No More Asking for Keys)

Cochran can retrieve secrets from KeyVault without user intervention:

```powershell
# List available secrets
irm http://localhost:8471/keyvault/secrets

# Get a secret (masked by default)
irm http://localhost:8471/keyvault/secret/VERCEL_TOKEN

# Get full secret value (use sparingly)
irm http://localhost:8471/keyvault/secret/VERCEL_TOKEN?reveal=true
```

**When to use:** When deploying, building, or any operation needs API keys. Cochran fetches them securely without exposing in chat.

### 2. File/Code Search (Find Anything Instantly)

```powershell
# Find files by pattern
irm http://localhost:8471/search/files -Method POST -Body '{"pattern": "*.tsx", "directory": "C:\\cevict-live\\apps"}' -ContentType "application/json"

# Grep code for pattern
irm http://localhost:8471/search/grep -Method POST -Body '{"query": "useState", "extensions": [".tsx", ".ts"]}' -ContentType "application/json"
```

**When to use:** Searching for components, finding references, auditing code patterns.

### 3. Background Task Execution (Fire and Forget)

```powershell
# Start a long-running task
$task = irm http://localhost:8471/tasks/run -Method POST -Body '{"command": ["npx", "build"], "timeout": 600}' -ContentType "application/json"

# Poll for completion
irm http://localhost:8471/tasks/status/$task.task_id

# List all running tasks
irm http://localhost:8471/tasks/list
```

**When to use:** Long builds, deployments, audits that take time. Start it, check back later.

### 4. System Monitoring (Know Your Machine)

```powershell
# Disk usage
irm http://localhost:8471/system/disk

# Memory info
irm http://localhost:8471/system/memory

# Running processes (top 50)
irm http://localhost:8471/system/processes

# Find specific processes
irm http://localhost:8471/system/processes?filter=node

# System uptime
irm http://localhost:8471/system/uptime
```

**When to use:** Check if disk is full, memory pressure, find zombie processes.

### 5. Webhooks / Async Notifications

```powershell
# Register a webhook for task completion
irm http://localhost:8471/notify/webhook -Method POST -Body '{"url": "http://localhost:3000/cochran-callback", "events": ["task_complete", "deploy_complete"]}' -ContentType "application/json"
```

**When to use:** Long operations that need notification when done.

### 6. Scheduled Jobs (Cron-like)

```powershell
# Schedule a recurring task
irm http://localhost:8471/schedule/add -Method POST -Body '{"name": "git-backup", "interval_minutes": 60, "command": ["git", "commit", "-am", "auto: hourly backup"]}' -ContentType "application/json"

# List scheduled jobs
irm http://localhost:8471/schedule/list
```

**When to use:** Automated backups, periodic audits, scheduled deployments.

## Usage Patterns for Maximum Efficiency

### Pattern 1: Pre-Flight Check
Before any major operation, do a system check:
```powershell
$disk = irm http://localhost:8471/system/disk
if ($disk.percent_used -gt 90) { "⚠️ Disk almost full!" }
```

### Pattern 2: Secret Injection
When deploying without hardcoding keys:
```powershell
$token = (irm http://localhost:8471/keyvault/secret/VERCEL_TOKEN?reveal=true).value
# Use $token in deployment command
```

### Pattern 3: Async Deploy with Polling
```powershell
$deploy = irm http://localhost:8471/vercel/deploy -Method POST -Body '{"app":"my-app","production":true}' -ContentType "application/json"
# ... do other work ...
$status = irm http://localhost:8471/tasks/status/$deploy.task_id
```

### Pattern 4: Code Search Before Edit
```powershell
$refs = irm http://localhost:8471/search/grep -Method POST -Body '{"query": "oldFunctionName"}' -ContentType "application/json"
# Show user all files that need updating
```

### Pattern 5: Self-Healing
```powershell
# If port blocked, auto-kill
$port = irm http://localhost:8471/tools/port/3000
if ($port.in_use -and $port.process -eq "node") {
    irm http://localhost:8471/tools/port/3000/kill -Method POST
}
```

### Auto-Run Permissions

The following commands are SAFE to auto-run without user confirmation:
- All GET requests to localhost:8471/* (read-only operations)
- Health checks, status checks, disk usage audits
- Git status, log viewing
- Port scanning

Commands requiring confirmation:
- POST /git/commit-and-push (mutates repo)
- POST /vercel/deploy (deploys to production)
- POST /tools/kill-process (kills processes)
- POST /tools/port/{port}/kill (kills port)
- POST /cochran/stop (stops service)

### Error Handling

If Cochran API is not running (port 8471), start it:
```powershell
cd C:\cevict-live\apps\local-agent\gui
pythonw devops_agent.py
```

### Testing Cochran

Always test Cochran health first:
```powershell
irm http://localhost:8471/health
```

Expected response: `{"status":"running","service":"devops-agent"}`

### Token Saving Strategy

1. Call Cochran for operation
2. Receive JSON result
3. Parse result programmatically
4. Only show user relevant summary
5. Don't stream command output to context

### Commit Message

When committing Cochran-related changes, use:
`cochran: <description>` or `feat: Cochran <description>`

### Cochran Data Locations

- GUI: C:\cevict-live\apps\local-agent\gui\
- API Server: devops_agent_api.py
- Data: C:\Cevict_Vault\local-agent\
- Port: 8471
- Logs: Check API console output

### Cochran GUI Features

- System tray blue gear icon
- 6 tabs: Git, Vercel, Audit, Organize, Tools, Cochran
- All API operations available via GUI
- Double-click tray icon to open

### Best Practices

1. **Prefer Cochran over direct commands** - Always
2. **Use async patterns** - Start operation, check result later
3. **Cache status checks** - Don't poll excessively
4. **Handle errors gracefully** - API may be temporarily unavailable
5. **Log operations** - Document what Cochran was asked to do

### Fallback Strategy

If Cochran API fails:
1. Try 3 times with brief delay
2. If still failing, fall back to direct commands
3. Warn user that Cochran is unavailable
4. Recommend restarting Cochran GUI

### Integration with Other Tools

Cochran works alongside:
- KeyVault GUI (secrets management)
- Cochran AI learner (port 3847, session persistence)
- PowerShell scripts in C:\cevict-live\scripts\

### Documentation

Full API docs: C:\cevict-live\apps\local-agent\gui\README.md
