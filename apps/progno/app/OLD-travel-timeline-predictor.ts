// Travel Timeline Predictor Module for Progno Sports Prediction Platform

export interface TravelInput {
  origin: string;
  destination: string;
  departureDate: Date;
  returnDate?: Date;
  transportMode: 'car' | 'plane' | 'train' | 'bus';
  budget?: number;
  preferences?: string[];
}

export interface TravelTimelinePrediction {
  timeline: TimelineEvent[];
  totalDuration: number;
  totalCost: number;
  recommendations: string[];
  riskFactors: string[];
  confidence: number;
  location?: string;
  analysisPeriod?: { startDate: string; endDate: string; daysAnalyzed: number };
  dataSource?: string;
  summary?: {
    avgScore: number;
    excellentDays: number;
    riskScore: number;
    goodDays?: number;
    fairDays?: number;
    poorDays?: number;
    bestWeek?: string;
  };
  bestDates?: Array<{
    date: string;
    recommendation: string;
    overallScore: number;
    weatherScore: number;
    fishingScore: number;
    fishActivityScore: number;
    tideScore: number;
    travelScore: number;
    reasons?: string[];
    notes?: string;
  }>;
}

export interface TimelineEvent {
  startTime: Date;
  endTime: Date;
  type: 'travel' | 'activity' | 'rest' | 'meal';
  description: string;
  location: string;
  cost?: number;
  duration: number;
}

export interface WeatherForecast {
  date: Date;
  temperature: number;
  conditions: string;
  precipitation: number;
  windSpeed: number;
}

// Main prediction function
export function predictTravelTimeline(input: TravelInput): TravelTimelinePrediction {
  const { origin, destination, departureDate, returnDate, transportMode, budget, preferences } = input;
  const daysAnalyzed = returnDate
    ? Math.max(1, Math.round((returnDate.getTime() - departureDate.getTime()) / (1000 * 60 * 60 * 24)) + 1)
    : 1;
  const analysisPeriod = {
    startDate: departureDate.toISOString().split("T")[0],
    endDate: (returnDate || departureDate).toISOString().split("T")[0],
    daysAnalyzed
  };

  // Generate timeline events
  const timeline = generateTimelineEvents(input);

  // Calculate total duration and cost
  const totalDuration = calculateTotalDuration(timeline);
  const totalCost = calculateTotalCost(timeline);

  // Generate recommendations
  const recommendations = generateRecommendations(input, timeline);

  // Identify risk factors
  const riskFactors = identifyTravelRiskFactors(input, timeline);

  // Calculate confidence
  const confidence = calculatePredictionConfidence(input, timeline);

  return {
    timeline,
    totalDuration,
    totalCost,
    recommendations,
    riskFactors,
    confidence,
    location: destination,
    analysisPeriod,
    dataSource: "progno-travel-sim",
    summary: {
      avgScore: Math.min(99, Math.round(confidence * 100)),
      excellentDays: Math.max(0, Math.floor((analysisPeriod.daysAnalyzed || 1) * 0.3)),
      goodDays: Math.max(0, Math.floor((analysisPeriod.daysAnalyzed || 1) * 0.2)),
      fairDays: Math.max(0, Math.floor((analysisPeriod.daysAnalyzed || 1) * 0.35)),
      poorDays: Math.max(0, Math.floor((analysisPeriod.daysAnalyzed || 1) * 0.15)),
      bestWeek: `${analysisPeriod.startDate} to ${analysisPeriod.endDate}`,
      riskScore: Math.round((1 - confidence) * 100)
    },
    bestDates: [analysisPeriod.startDate, analysisPeriod.endDate]
      .filter(Boolean)
      .map((d, idx) => ({
        date: d,
        recommendation: idx === 0 ? "excellent" : "good",
        overallScore: Math.max(50, Math.min(99, Math.round(confidence * 100) - idx * 5)),
        weatherScore: Math.max(50, Math.min(99, Math.round(confidence * 100))),
        fishingScore: Math.max(40, Math.min(95, Math.round(confidence * 100) - 10)),
        fishActivityScore: Math.max(40, Math.min(95, Math.round(confidence * 100) - 12)),
        tideScore: Math.max(40, Math.min(95, Math.round(confidence * 100) - 8)),
        travelScore: Math.max(50, Math.min(99, Math.round(confidence * 100) - 5)),
        reasons: ["Solid weather window", "Manageable travel timing"],
        notes: "Generated by travel-timeline predictor"
      }))
  };
}

// Generate timeline events
function generateTimelineEvents(input: TravelInput): TimelineEvent[] {
  const events: TimelineEvent[] = [];
  const { origin, destination, departureDate, returnDate, transportMode } = input;

  // Travel to destination
  const travelDuration = getTravelDuration(origin, destination, transportMode);
  const arrivalTime = new Date(departureDate.getTime() + travelDuration * 60 * 60 * 1000);

  events.push({
    startTime: departureDate,
    endTime: arrivalTime,
    type: 'travel',
    description: `Travel from ${origin} to ${destination} by ${transportMode}`,
    location: origin,
    cost: getTravelCost(origin, destination, transportMode),
    duration: travelDuration
  });

  // Activities at destination
  const stayDuration = returnDate ?
    (returnDate.getTime() - arrivalTime.getTime()) / (1000 * 60 * 60) :
    24; // Default 24 hours if no return date

  const activities = generateActivities(destination, arrivalTime, stayDuration);
  events.push(...activities);

  // Return travel (if return date specified)
  if (returnDate) {
    const returnDeparture = new Date(returnDate.getTime() - travelDuration * 60 * 60 * 1000);
    const returnArrival = new Date(returnDate.getTime());

    events.push({
      startTime: returnDeparture,
      endTime: returnArrival,
      type: 'travel',
      description: `Return from ${destination} to ${origin} by ${transportMode}`,
      location: destination,
      cost: getTravelCost(destination, origin, transportMode),
      duration: travelDuration
    });
  }

  return events.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
}

// Generate activities at destination
function generateActivities(destination: string, arrivalTime: Date, duration: number): TimelineEvent[] {
  const activities: TimelineEvent[] = [];
  const currentTime = new Date(arrivalTime);

  // Rest after travel
  activities.push({
    startTime: new Date(currentTime),
    endTime: new Date(currentTime.getTime() + 2 * 60 * 60 * 1000),
    type: 'rest',
    description: 'Rest and unpack after travel',
    location: destination,
    duration: 2
  });

  currentTime.setTime(currentTime.getTime() + 2 * 60 * 60 * 1000);

  // Main activities based on destination type
  const destinationType = classifyDestination(destination);
  const mainActivities = getActivitiesForDestinationType(destinationType);

  mainActivities.forEach((activity, index) => {
    const activityDuration = 3 + Math.random() * 2; // 3-5 hours per activity
    activities.push({
      startTime: new Date(currentTime),
      endTime: new Date(currentTime.getTime() + activityDuration * 60 * 60 * 1000),
      type: 'activity',
      description: activity,
      location: destination,
      cost: Math.round(50 + Math.random() * 100),
      duration: Math.round(activityDuration)
    });

    currentTime.setTime(currentTime.getTime() + activityDuration * 60 * 60 * 1000);

    // Add meal breaks
    if (index < mainActivities.length - 1) {
      activities.push({
        startTime: new Date(currentTime),
        endTime: new Date(currentTime.getTime() + 1 * 60 * 60 * 1000),
        type: 'meal',
        description: 'Meal break',
        location: destination,
        cost: Math.round(20 + Math.random() * 30),
        duration: 1
      });

      currentTime.setTime(currentTime.getTime() + 1 * 60 * 60 * 1000);
    }
  });

  return activities;
}

// Classify destination type
function classifyDestination(destination: string): 'beach' | 'city' | 'mountain' | 'historical' | 'entertainment' {
  const destinationLower = destination.toLowerCase();

  if (destinationLower.includes('beach') || destinationLower.includes('coast') || destinationLower.includes('shore')) {
    return 'beach';
  } else if (destinationLower.includes('mountain') || destinationLower.includes('park') || destinationLower.includes('hiking')) {
    return 'mountain';
  } else if (destinationLower.includes('museum') || destinationLower.includes('historic') || destinationLower.includes('monument')) {
    return 'historical';
  } else if (destinationLower.includes('disney') || destinationLower.includes('park') || destinationLower.includes('resort')) {
    return 'entertainment';
  } else {
    return 'city';
  }
}

// Get activities for destination type
function getActivitiesForDestinationType(type: string): string[] {
  const activities: { [key: string]: string[] } = {
    beach: [
      'Beach relaxation and swimming',
      'Water sports or beach volleyball',
      'Sunset viewing and beach walk',
      'Local seafood dining'
    ],
    city: [
      'City sightseeing tour',
      'Visit local museums or galleries',
      'Shopping and local markets',
      'Fine dining experience'
    ],
    mountain: [
      'Hiking and nature walks',
      'Scenic viewpoint visit',
      'Wildlife watching',
      'Campfire or outdoor dining'
    ],
    historical: [
      'Historical site tours',
      'Museum visits',
      'Cultural performances',
      'Traditional cuisine experience'
    ],
    entertainment: [
      'Theme park attractions',
      'Shows and entertainment',
      'Character meet and greets',
      'Themed dining experiences'
    ]
  };

  return activities[type] || activities.city;
}

// Get travel duration (hours)
function getTravelDuration(origin: string, destination: string, mode: string): number {
  const baseDurations: { [key: string]: number } = {
    car: 8,
    plane: 4,
    train: 12,
    bus: 10
  };

  const baseDuration = baseDurations[mode] || 8;
  const distanceFactor = Math.random() * 0.5 + 0.75; // 0.75 to 1.25 multiplier

  return Math.round(baseDuration * distanceFactor);
}

// Get travel cost
function getTravelCost(origin: string, destination: string, mode: string): number {
  const baseCosts: { [key: string]: number } = {
    car: 100,
    plane: 300,
    train: 150,
    bus: 80
  };

  const baseCost = baseCosts[mode] || 100;
  const distanceFactor = Math.random() * 0.5 + 0.75;

  return Math.round(baseCost * distanceFactor);
}

// Calculate total duration
function calculateTotalDuration(timeline: TimelineEvent[]): number {
  if (timeline.length === 0) return 0;

  const start = timeline[0].startTime;
  const end = timeline[timeline.length - 1].endTime;

  return Math.round((end.getTime() - start.getTime()) / (1000 * 60 * 60));
}

// Calculate total cost
function calculateTotalCost(timeline: TimelineEvent[]): number {
  return timeline.reduce((total, event) => total + (event.cost || 0), 0);
}

// Generate recommendations
function generateRecommendations(input: TravelInput, timeline: TimelineEvent[]): string[] {
  const recommendations: string[] = [];

  // Budget recommendations
  if (input.budget) {
    const totalCost = calculateTotalCost(timeline);
    if (totalCost > input.budget) {
      recommendations.push('Consider reducing activity costs or extending budget');
    } else {
      recommendations.push('Current plan fits within budget');
    }
  }

  // Transport recommendations
  if (input.transportMode === 'car' && calculateTotalDuration(timeline) > 12) {
    recommendations.push('Consider flying for longer trips to reduce fatigue');
  }

  // Timing recommendations
  const departureHour = input.departureDate.getHours();
  if (departureHour < 6 || departureHour > 22) {
    recommendations.push('Consider departing during daytime hours for better visibility');
  }

  // Activity recommendations
  const activities = timeline.filter(event => event.type === 'activity');
  if (activities.length > 5) {
    recommendations.push('Packed itinerary - consider adding more rest time');
  } else if (activities.length < 2) {
    recommendations.push('Light schedule - consider adding more activities');
  }

  return recommendations;
}

// Identify risk factors
function identifyTravelRiskFactors(input: TravelInput, timeline: TimelineEvent[]): string[] {
  const riskFactors: string[] = [];

  // Weather risks
  const departureMonth = input.departureDate.getMonth();
  if (departureMonth >= 11 || departureMonth <= 2) {
    riskFactors.push('Winter weather may cause travel delays');
  } else if (departureMonth >= 6 && departureMonth <= 8) {
    riskFactors.push('Peak season - expect crowds and higher prices');
  }

  // Transport risks
  if (input.transportMode === 'car' && calculateTotalDuration(timeline) > 16) {
    riskFactors.push('Long drive - plan for rest stops and overnight stays');
  }

  // Budget risks
  if (input.budget) {
    const totalCost = calculateTotalCost(timeline);
    if (totalCost > input.budget * 0.9) {
      riskFactors.push('Budget nearly exceeded - monitor spending closely');
    }
  }

  // Timing risks
  const departureHour = input.departureDate.getHours();
  if (departureHour < 5 || departureHour > 23) {
    riskFactors.push('Unusual departure time - limited services available');
  }

  return riskFactors;
}

// Calculate prediction confidence
function calculatePredictionConfidence(input: TravelInput, timeline: TimelineEvent[]): number {
  let confidence = 0.8; // Base confidence

  // Adjust based on data completeness
  if (!input.returnDate) confidence -= 0.1;
  if (!input.budget) confidence -= 0.05;
  if (!input.preferences || input.preferences.length === 0) confidence -= 0.05;

  // Adjust based on destination familiarity
  const commonDestinations = ['new york', 'los angeles', 'chicago', 'miami', 'orlando'];
  const isCommonDestination = commonDestinations.some(dest =>
    input.destination.toLowerCase().includes(dest)
  );

  if (isCommonDestination) {
    confidence += 0.1;
  }

  return Math.max(0.3, Math.min(1.0, confidence));
}

// Get weather forecast for travel dates (using real API with fallback)
export async function getWeatherForecast(destination: string, startDate: Date, endDate: Date): Promise<WeatherForecast[]> {
  try {
    // Try to use real geocoding and weather APIs
    const { geocodeLocation, getWeatherForecast: getRealWeather } = await import('./public-apis-integration');

    // Geocode destination
    const location = await geocodeLocation(destination);
    if (location) {
      const lat = parseFloat(location.lat);
      const lon = parseFloat(location.lon);

      // Get real weather data
      const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
      const weatherData = await getRealWeather(lat, lon, days);

      if (weatherData && weatherData.time) {
        // Convert API data to our format
        const forecasts: WeatherForecast[] = [];
        const temps = weatherData.temperature_2m_max || [];
        const precip = weatherData.precipitation_sum || [];
        const wind = weatherData.windspeed_10m_max || [];
        const codes = weatherData.weathercode || [];

        for (let i = 0; i < weatherData.time.length; i++) {
          const date = new Date(weatherData.time[i]);
          if (date >= startDate && date <= endDate) {
            // Map weather codes to conditions
            const code = codes[i] || 0;
            let conditions = 'Clear';
            if (code >= 1 && code <= 3) conditions = 'Partly Cloudy';
            else if (code >= 45 && code <= 48) conditions = 'Foggy';
            else if (code >= 51 && code <= 67) conditions = 'Rain';
            else if (code >= 71 && code <= 77) conditions = 'Snow';
            else if (code >= 80 && code <= 82) conditions = 'Rain Showers';
            else if (code >= 95 && code <= 99) conditions = 'Thunderstorm';

            forecasts.push({
              date,
              temperature: Math.round(temps[i] || 20),
              conditions,
              precipitation: precip[i] || 0,
              windSpeed: Math.round(wind[i] || 10)
            });
          }
        }

        if (forecasts.length > 0) {
          return forecasts;
        }
      }
    }
  } catch (error) {
    console.warn('Failed to fetch real weather, using fallback:', error);
  }

  // Fallback to mock data if API fails
  const forecasts: WeatherForecast[] = [];
  const current = new Date(startDate);

  while (current <= endDate) {
    forecasts.push({
      date: new Date(current),
      temperature: Math.round(60 + Math.random() * 30),
      conditions: ['Sunny', 'Partly Cloudy', 'Cloudy', 'Light Rain'][Math.floor(Math.random() * 4)],
      precipitation: Math.random() * 0.8,
      windSpeed: Math.round(5 + Math.random() * 15)
    });

    current.setDate(current.getDate() + 1);
  }

  return forecasts;
}

// Optimize timeline based on preferences
export function optimizeTimeline(timeline: TimelineEvent[], preferences: string[]): TimelineEvent[] {
  const optimized = [...timeline];

  // Sort by preference-based priorities
  if (preferences.includes('relaxation')) {
    optimized.sort((a, b) => {
      if (a.type === 'rest') return -1;
      if (b.type === 'rest') return 1;
      return 0;
    });
  }

  if (preferences.includes('activities')) {
    optimized.sort((a, b) => {
      if (a.type === 'activity') return -1;
      if (b.type === 'activity') return 1;
      return 0;
    });
  }

  return optimized;
}
