DOCTYPE html>
<html lang="en">
<!
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PROGNO ‚Äî TV Wallboard</title>
  <style>
    :root {
      --bg: #0b0f17;
      --surface: #101625;
      --surface2: #121a2c;
      --text: #e6edf7;
      --muted: #94a3b8;
      --green: #34d399;
      /* OK */
      --yellow: #fbbf24;
      /* WARN */
      --red: #fb7185;
      /* CRIT */
      --blue: #60a5fa;
    }

    /* ---- Odds fetching and line-move deltas ----
    async function fetchOdds(sport) {
      const url=`$ {
        baseUrl()
      }

      /api/progno/v2?action=games&sport=$ {
        encodeURIComponent(sport)
      }

      `;

      try {
        const res=await fetch(url, {
          cache: 'no-store'
        });
      if ( !res.ok) return [];
      const j=await res.json();
      const arr=Array.isArray(j?.data) ? j.data : [];

      return arr.map(g=> ({

          id: g.id,
          home: g.homeTeam,
          away: g.awayTeam,
          startTime: g.startTime,
          odds: {
            mlHome: g.odds?.moneyline?.home ?? null,
            mlAway: g.odds?.moneyline?.away ?? null,
            spreadHome: g.odds?.spread?.home ?? null,
            total: g.odds?.total?.line ?? null,
          }
        }));
    }

    catch {
      return []
    }
    }

    function keyTeams(home, away) {
      return `$ {
        String(home || '').toLowerCase()
      }

      __$ {
        String(away || '').toLowerCase()
      }

      `;
    }

    function isTrackedPick(home, away) {
      const k1=keyTeams(home, away);
      const k2=keyTeams(away, home);
      return picksIndex.byTeams.has(k1) || picksIndex.byTeams.has(k2);
    }

    function diffOddsAndAlert(prevMap, currList) {
      const ML_RED=12,
      ML_YELLOW=8; // cents
      const SPREAD_RED=0.75,
      SPREAD_YELLOW=0.5;
      const TOTAL_RED=1.0,
      TOTAL_YELLOW=0.5;

      for (const g of currList) {
        const prev=prevMap.get(g.id);

        if (prev) {
          const p=prev.odds || {}

          ;

          const c=g.odds || {}

          ;
          const dmh=deltaNum(c.mlHome, p.mlHome);
          const dma=deltaNum(c.mlAway, p.mlAway);
          const dsh=deltaNum(c.spreadHome, p.spreadHome);
          const dt=deltaNum(c.total, p.total);
          const tracked=isTrackedPick(g.home, g.away);
          const mlMove=Math.max(Math.abs(dmh || 0), Math.abs(dma || 0));

          if (mlMove >=ML_RED) alertPush('red', tracked ? 'Pick ML move' : 'ML move', `$ {
              g.away
            }

            @ $ {
              g.home
            }

            Œî$ {
              mlMove
            }

            (H $ {
                fmtOdds(c.mlHome)
              }

              , A $ {
                fmtOdds(c.mlAway)
              })`);

          else if (mlMove >=ML_YELLOW) alertPush('yellow', 'ML move', `$ {
              g.away
            }

            @ $ {
              g.home
            }

            Œî$ {
              mlMove
            }

            `);

          if (Math.abs(dsh || 0) >=SPREAD_RED) alertPush('red', tracked ? 'Pick Spread move' : 'Spread move', `$ {
              g.away
            }

            @ $ {
              g.home
            }

            Œî$ {
              (dsh ?? 0).toFixed(2)
            }

            `);

          else if (Math.abs(dsh || 0) >=SPREAD_YELLOW) alertPush('yellow', 'Spread move', `$ {
              g.away
            }

            @ $ {
              g.home
            }

            Œî$ {
              (dsh ?? 0).toFixed(2)
            }

            `);

          if (Math.abs(dt || 0) >=TOTAL_RED) alertPush('red', 'Total move', `$ {
              g.away
            }

            @ $ {
              g.home
            }

            Œî$ {
              (dt ?? 0).toFixed(2)
            }

            `);

          else if (Math.abs(dt || 0) >=TOTAL_YELLOW) alertPush('yellow', 'Total move', `$ {
              g.away
            }

            @ $ {
              g.home
            }

            Œî$ {
              (dt ?? 0).toFixed(2)
            }

            `);
        }

        lastOddsById.set(g.id, g);
      }
    }

    function deltaNum(a, b) {
      if (a==null || b==null) return null;
      const da=Number(a) - Number(b);
      return Number.isFinite(da) ? Math.round(da): null
    }

    function fmtOdds(n) {
      if (n==null) return '‚Äî';
      const x=Number(n);

      return x>0 ? `+$ {
        x
      }

      ` : String(x);
    }

    */
    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 20% -10%, #182036 0%, #0b0f17 60%), #0b0f17;
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.3fr 0.7fr;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
      padding: 16px;
      height: 100%;
    }

    .header {
      grid-column: 1 / span 2;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: var(--surface2);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 10px;
    }

    .brand {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }

    .brand h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.04em;
    }

    .brand .sub {
      color: var(--muted);
      font-size: 14px;
    }

    .clock {
      font-variant-numeric: tabular-nums;
      font-size: 18px;
      color: var(--muted);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--muted);
      font-size: 12px;
    }

    .pill {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 9999px;
      padding: 4px 10px;
      color: var(--text);
      cursor: pointer;
    }


    .panel {
      background: var(--surface);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel h2 {
      margin: 0;
      padding: 10px 14px;
      font-size: 16px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
      background: var(--surface2);
      border-bottom: 1px solid rgba(148, 163, 184, 0.15);
    }

    .scores {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      padding: 12px;
      overflow: auto;
    }

    .score-card {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(148, 163, 184, 0.16);
      border-radius: 10px;
      padding: 10px 12px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
    }

    /* Scoring swing animation */
    .game-card {
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
    }
    .game-card.swing-good {
      transform: scale(1.06);
      box-shadow: 0 0 25px rgba(52, 211, 153, 0.8);
      border-color: var(--green);
    }
    .game-card.swing-bad {
      transform: scale(1.06);
      box-shadow: 0 0 25px rgba(251, 113, 133, 0.85);
      border-color: var(--red);
    }

    .teams {
      font-weight: 700;
      font-size: 18px;
      letter-spacing: 0.02em;
    }

    .meta {
      color: var(--muted);
      font-size: 12px;
    }

    .score {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 24px;
      font-weight: 800;
    }

    .badge {
      padding: 2px 8px;
      border-radius: 9999px;
      font-size: 11px;
      border: 1px solid currentColor;
      align-self: start;
    }

    .badge.green {
      color: var(--green);
    }

    .badge.yellow {
      color: var(--yellow);
    }

    .badge.red {
      color: var(--red);
    }

    .alerts {
      padding: 8px;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .alert {
      display: grid;
      grid-template-columns: 16px 1fr auto;
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      background: rgba(255, 255, 255, 0.02);
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 9999px;
    }

    .dot.green {
      background: var(--green);
      box-shadow: 0 0 16px rgba(52, 211, 153, 0.6);
    }

    .dot.yellow {
      background: var(--yellow);
      box-shadow: 0 0 16px rgba(251, 191, 36, 0.6);
    }

    .dot.red {
      background: var(--red);
      box-shadow: 0 0 16px rgba(251, 113, 133, 0.6);
    }

    .alert .title {
      font-weight: 700;
      font-size: 14px;
    }

    .alert .desc {
      color: var(--muted);
      font-size: 12px;
    }

    .alert .time {
      color: var(--muted);
      font-size: 12px;
      font-variant-numeric: tabular-nums;
    }

    .ticker {
      grid-column: 1 / span 2;
      background: var(--surface2);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 10px;
      overflow: hidden;
      display: flex;
      align-items: center;
    }

    .ticker .band {
      background: rgba(96, 165, 250, 0.08);
      padding: 8px 12px;
      font-weight: 700;
      color: var(--blue);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      border-right: 1px solid rgba(148, 163, 184, 0.2);
    }

    .ticker .marquee {
      overflow: hidden;
      position: relative;
    }

    .ticker .scroll {
      white-space: nowrap;
      display: inline-block;
      padding-left: 100%;
      animation: scroll 45s linear infinite;
    }

    .ticker .item {
      margin-right: 48px;
      color: var(--muted);
    }

    .ticker .imp {
      color: var(--red);
      font-weight: 700;
    }

    @keyframes scroll {
      from {
        transform: translateX(0);
      }

      to {
        transform: translateX(-100%);
      }
    }

    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 12px;
    }

    .small {
      color: var(--muted);
      font-size: 12px;
    }

    .footer {
      grid-column: 1 / span 2;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--muted);
      font-size: 12px;
      padding: 8px 2px;
    }

    .legend {
      display: flex;
      gap: 14px;
      align-items: center;
    }

    .legend .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend .swatch {
      width: 10px;
      height: 10px;
      border-radius: 9999px;
    }

    .swatch.green {
      background: var(--green);
    }

    .swatch.yellow {
      background: var(--yellow);
    }

    .swatch.red {
      background: var(--red);
    }

    @media (min-width: 1600px) {
      .scores {
        grid-template-columns: repeat(3, 1fr);
      }

      .teams {
        font-size: 20px;
      }

      .score {
        font-size: 28px;
      }
    }
  </style>
</head>

<body>
  <div class="layout">
    <div class="header">
      <div class="brand">
        <h1>PROGNO ‚Ä¢ TV Wallboard</h1>
        <div class="sub" id="sportLabel">Rotating: NBA, NCAAB, NHL...</div>
      </div>
      <div class="controls">
        <span class="pill" id="soundPill" title="Toggle sound (M)">üîä Sound: On</span>
        <span class="pill" id="pastePicks" title="Paste picks JSON (P)">üìã Paste Picks</span>
        <span class="pill" id="pasteBets" title="Paste my bets JSON (B)">üíº Paste Bets</span>
        <span class="pill" id="loadKalshi" title="Load Kalshi positions (stub)">üìà Kalshi</span>
        <span class="pill" id="loadPoly" title="Load Polymarket positions (stub)">ü™ô Polymarket</span>
        <span class="pill" id="testAlert" title="Trigger a test alert (T)">üß™ Test Alert</span>
        <span class="pill" id="loadTodayPreds" title="Load today‚Äôs predictions (L)">üìÖ Today‚Äôs Predictions</span>
        <span class="pill" id="loadTodayEarly" title="Load today‚Äôs early-lines (E)">ü©∫ Early Lines</span>
        <span class="pill" id="testAudio" title="Play crowd then boo">üîä Test Audio</span>
        <span class="pill" title="Keyboard: M/P/B/T for Sound/Picks/Bets/Test">‚å®Ô∏è Help</span>
      </div>
      <div class="clock" id="clock">--:--:--</div>
    </div>

    <div class="panel" style="grid-column: 1 / span 1;">
      <h2>Live Scores</h2>
      <div class="scores" id="scores"></div>
    </div>

    <div class="panel" style="grid-column: 2 / span 1;">
      <h2>Alerts</h2>
      <div class="alerts" id="alerts"></div>
      <div class="row small">
        <div>Auto-generated from score changes, lead changes, start windows, and injury hooks.</div>
      </div>
    </div>

    <div class="panel" style="grid-column: 2 / span 1;">
      <h2>My Bets</h2>
      <div class="alerts" id="myBets"></div>
      <div class="row small"><div>Paste Bets or auto-load to track bankroll and results.</div></div>
    </div>

    <div class="ticker">
      <div class="band">Live Ticker</div>
      <div class="marquee">
        <div class="scroll" id="ticker">
          <span class="item imp">Welcome ‚Äî concept wallboard. Red = critical, Yellow = medium, Green = all good.</span>
          <span class="item">Last-minute line moves and injuries will surface here when wired.</span>
          <span class="item">Use in full-screen on a TV for best visibility.</span>
        </div>
      </div>
    </div>

    <div class="footer">
      <div class="legend">
        <span class="pill"><span class="swatch red"></span> Critical</span>
        <span class="pill"><span class="swatch yellow"></span> Medium</span>
        <span class="pill"><span class="swatch green"></span> Informational</span>
      </div>
      <div>Data refresh: <span id="refreshInfo">‚Äî</span></div>
    </div>
  </div>

  <script>
    const SPORTS = ['nba', 'ncaab', 'nhl', 'mlb', 'nfl'];
    let sportIdx = 0;
    let lastScoresById = new Map();
    let lastOddsById = new Map();
    let picksIndex = { byTeams: new Map(), raw: [] };
    let muted = false;
    let audioReady = false;
    let AC = null;
    const scoresEl = document.getElementById('scores');
    const alertsEl = document.getElementById('alerts');
    const clockEl = document.getElementById('clock');
    const refreshEl = document.getElementById('refreshInfo');
    const sportLabelEl = document.getElementById('sportLabel');
    const soundPill = document.getElementById('soundPill');
    const pasteBtn = document.getElementById('pastePicks');
    const testBtn = document.getElementById('testAlert');
    const pasteBetsBtn = document.getElementById('pasteBets');
    const loadKalshiBtn = document.getElementById('loadKalshi');
    const loadPolyBtn = document.getElementById('loadPoly');
    const myBetsEl = document.getElementById('myBets');
    let myBets = [];
    const loadTodayPredsBtn = document.getElementById('loadTodayPreds');
    const loadTodayEarlyBtn = document.getElementById('loadTodayEarly');
    const testAudioBtn = document.getElementById('testAudio');
    // Early-lines store
    let earlyLinesByKey = {};

    function two(n) { return n < 10 ? '0' + n : n }
    function nowStr() { const d = new Date(); return `${two(d.getHours())}:${two(d.getMinutes())}:${two(d.getSeconds())}` }
    setInterval(() => { clockEl.textContent = nowStr(); }, 1000);

    function baseUrl() { try { const u = new URL(window.location.href); return `${u.origin}`; } catch { return 'http://localhost:3008'; } }

    function alertPush(sev, title, desc) {
      const wrap = document.createElement('div');
      wrap.className = 'alert';
      const dot = document.createElement('div'); dot.className = 'dot ' + sev;
      const content = document.createElement('div');
      const t = document.createElement('div'); t.className = 'title'; t.textContent = title;
      const d = document.createElement('div'); d.className = 'desc'; d.textContent = desc || '';
      content.appendChild(t); content.appendChild(d);
      const time = document.createElement('div'); time.className = 'time'; time.textContent = nowStr();
      wrap.appendChild(dot); wrap.appendChild(content); wrap.appendChild(time);
      alertsEl.prepend(wrap);
      // Limit alerts
      const max = 30; while (alertsEl.children.length > max) { alertsEl.removeChild(alertsEl.lastChild); }
      // Sounds by severity
      if (sev === 'red') playTone(880, 0.25); else if (sev === 'yellow') playTone(660, 0.18); else playTone(440, 0.12);
      // Ticker enrichment
      pushTicker(`${title}: ${desc}`, sev);
    }

    function statusBadge(completed) {
      if (completed) return '<span class="badge green">Final</span>';
      return '<span class="badge yellow">Live</span>';
    }

    function renderScores(list) {
      scoresEl.innerHTML = list.map(g => {
        const id = g.id;
        const score = `${g.homeScore ?? 0}‚Äì${g.awayScore ?? 0}`;
        const teams = `${g.away} @ ${g.home}`;
        const when = g.commence_time ? new Date(g.commence_time).toLocaleString(undefined, { hour: '2-digit', minute: '2-digit' }) : '';
        return `<div class="score-card game-card" data-game-id="${id}">
          <div>
            <div class="teams">${teams}</div>
            <div class="meta">${when}</div>
          </div>
          <div style="text-align:right">
            <div class="score">${score}</div>
            ${statusBadge(g.completed)}
          </div>
        </div>`;
      }).join('');
    }

    function triggerScoringSwing(gameId, goodForUs) {
      const el = document.querySelector(`[data-game-id="${CSS.escape(String(gameId))}"]`);
      if (!el) return;
      const cls = goodForUs ? 'swing-good' : 'swing-bad';
      el.classList.add(cls);
      setTimeout(() => el.classList.remove(cls), 1200);
    }

    function diffScoresAndAlert(prevMap, currList) {
      for (const g of currList) {
        const k = g.id;
        const prev = prevMap.get(k);
        const hs = Number(g.homeScore || 0), as = Number(g.awayScore || 0);
        if (prev) {
          const dh = hs - Number(prev.homeScore || 0);
          const da = as - Number(prev.awayScore || 0);
          if (dh > 0 || da > 0) {
            const who = dh > 0 && da > 0 ? 'Both score' : (dh > 0 ? g.home : g.away);
            const tracked = isTrackedPick(g.home, g.away);
            const title = tracked ? 'Progno pick scored' : 'Scoring play';
            alertPush('red', title, `${who} ‚Äî ${g.away} @ ${g.home} now ${hs}‚Äì${as}`);
            const bet = findBetForGame(g.home, g.away);
            if (bet) {
              const scoringTeam = (dh > 0) ? g.home : g.away;
              const mySideTeam = (String(bet.side || '').toLowerCase() === 'home') ? g.home :
                                 (String(bet.side || '').toLowerCase() === 'away') ? g.away :
                                 (bet.team || '');
              const good = normalizeTeam(scoringTeam) === normalizeTeam(mySideTeam);
              if (good) playCrowd(); else playBoo();
              triggerScoringSwing(g.id, !!good);
            }
          }
          const prevLead = Number(prev.homeScore || 0) - Number(prev.awayScore || 0);
          const lead = hs - as;
          if (Math.sign(prevLead) !== Math.sign(lead)) {
            alertPush('red', 'Lead change', `${g.away} @ ${g.home} ‚Äî ${hs}‚Äì${as}`);
            triggerScoringSwing(g.id, lead > 0); // simple: home lead good visual when positive
          }
        } else {
          // New game loaded ‚Äî pre-game soon window
          try {
            const start = g.commence_time ? new Date(g.commence_time).getTime() : 0;
            const mins = (start - Date.now()) / 60000;
            if (mins > 0 && mins <= 30) { alertPush('yellow', 'Starting soon', `${g.away} @ ${g.home} in ${Math.round(mins)}m`); }
          } catch (_) { }
        }
        lastScoresById.set(k, { homeScore: hs, awayScore: as });
      }
    }

    async function fetchScores(sport) {
      const url = `${baseUrl()}/api/progno/v2?action=live-scores&sport=${encodeURIComponent(sport)}`;
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) { refreshEl.textContent = `Fetch ${sport}: ${res.status}`; return []; }
        const data = await res.json();
        return data?.data || [];
      } catch (e) { refreshEl.textContent = `Fetch error: ${String(e).slice(0, 80)}`; return []; }
    }

    async function cycle() {
      const sport = SPORTS[sportIdx % SPORTS.length];
      sportLabelEl.textContent = `Rotating: ${SPORTS.map(s => s.toUpperCase()).join(', ')} ‚Äî Now: ${sport.toUpperCase()}`;
      const [list, odds] = await Promise.all([fetchScores(sport), fetchOdds(sport)]);
      diffScoresAndAlert(lastScoresById, list);
      diffOddsAndAlert(lastOddsById, odds);
      renderScores(list);
      refreshEl.textContent = `${sport.toUpperCase()} @ ${nowStr()} ‚Ä¢ ${list.length} games`;
      sportIdx++;
    }

    // Start loops
    cycle();
    setInterval(cycle, 15000); // rotate sport every 15s

    // ---- Ticker enrichment ----
    const tickerEl = document.getElementById('ticker');
    let tickerItems = [];
    function pushTicker(text, sev) {
      const cls = sev === 'red' ? 'imp' : '';
      tickerItems.push({ text, sev });
      if (tickerItems.length > 60) tickerItems.shift();
      tickerEl.innerHTML = tickerItems.map(i => `<span class="item ${i.sev === 'red' ? 'imp' : ''}">${escapeHtml(i.text)}</span>`).join(' ');
    }

    // ---- Odds & helpers (moved from <style>) ----
    function keyTeams(home, away) { return `${String(home || '').toLowerCase()}__${String(away || '').toLowerCase()}`; }
    function isTrackedPick(home, away) { const k1 = keyTeams(home, away); const k2 = keyTeams(away, home); return picksIndex.byTeams.has(k1) || picksIndex.byTeams.has(k2); }
    function deltaNum(a, b) { if (a == null || b == null) return null; const da = Number(a) - Number(b); return Number.isFinite(da) ? Math.round(da) : null; }
    function fmtOdds(n) { if (n == null) return '‚Äî'; const x = Number(n); return x > 0 ? `+${x}` : String(x); }
    function diffOddsAndAlert(prevMap, currList) {
      const ML_RED = 12, ML_YELLOW = 8;
      const SPREAD_RED = 0.75, SPREAD_YELLOW = 0.5;
      const TOTAL_RED = 1.0, TOTAL_YELLOW = 0.5;
      for (const g of currList) {
        const prev = prevMap.get(g.id);
        if (prev) {
          const p = prev.odds || {};
          const c = g.odds || {};
          const dmh = deltaNum(c.mlHome, p.mlHome);
          const dma = deltaNum(c.mlAway, p.mlAway);
          const dsh = deltaNum(c.spreadHome, p.spreadHome);
          const dt = deltaNum(c.total, p.total);
          const tracked = isTrackedPick(g.home, g.away);
          const mlMove = Math.max(Math.abs(dmh || 0), Math.abs(dma || 0));
          if (mlMove >= ML_RED) alertPush('red', tracked ? 'Pick ML move' : 'ML move', `${g.away} @ ${g.home} Œî${mlMove} (H ${fmtOdds(c.mlHome)}, A ${fmtOdds(c.mlAway)})`);
          else if (mlMove >= ML_YELLOW) alertPush('yellow', 'ML move', `${g.away} @ ${g.home} Œî${mlMove}`);
          if (Math.abs(dsh || 0) >= SPREAD_RED) alertPush('red', tracked ? 'Pick Spread move' : 'Spread move', `${g.away} @ ${g.home} Œî${(dsh ?? 0).toFixed(2)}`);
          else if (Math.abs(dsh || 0) >= SPREAD_YELLOW) alertPush('yellow', 'Spread move', `${g.away} @ ${g.home} Œî${(dsh ?? 0).toFixed(2)}`);
          if (Math.abs(dt || 0) >= TOTAL_RED) alertPush('red', 'Total move', `${g.away} @ ${g.home} Œî${(dt ?? 0).toFixed(2)}`);
          else if (Math.abs(dt || 0) >= TOTAL_YELLOW) alertPush('yellow', 'Total move', `${g.away} @ ${g.home} Œî${(dt ?? 0).toFixed(2)}`);
        }
        prevMap.set(g.id, g);
      }
    }
    async function fetchOdds(sport) {
      const url = `${baseUrl()}/api/progno/v2?action=games&sport=${encodeURIComponent(sport)}`;
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) return [];
        const j = await res.json();
        const arr = Array.isArray(j?.data) ? j.data : [];
        return arr.map(g => ({
          id: g.id,
          home: g.homeTeam,
          away: g.awayTeam,
          startTime: g.startTime,
          odds: {
            mlHome: g.odds?.moneyline?.home ?? null,
            mlAway: g.odds?.moneyline?.away ?? null,
            spreadHome: g.odds?.spread?.home ?? null,
            total: g.odds?.total?.line ?? null,
          }
        }));
      } catch { return []; }
    }

    // ---- Daily file loaders (predictions and early-lines) ----
    function ymd(d = new Date()) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }
    function todayPredsPaths() {
      const fname = `predictions-${ymd()}.json`;
      // try root, then /progno
      return [`/${fname}`, `/progno/${fname}`, `/predictions-history/${fname}`];
    }
    function todayEarlyPaths() {
      const fname = `early-lines-${ymd()}.json`;
      return [`/${fname}`, `/progno/${fname}`];
    }
    async function tryFetchJsonFrom(paths) {
      for (const p of paths) {
        try {
          const res = await fetch(p, { cache: 'no-store' });
          if (res.ok) { return await res.json(); }
        } catch { /* continue */ }
      }
      throw new Error('All candidate paths failed');
    }
    async function loadTodayPredictions() {
      try {
        const data = await tryFetchJsonFrom(todayPredsPaths());
        ingestPicks(data);
        alertPush('green', "Predictions loaded", `predictions-${ymd()}.json`);
      } catch (e) {
        alertPush('yellow', 'No predictions file found today', String(e).slice(0,80));
      }
    }

    function makeGameKeyFromEarlyLine(e) {
      const home = (e.home_team || e.homeTeam || '').trim().toUpperCase();
      const away = (e.away_team || e.awayTeam || '').trim().toUpperCase();
      const league = (e.league || e.sport || '').trim().toUpperCase();
      return `${league}:${away}@${home}`;
    }
    function buildTickerFromEarlyLines() {
      for (const [key, info] of Object.entries(earlyLinesByKey)) {
        const base = info.raw || {};
        const league = (base.league || base.sport || '').toUpperCase();
        const home = (base.home_team || base.homeTeam || '').toUpperCase();
        const away = (base.away_team || base.awayTeam || '').toUpperCase();
        for (const inj of info.injuries || []) {
          const label = `${inj.player} (${inj.team}) ${inj.status || ''}`.trim();
          const note = inj.note || '';
          pushTicker(`${league} ${away}@${home}: ${label}${note ? ' ‚Äì ' + note : ''}`, 'yellow');
        }
        if (info.weather) {
          const w = info.weather; const parts = [];
          if (w.desc || w.description) parts.push(w.desc || w.description);
          if (w.temp || w.temperature) parts.push(`${w.temp || w.temperature}¬∞`);
          if (w.wind || w.wind_speed) parts.push(`${w.wind || w.wind_speed} mph wind`);
          if (parts.length) pushTicker(`${league} ${away}@${home}: ${parts.join(', ')}`, 'green');
        }
      }
    }
    function ingestEarlyLines(data) {
      earlyLinesByKey = {};
      const arr = Array.isArray(data) ? data : (Array.isArray(data.games) ? data.games : []);
      for (const g of arr) {
        const key = makeGameKeyFromEarlyLine(g);
        if (!key) continue;
        const injuries = [];
        if (Array.isArray(g.injuries)) {
          for (const inj of g.injuries) {
            injuries.push({
              player: inj.player || inj.name || '',
              team: inj.team || inj.team_abbr || '',
              status: inj.status || inj.designation || '',
              note: inj.note || inj.details || ''
            });
          }
        }
        const weather = g.weather || g.weather_info || null;
        earlyLinesByKey[key] = { injuries, weather, raw: g };
      }
      buildTickerFromEarlyLines();
      alertPush('green', 'Early-lines loaded', `${Object.keys(earlyLinesByKey).length} games`);
    }
    async function loadTodayEarlyLines() {
      try {
        const data = await tryFetchJsonFrom(todayEarlyPaths());
        ingestEarlyLines(data);
      } catch (e) {
        alertPush('yellow', 'No early-lines file found today', String(e).slice(0,80));
      }
    }

    // ---- Picks ingestion ----
    function ingestPicks(data) {
      let picks = [];
      if (Array.isArray(data)) picks = data;
      else if (data && Array.isArray(data.picks)) picks = data.picks;
      else if (data && Array.isArray(data.results)) picks = data.results;
      picksIndex.raw = picks;
      picksIndex.byTeams = new Map();
      for (const p of picks) {
        const k1 = keyTeams(p.home_team || p.homeTeam, p.away_team || p.awayTeam);
        const k2 = keyTeams(p.away_team || p.awayTeam, p.home_team || p.homeTeam);
        if (k1.trim() !== '__') picksIndex.byTeams.set(k1, p);
        if (k2.trim() !== '__') picksIndex.byTeams.set(k2, p);
      }
      alertPush('green', 'Picks loaded', `${picks.length} tracked picks`);
    }

    function promptPicks() {
      const txt = prompt('Paste JSON with picks (supports {picks:[...]}, {results:[...]}, or array)');
      if (!txt) return;
      try { const j = JSON.parse(txt); ingestPicks(j); }
      catch (e) { alertPush('yellow', 'Invalid JSON', String(e).slice(0, 80)); }
    }

    // ---- Bets ingestion & rendering ----
    function normalizeTeam(s) { return String(s || '').toLowerCase().replace(/\s+/g, ' ').trim(); }
    function findBetForGame(home, away) {
      const nh = normalizeTeam(home), na = normalizeTeam(away);
      return myBets.find(b => {
        const bh = normalizeTeam(b.home_team || b.homeTeam || b.home || '');
        const ba = normalizeTeam(b.away_team || b.awayTeam || b.away || '');
        return (bh === nh && ba === na) || (bh === na && ba === nh);
      }) || null;
    }
    function ingestBets(data) {
      let arr = [];
      if (Array.isArray(data)) arr = data;
      else if (data && Array.isArray(data.bets)) arr = data.bets;
      else if (data && Array.isArray(data.positions)) arr = data.positions;
      myBets = arr.map(x => ({
        home_team: x.home_team || x.homeTeam || x.home || '',
        away_team: x.away_team || x.awayTeam || x.away || '',
        side: String(x.side || x.pick || '').toLowerCase(),
        team: x.team || x.teamName || '',
        stake: Number(x.stake || x.size || x.amount || 0),
        book: x.book || x.exchange || x.source || '‚Äî',
        price: x.price != null ? Number(x.price) : (x.odds != null ? Number(x.odds) : null),
      }));
      renderMyBets();
      alertPush('green', 'Bets loaded', `${myBets.length} bets`);
    }
    function renderMyBets() {
      if (!myBetsEl) return;
      if (!myBets.length) { myBetsEl.innerHTML = '<div class="small">No bets loaded. Paste or auto-load.</div>'; return; }
      myBetsEl.innerHTML = myBets.map(b => {
        const line = b.price != null ? (b.price > 0 ? ('+' + b.price) : String(b.price)) : '‚Äî';
        return `<div class="alert"><div class="dot green"></div><div><div class="title">${escapeHtml(b.away_team)} @ ${escapeHtml(b.home_team)}</div><div class="desc">Bet: <strong>${escapeHtml(b.side || b.team || '')}</strong> ¬∑ ${escapeHtml(b.book)} ¬∑ ${escapeHtml(line)} ¬∑ $${(b.stake || 0).toFixed(2)}</div></div><div class="time">‚Äî</div></div>`;
      }).join('');
    }
    async function tryLoadKalshi() {
      try {
        const res = await fetch(`${baseUrl()}/api/kalshi/positions`, { cache: 'no-store' });
        if (!res.ok) return alertPush('yellow', 'Kalshi positions', 'Endpoint not available');
        const j = await res.json(); ingestBets(j);
      } catch { alertPush('yellow', 'Kalshi positions', 'Failed to load'); }
    }
    async function tryLoadPolymarket() {
      try {
        const res = await fetch(`${baseUrl()}/api/polymarket/positions`, { cache: 'no-store' });
        if (!res.ok) return alertPush('yellow', 'Polymarket', 'Endpoint not available');
        const j = await res.json(); ingestBets(j);
      } catch { alertPush('yellow', 'Polymarket', 'Failed to load'); }
    }

    // ---- Audio ----
    function ensureAudio() {
      if (audioReady) return;
      try { AC = AC || new (window.AudioContext || window.webkitAudioContext)(); AC.resume && AC.resume(); audioReady = true; }
      catch (_) { audioReady = false; }
    }

    function playTone(freq, seconds) {
      if (muted) return;
      ensureAudio();
      if (!audioReady || !AC) return;
      const o = AC.createOscillator(); const g = AC.createGain();
      o.type = 'sine'; o.frequency.value = freq;
      g.gain.value = 0.0001;
      o.connect(g); g.connect(AC.destination);
      const now = AC.currentTime;
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + Math.max(0.05, seconds));
      o.start(); o.stop(now + Math.max(0.1, seconds + 0.05));
    }

    // MP3 crowd/boo (fallback to synth if Audio fails)
    let crowdAudio = null; let booAudio = null;
    try {
      crowdAudio = new Audio('./crowd-cheer.mp3'); crowdAudio.preload = 'auto'; crowdAudio.volume = 0.4;
      booAudio = new Audio('./crowd-disappointment.mp3'); booAudio.preload = 'auto'; booAudio.volume = 0.45;
    } catch {}

    function playCrowd() {
      if (muted) return;
      if (crowdAudio) { try { crowdAudio.currentTime = 0; crowdAudio.play().catch(()=>{}); return; } catch {}
      }
      ensureAudio(); if (!AC) return;
      const src = AC.createBufferSource();
      const buf = AC.createBuffer(1, AC.sampleRate * 0.7, AC.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) { const t = i / AC.sampleRate; data[i] = (Math.random() * 2 - 1) * Math.exp(-t / 0.5); }
      src.buffer = buf; const g = AC.createGain(); g.gain.value = 0.0001; src.connect(g); g.connect(AC.destination);
      const now = AC.currentTime; g.gain.exponentialRampToValueAtTime(0.15, now + 0.02); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);
      src.start();
    }

    function playBoo() {
      if (muted) return;
      if (booAudio) { try { booAudio.currentTime = 0; booAudio.play().catch(()=>{}); return; } catch {}
      }
      ensureAudio(); if (!AC) return;
      const o = AC.createOscillator(); const g = AC.createGain();
      o.type = 'sawtooth'; o.frequency.value = 180; g.gain.value = 0.0001; o.connect(g); g.connect(AC.destination);
      const now = AC.currentTime; g.gain.exponentialRampToValueAtTime(0.1, now + 0.01); o.frequency.exponentialRampToValueAtTime(110, now + 0.45); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
      o.start(); o.stop(now + 0.55);
    }

    // ---- Controls & keys ----
    soundPill?.addEventListener('click', () => { muted = !muted; soundPill.textContent = (muted ? 'üîá Sound: Off' : 'üîä Sound: On'); });
    pasteBtn?.addEventListener('click', promptPicks);
    pasteBetsBtn?.addEventListener('click', () => {
      const txt = prompt('Paste bets JSON (supports {bets:[...]}, {positions:[...]}, or array)');
      if (!txt) return; try { const j = JSON.parse(txt); ingestBets(j); } catch (e) { alertPush('yellow', 'Invalid JSON', String(e).slice(0, 80)); }
    });
    loadKalshiBtn?.addEventListener('click', tryLoadKalshi);
    loadPolyBtn?.addEventListener('click', tryLoadPolymarket);
    testBtn?.addEventListener('click', () => { alertPush('red', 'Test alert', 'This is only a test'); });
    loadTodayPredsBtn?.addEventListener('click', loadTodayPredictions);
    loadTodayEarlyBtn?.addEventListener('click', loadTodayEarlyLines);
    testAudioBtn?.addEventListener('click', () => { playCrowd(); setTimeout(() => playBoo(), 900); });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'm' || e.key === 'M') { muted = !muted; if (soundPill) soundPill.textContent = (muted ? 'üîá Sound: Off' : 'üîä Sound: On'); }
      if (e.key === 'p' || e.key === 'P') { promptPicks(); }
      if (e.key === 'b' || e.key === 'B') { const txt = prompt('Paste bets JSON'); if (!txt) return; try { ingestBets(JSON.parse(txt)); } catch (e2) { alertPush('yellow', 'Invalid JSON', String(e2).slice(0, 80)); } }
      if (e.key === 't' || e.key === 'T') { alertPush('yellow', 'Test alert', 'Keyboard trigger'); }
      if (e.key === 'l' || e.key === 'L') { loadTodayPredictions(); }
      if (e.key === 'e' || e.key === 'E') { loadTodayEarlyLines(); }
      if (e.key === 'c' || e.key === 'C') { playCrowd(); setTimeout(() => playBoo(), 900); }
    });

    function escapeHtml(s) { if (s == null) return ''; const div = document.createElement('div'); div.textContent = String(s); return div.innerHTML; }
  </script>
</body>

</html>
