<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PROGNO ‚Äî TV Wallboard</title>
  <style>
    :root {
      --bg: #0b0f17;
      --surface: #101625;
      --surface2: #121a2c;
      --text: #e6edf7;
      --muted: #94a3b8;
      --green: #34d399;
      /* OK */
      --yellow: #fbbf24;
      /* WARN */
      --red: #fb7185;
      /* CRIT */
      --blue: #60a5fa;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 20% -10%, #182036 0%, #0b0f17 60%), #0b0f17;
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.3fr 0.7fr;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
      padding: 16px;
      height: 100%;
    }

    .header {
      grid-column: 1 / span 2;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: var(--surface2);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 10px;
    }

    .brand {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }

    .brand h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.04em;
    }

    .brand .sub {
      color: var(--muted);
      font-size: 14px;
    }

    .clock {
      font-variant-numeric: tabular-nums;
      font-size: 18px;
      color: var(--muted);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--muted);
      font-size: 12px;
    }

    .pill {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 9999px;
      padding: 4px 10px;
      color: var(--text);
      cursor: pointer;
    }


    .panel {
      background: var(--surface);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel h2 {
      margin: 0;
      padding: 10px 14px;
      font-size: 16px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
      background: var(--surface2);
      border-bottom: 1px solid rgba(148, 163, 184, 0.15);
    }

    .scores {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      padding: 12px;
      overflow: auto;
    }

    .score-card {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(148, 163, 184, 0.16);
      border-radius: 10px;
      padding: 10px 12px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
    }

    /* Scoring swing animation */
    .game-card {
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
    }

    .game-card.swing-good {
      transform: scale(1.06);
      box-shadow: 0 0 25px rgba(52, 211, 153, 0.8);
      border-color: var(--green);
    }

    .game-card.swing-bad {
      transform: scale(1.06);
      box-shadow: 0 0 25px rgba(251, 113, 133, 0.85);
      border-color: var(--red);
    }

    .teams {
      font-weight: 700;
      font-size: 18px;
      letter-spacing: 0.02em;
    }

    .meta {
      color: var(--muted);
      font-size: 12px;
    }

    .score {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 24px;
      font-weight: 800;
    }

    .badge {
      padding: 2px 8px;
      border-radius: 9999px;
      font-size: 11px;
      border: 1px solid currentColor;
      align-self: start;
    }

    .badge.green {
      color: var(--green);
    }

    .badge.yellow {
      color: var(--yellow);
    }

    .badge.red {
      color: var(--red);
    }

    .alerts {
      padding: 8px;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .alert {
      display: grid;
      grid-template-columns: 16px 1fr auto;
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      background: rgba(255, 255, 255, 0.02);
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 9999px;
    }

    .dot.green {
      background: var(--green);
      box-shadow: 0 0 16px rgba(52, 211, 153, 0.6);
    }

    .dot.yellow {
      background: var(--yellow);
      box-shadow: 0 0 16px rgba(251, 191, 36, 0.6);
    }

    .dot.red {
      background: var(--red);
      box-shadow: 0 0 16px rgba(251, 113, 133, 0.6);
    }

    .alert .title {
      font-weight: 700;
      font-size: 14px;
    }

    .alert .desc {
      color: var(--muted);
      font-size: 12px;
    }

    .alert .time {
      color: var(--muted);
      font-size: 12px;
      font-variant-numeric: tabular-nums;
    }

    .ticker {
      grid-column: 1 / span 2;
      background: var(--surface2);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 10px;
      overflow: hidden;
      display: flex;
      align-items: center;
    }

    .ticker .band {
      background: rgba(96, 165, 250, 0.08);
      padding: 8px 12px;
      font-weight: 700;
      color: var(--blue);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      border-right: 1px solid rgba(148, 163, 184, 0.2);
    }

    .ticker .marquee {
      overflow: hidden;
      position: relative;
    }

    .ticker .scroll {
      white-space: nowrap;
      display: inline-block;
      padding-left: 100%;
      animation: scroll 45s linear infinite;
    }

    .ticker .item {
      margin-right: 48px;
      color: var(--muted);
    }

    .ticker .imp {
      color: var(--red);
      font-weight: 700;
    }

    @keyframes scroll {
      from {
        transform: translateX(0);
      }

      to {
        transform: translateX(-100%);
      }
    }

    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 12px;
    }

    .small {
      color: var(--muted);
      font-size: 12px;
    }

    .footer {
      grid-column: 1 / span 2;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--muted);
      font-size: 12px;
      padding: 8px 2px;
    }

    .legend {
      display: flex;
      gap: 14px;
      align-items: center;
    }

    .legend .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend .swatch {
      width: 10px;
      height: 10px;
      border-radius: 9999px;
    }

    .swatch.green {
      background: var(--green);
    }

    .swatch.yellow {
      background: var(--yellow);
    }

    .swatch.red {
      background: var(--red);
    }

    @media (min-width: 1600px) {
      .scores {
        grid-template-columns: repeat(3, 1fr);
      }

      .teams {
        font-size: 20px;
      }

      .score {
        font-size: 28px;
      }
    }
  </style>
</head>

<body>
  <div class="layout">
    <div class="header">
      <div class="brand">
        <h1>PROGNO ‚Ä¢ TV Wallboard</h1>
        <div class="sub" id="sportLabel">Rotating: NBA, NCAAB, NHL...</div>
      </div>
      <div class="controls">
        <span class="pill" id="soundPill" title="Toggle sound (M)">üîä Sound: On</span>
        <span class="pill" id="pastePicks" title="Paste picks JSON (P)">üìã Paste Picks</span>
        <span class="pill" id="pasteBets" title="Paste my bets JSON (B)">üíº Paste Bets</span>
        <span class="pill" id="loadKalshi" title="Load Kalshi positions (stub)">üìà Kalshi</span>
        <span class="pill" id="loadPoly" title="Load Polymarket positions (stub)">ü™ô Polymarket</span>
        <span class="pill" id="testAlert" title="Trigger a test alert (T)">üß™ Test Alert</span>
        <span class="pill" id="loadTodayPreds" title="Load today‚Äôs predictions (L)">üìÖ Today‚Äôs Predictions</span>
        <span class="pill" id="loadTodayEarly" title="Load today‚Äôs early-lines (E)">ü©∫ Early Lines</span>
        <span class="pill" id="testAudio" title="Play crowd then boo">üîä Test Audio</span>
        <span class="pill" title="Keyboard: M/P/B/T for Sound/Picks/Bets/Test">‚å®Ô∏è Help</span>
      </div>
      <div class="clock" id="clock">--:--:--</div>
    </div>

    <div class="panel" style="grid-column: 1 / span 1;">
      <h2>Live Scores</h2>
      <div class="scores" id="scores"></div>
    </div>

    <div class="panel" style="grid-column: 2 / span 1;">
      <h2>Alerts</h2>
      <div class="alerts" id="alerts"></div>
      <div class="row small">
        <div>Auto-generated from score changes, lead changes, start windows, and injury hooks.</div>
      </div>
    </div>

    <div class="panel" style="grid-column: 2 / span 1;">
      <h2 style="display:flex;justify-content:space-between;align-items:center;">
        My Bets
        <span class="pill" id="addBetBtn" style="font-size:12px;padding:3px 10px;cursor:pointer;">+ Add Bet</span>
      </h2>
      <div id="statsBar"
        style="display:flex;gap:12px;padding:8px 14px;background:rgba(255,255,255,0.02);border-bottom:1px solid rgba(148,163,184,0.12);font-size:13px;">
        <span>P&L: <strong id="statPnl" style="color:var(--muted)">$0.00</strong></span>
        <span>Win Rate: <strong id="statWinRate" style="color:var(--muted)">--%</strong></span>
        <span>Live: <strong id="statLive" style="color:var(--muted)">0</strong></span>
        <span>Kalshi: <strong id="statKalshi" style="color:var(--muted)">$0</strong></span>
      </div>
      <div class="alerts" id="myBets"></div>
      <div class="row small">
        <div>Click result badge to cycle: pending ‚Üí win ‚Üí loss ‚Üí push. Data persists in localStorage.</div>
      </div>
    </div>

    <div class="ticker">
      <div class="band">Live Ticker</div>
      <div class="marquee">
        <div class="scroll" id="ticker">
          <span class="item imp">Welcome ‚Äî concept wallboard. Red = critical, Yellow = medium, Green = all good.</span>
          <span class="item">Last-minute line moves and injuries will surface here when wired.</span>
          <span class="item">Use in full-screen on a TV for best visibility.</span>
        </div>
      </div>
    </div>

    <div class="footer">
      <div class="legend">
        <span class="pill"><span class="swatch red"></span> Critical</span>
        <span class="pill"><span class="swatch yellow"></span> Medium</span>
        <span class="pill"><span class="swatch green"></span> Informational</span>
      </div>
      <div>Data refresh: <span id="refreshInfo">‚Äî</span></div>
    </div>
  </div>

  <script>
    const SPORTS = ['nba', 'ncaab', 'nhl', 'mlb', 'nfl', 'cbb'];
    let sportIdx = 0;
    let lastScoresBySport = {};  // keyed by sport, each is a Map
    let lastOddsById = new Map();
    let espnChannels = {};  // gameKey -> channels string
    function getScoreMap(sport) { if (!lastScoresBySport[sport]) lastScoresBySport[sport] = new Map(); return lastScoresBySport[sport]; }
    let picksIndex = { byTeams: new Map(), raw: [] };
    let muted = false;
    let audioReady = false;
    let AC = null;
    const scoresEl = document.getElementById('scores');
    const alertsEl = document.getElementById('alerts');
    const clockEl = document.getElementById('clock');
    const refreshEl = document.getElementById('refreshInfo');
    const sportLabelEl = document.getElementById('sportLabel');
    const soundPill = document.getElementById('soundPill');
    const pasteBtn = document.getElementById('pastePicks');
    const testBtn = document.getElementById('testAlert');
    const pasteBetsBtn = document.getElementById('pasteBets');
    const loadKalshiBtn = document.getElementById('loadKalshi');
    const loadPolyBtn = document.getElementById('loadPoly');
    const myBetsEl = document.getElementById('myBets');
    let myBets = [];
    const loadTodayPredsBtn = document.getElementById('loadTodayPreds');
    const loadTodayEarlyBtn = document.getElementById('loadTodayEarly');
    const testAudioBtn = document.getElementById('testAudio');
    // Early-lines store
    let earlyLinesByKey = {};

    function two(n) { return n < 10 ? '0' + n : n }
    function nowStr() { const d = new Date(); return `${two(d.getHours())}:${two(d.getMinutes())}:${two(d.getSeconds())}` }
    setInterval(() => { clockEl.textContent = nowStr(); }, 1000);

    function baseUrl() { try { const u = new URL(window.location.href); return `${u.origin}`; } catch { return 'http://localhost:3008'; } }

    function alertPush(sev, title, desc) {
      const wrap = document.createElement('div');
      wrap.className = 'alert';
      const dot = document.createElement('div'); dot.className = 'dot ' + sev;
      const content = document.createElement('div');
      const t = document.createElement('div'); t.className = 'title'; t.textContent = title;
      const d = document.createElement('div'); d.className = 'desc'; d.textContent = desc || '';
      content.appendChild(t); content.appendChild(d);
      const time = document.createElement('div'); time.className = 'time'; time.textContent = nowStr();
      wrap.appendChild(dot); wrap.appendChild(content); wrap.appendChild(time);
      alertsEl.prepend(wrap);
      // Limit alerts
      const max = 30; while (alertsEl.children.length > max) { alertsEl.removeChild(alertsEl.lastChild); }
      // Sounds by severity
      if (sev === 'red') playTone(880, 0.25); else if (sev === 'yellow') playTone(660, 0.18); else playTone(440, 0.12);
      // Ticker enrichment
      pushTicker(`${title}: ${desc}`, sev);
    }

    function statusBadge(completed) {
      if (completed) return '<span class="badge green">Final</span>';
      return '<span class="badge yellow">Live</span>';
    }

    function renderScores(list, sport) {
      scoresEl.innerHTML = list.map(g => {
        const id = g.id;
        const score = `${g.homeScore ?? 0}‚Äì${g.awayScore ?? 0}`;
        const teams = `${g.away} @ ${g.home}`;
        const when = g.commence_time ? new Date(g.commence_time).toLocaleString(undefined, { hour: '2-digit', minute: '2-digit' }) : '';
        const chanKey = channelKey(g.home, g.away);
        const chan = espnChannels[chanKey] || '';
        const tracked = isTrackedPick(g.home, g.away);
        const trackedStyle = tracked ? 'border-left: 3px solid var(--green);' : '';
        return `<div class="score-card game-card" data-game-id="${CSS.escape(String(id))}" style="${trackedStyle}">
          <div>
            <div class="teams">${escapeHtml(teams)}</div>
            <div class="meta">${escapeHtml(when)}${chan ? ' ¬∑ <span style="color:var(--blue)">' + escapeHtml(chan) + '</span>' : ''}</div>
          </div>
          <div style="text-align:right">
            <div class="score">${escapeHtml(score)}</div>
            ${statusBadge(g.completed)}
          </div>
        </div>`;
      }).join('');
    }

    function triggerScoringSwing(gameId, goodForUs) {
      const el = document.querySelector(`[data-game-id="${CSS.escape(String(gameId))}"]`);
      if (!el) return;
      const cls = goodForUs ? 'swing-good' : 'swing-bad';
      el.classList.add(cls);
      setTimeout(() => el.classList.remove(cls), 1200);
    }

    function diffScoresAndAlert(prevMap, currList, sport) {
      for (const g of currList) {
        const k = g.id;
        const prev = prevMap.get(k);
        const hs = Number(g.homeScore || 0), as = Number(g.awayScore || 0);
        if (prev) {
          const dh = hs - Number(prev.homeScore || 0);
          const da = as - Number(prev.awayScore || 0);
          if (dh > 0 || da > 0) {
            const who = dh > 0 && da > 0 ? 'Both score' : (dh > 0 ? g.home : g.away);
            const tracked = isTrackedPick(g.home, g.away);
            const title = tracked ? 'Progno pick scored' : 'Scoring play';
            alertPush('red', title, `${who} ‚Äî ${g.away} @ ${g.home} now ${hs}‚Äì${as}`);
            const bet = findBetForGame(g.home, g.away);
            if (bet) {
              const scoringTeam = (dh > 0) ? g.home : g.away;
              const mySideTeam = (String(bet.side || '').toLowerCase() === 'home') ? g.home :
                (String(bet.side || '').toLowerCase() === 'away') ? g.away :
                  (bet.team || '');
              const good = normalizeTeam(scoringTeam) === normalizeTeam(mySideTeam);
              if (good) playCrowd(); else playBoo();
              triggerScoringSwing(g.id, !!good);
            }
          }
          const prevLead = Number(prev.homeScore || 0) - Number(prev.awayScore || 0);
          const lead = hs - as;
          if (Math.sign(prevLead) !== Math.sign(lead)) {
            alertPush('red', 'Lead change', `${g.away} @ ${g.home} ‚Äî ${hs}‚Äì${as}`);
            triggerScoringSwing(g.id, lead > 0); // simple: home lead good visual when positive
          }
        } else {
          // New game loaded ‚Äî pre-game soon window
          try {
            const start = g.commence_time ? new Date(g.commence_time).getTime() : 0;
            const mins = (start - Date.now()) / 60000;
            if (mins > 0 && mins <= 30) { alertPush('yellow', 'Starting soon', `${g.away} @ ${g.home} in ${Math.round(mins)}m`); }
          } catch (_) { }
        }
        prevMap.set(k, { homeScore: hs, awayScore: as });
      }
    }

    async function fetchScores(sport) {
      const url = `${baseUrl()}/api/progno/v2?action=live-scores&sport=${encodeURIComponent(sport)}`;
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) { refreshEl.textContent = `Fetch ${sport}: ${res.status}`; return []; }
        const data = await res.json();
        return data?.data || [];
      } catch (e) { refreshEl.textContent = `Fetch error: ${String(e).slice(0, 80)}`; return []; }
    }

    async function cycle() {
      const sport = SPORTS[sportIdx % SPORTS.length];
      sportLabelEl.textContent = `Rotating: ${SPORTS.map(s => s.toUpperCase()).join(', ')} ‚Äî Now: ${sport.toUpperCase()}`;
      const [list, odds] = await Promise.all([fetchScores(sport), fetchOdds(sport), fetchEspnChannels(sport)]);
      const scoreMap = getScoreMap(sport);
      diffScoresAndAlert(scoreMap, list, sport);
      diffOddsAndAlert(lastOddsById, odds);
      renderScores(list, sport);
      refreshEl.textContent = `${sport.toUpperCase()} @ ${nowStr()} ‚Ä¢ ${list.length} games`;
      sportIdx++;
    }

    // Start loops
    cycle();
    setInterval(cycle, 15000); // rotate sport every 15s

    // ---- Ticker enrichment ----
    const tickerEl = document.getElementById('ticker');
    let tickerItems = [];
    function pushTicker(text, sev) {
      const cls = sev === 'red' ? 'imp' : '';
      tickerItems.push({ text, sev });
      if (tickerItems.length > 60) tickerItems.shift();
      tickerEl.innerHTML = tickerItems.map(i => `<span class="item ${i.sev === 'red' ? 'imp' : ''}">${escapeHtml(i.text)}</span>`).join(' ');
    }

    // ---- Channel helpers ----
    function channelKey(home, away) { return normalizeTeam(away) + '@' + normalizeTeam(home); }
    async function fetchEspnChannels(sport) {
      try {
        const res = await fetch(`${baseUrl()}/api/espn-scores?sport=${encodeURIComponent(sport)}`, { cache: 'no-store' });
        if (!res.ok) return;
        const j = await res.json();
        for (const g of (j.data || [])) {
          const key = channelKey(g.home, g.away);
          if (g.channels && g.channels.length) espnChannels[key] = g.channels.join(', ');
        }
      } catch { /* non-critical */ }
    }

    // ---- Odds & helpers ----
    function keyTeams(home, away) { return `${String(home || '').toLowerCase().trim()}__${String(away || '').toLowerCase().trim()}`; }
    function fuzzyTeamMatch(a, b) {
      const na = normalizeTeam(a), nb = normalizeTeam(b);
      if (!na || !nb) return false;
      if (na === nb) return true;
      // Check if one name contains the other (handles "Troy" vs "Troy Trojans", "Georgia" vs "Georgia Bulldogs")
      if (na.includes(nb) || nb.includes(na)) return true;
      // Check last-word match (handles "Georgia" matching "Georgia Bulldogs")
      const wa = na.split(' '), wb = nb.split(' ');
      if (wa[0] === wb[0] && wa[0].length >= 4) return true;
      return false;
    }
    function isTrackedPick(home, away) {
      // Exact match first
      const k1 = keyTeams(home, away); const k2 = keyTeams(away, home);
      if (picksIndex.byTeams.has(k1) || picksIndex.byTeams.has(k2)) return true;
      // Fuzzy match for college sports
      for (const p of picksIndex.raw) {
        const ph = normalizeTeam(p.home_team || p.homeTeam);
        const pa = normalizeTeam(p.away_team || p.awayTeam);
        const gh = normalizeTeam(home);
        const ga = normalizeTeam(away);
        if ((fuzzyTeamMatch(ph, gh) && fuzzyTeamMatch(pa, ga)) ||
          (fuzzyTeamMatch(ph, ga) && fuzzyTeamMatch(pa, gh))) return true;
      }
      return false;
    }
    function deltaNum(a, b) { if (a == null || b == null) return null; const da = Number(a) - Number(b); return Number.isFinite(da) ? Math.round(da) : null; }
    function fmtOdds(n) { if (n == null) return '‚Äî'; const x = Number(n); return x > 0 ? `+${x}` : String(x); }
    function diffOddsAndAlert(prevMap, currList) {
      const ML_RED = 12, ML_YELLOW = 8;
      const SPREAD_RED = 0.75, SPREAD_YELLOW = 0.5;
      const TOTAL_RED = 1.0, TOTAL_YELLOW = 0.5;
      for (const g of currList) {
        const prev = prevMap.get(g.id);
        if (prev) {
          const p = prev.odds || {};
          const c = g.odds || {};
          const dmh = deltaNum(c.mlHome, p.mlHome);
          const dma = deltaNum(c.mlAway, p.mlAway);
          const dsh = deltaNum(c.spreadHome, p.spreadHome);
          const dt = deltaNum(c.total, p.total);
          const tracked = isTrackedPick(g.home, g.away);
          const mlMove = Math.max(Math.abs(dmh || 0), Math.abs(dma || 0));
          if (mlMove >= ML_RED) alertPush('red', tracked ? 'Pick ML move' : 'ML move', `${g.away} @ ${g.home} Œî${mlMove} (H ${fmtOdds(c.mlHome)}, A ${fmtOdds(c.mlAway)})`);
          else if (mlMove >= ML_YELLOW) alertPush('yellow', 'ML move', `${g.away} @ ${g.home} Œî${mlMove}`);
          if (Math.abs(dsh || 0) >= SPREAD_RED) alertPush('red', tracked ? 'Pick Spread move' : 'Spread move', `${g.away} @ ${g.home} Œî${(dsh ?? 0).toFixed(2)}`);
          else if (Math.abs(dsh || 0) >= SPREAD_YELLOW) alertPush('yellow', 'Spread move', `${g.away} @ ${g.home} Œî${(dsh ?? 0).toFixed(2)}`);
          if (Math.abs(dt || 0) >= TOTAL_RED) alertPush('red', 'Total move', `${g.away} @ ${g.home} Œî${(dt ?? 0).toFixed(2)}`);
          else if (Math.abs(dt || 0) >= TOTAL_YELLOW) alertPush('yellow', 'Total move', `${g.away} @ ${g.home} Œî${(dt ?? 0).toFixed(2)}`);
        }
        prevMap.set(g.id, g);
      }
    }
    async function fetchOdds(sport) {
      const url = `${baseUrl()}/api/progno/v2?action=games&sport=${encodeURIComponent(sport)}`;
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) return [];
        const j = await res.json();
        const arr = Array.isArray(j?.data) ? j.data : [];
        return arr.map(g => ({
          id: g.id,
          home: g.homeTeam,
          away: g.awayTeam,
          startTime: g.startTime,
          odds: {
            mlHome: g.odds?.moneyline?.home ?? null,
            mlAway: g.odds?.moneyline?.away ?? null,
            spreadHome: g.odds?.spread?.home ?? null,
            total: g.odds?.total?.line ?? null,
          }
        }));
      } catch { return []; }
    }

    // ---- Daily file loaders (predictions and early-lines) ----
    function ymd(d = new Date()) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }
    function todayPredsPaths() {
      const fname = `predictions-${ymd()}.json`;
      // try root, then /progno
      return [`/${fname}`, `/progno/${fname}`, `/predictions-history/${fname}`];
    }
    function todayEarlyPaths() {
      const fname = `early-lines-${ymd()}.json`;
      return [`/${fname}`, `/progno/${fname}`];
    }
    async function tryFetchJsonFrom(paths) {
      for (const p of paths) {
        try {
          const res = await fetch(p, { cache: 'no-store' });
          if (res.ok) { return await res.json(); }
        } catch { /* continue */ }
      }
      throw new Error('All candidate paths failed');
    }
    async function loadTodayPredictions() {
      try {
        const data = await tryFetchJsonFrom(todayPredsPaths());
        ingestPicks(data);
        alertPush('green', "Predictions loaded", `predictions-${ymd()}.json`);
      } catch (e) {
        alertPush('yellow', 'No predictions file found today', String(e).slice(0, 80));
      }
    }

    function makeGameKeyFromEarlyLine(e) {
      const home = (e.home_team || e.homeTeam || '').trim().toUpperCase();
      const away = (e.away_team || e.awayTeam || '').trim().toUpperCase();
      const league = (e.league || e.sport || '').trim().toUpperCase();
      return `${league}:${away}@${home}`;
    }
    function buildTickerFromEarlyLines() {
      for (const [key, info] of Object.entries(earlyLinesByKey)) {
        const base = info.raw || {};
        const league = (base.league || base.sport || '').toUpperCase();
        const home = (base.home_team || base.homeTeam || '').toUpperCase();
        const away = (base.away_team || base.awayTeam || '').toUpperCase();
        for (const inj of info.injuries || []) {
          const label = `${inj.player} (${inj.team}) ${inj.status || ''}`.trim();
          const note = inj.note || '';
          pushTicker(`${league} ${away}@${home}: ${label}${note ? ' ‚Äì ' + note : ''}`, 'yellow');
        }
        if (info.weather) {
          const w = info.weather; const parts = [];
          if (w.desc || w.description) parts.push(w.desc || w.description);
          if (w.temp || w.temperature) parts.push(`${w.temp || w.temperature}¬∞`);
          if (w.wind || w.wind_speed) parts.push(`${w.wind || w.wind_speed} mph wind`);
          if (parts.length) pushTicker(`${league} ${away}@${home}: ${parts.join(', ')}`, 'green');
        }
      }
    }
    function ingestEarlyLines(data) {
      earlyLinesByKey = {};
      const arr = Array.isArray(data) ? data : (Array.isArray(data.games) ? data.games : []);
      for (const g of arr) {
        const key = makeGameKeyFromEarlyLine(g);
        if (!key) continue;
        const injuries = [];
        if (Array.isArray(g.injuries)) {
          for (const inj of g.injuries) {
            injuries.push({
              player: inj.player || inj.name || '',
              team: inj.team || inj.team_abbr || '',
              status: inj.status || inj.designation || '',
              note: inj.note || inj.details || ''
            });
          }
        }
        const weather = g.weather || g.weather_info || null;
        earlyLinesByKey[key] = { injuries, weather, raw: g };
      }
      buildTickerFromEarlyLines();
      alertPush('green', 'Early-lines loaded', `${Object.keys(earlyLinesByKey).length} games`);
    }
    async function loadTodayEarlyLines() {
      try {
        const data = await tryFetchJsonFrom(todayEarlyPaths());
        ingestEarlyLines(data);
      } catch (e) {
        alertPush('yellow', 'No early-lines file found today', String(e).slice(0, 80));
      }
    }

    // ---- Picks ingestion ----
    function ingestPicks(data) {
      let picks = [];
      if (Array.isArray(data)) picks = data;
      else if (data && Array.isArray(data.picks)) picks = data.picks;
      else if (data && Array.isArray(data.results)) picks = data.results;
      picksIndex.raw = picks;
      picksIndex.byTeams = new Map();
      for (const p of picks) {
        const k1 = keyTeams(p.home_team || p.homeTeam, p.away_team || p.awayTeam);
        const k2 = keyTeams(p.away_team || p.awayTeam, p.home_team || p.homeTeam);
        if (k1.trim() !== '__') picksIndex.byTeams.set(k1, p);
        if (k2.trim() !== '__') picksIndex.byTeams.set(k2, p);
      }
      alertPush('green', 'Picks loaded', `${picks.length} tracked picks`);
    }

    function promptPicks() {
      const txt = prompt('Paste JSON with picks (supports {picks:[...]}, {results:[...]}, or array)');
      if (!txt) return;
      try { const j = JSON.parse(txt); ingestPicks(j); }
      catch (e) { alertPush('yellow', 'Invalid JSON', String(e).slice(0, 80)); }
    }

    // ---- Bets ingestion & rendering (with localStorage + result cycling + stats) ----
    const RESULT_CYCLE = ['pending', 'win', 'loss', 'push'];
    const RESULT_COLORS = { pending: 'yellow', win: 'green', loss: 'red', push: 'blue' };
    let kalshiValue = 0;

    function normalizeTeam(s) { return String(s || '').toLowerCase().replace(/\s+/g, ' ').trim(); }

    function findBetForGame(home, away) {
      const nh = normalizeTeam(home), na = normalizeTeam(away);
      return myBets.find(b => {
        const bh = normalizeTeam(b.home_team || '');
        const ba = normalizeTeam(b.away_team || '');
        return (bh === nh && ba === na) || (bh === na && ba === nh) ||
          (fuzzyTeamMatch(bh, nh) && fuzzyTeamMatch(ba, na)) ||
          (fuzzyTeamMatch(bh, na) && fuzzyTeamMatch(ba, nh));
      }) || null;
    }

    function saveBets() {
      try { localStorage.setItem('wallboard_bets', JSON.stringify(myBets)); } catch { }
    }
    function loadBetsFromStorage() {
      try {
        const raw = localStorage.getItem('wallboard_bets');
        if (raw) { myBets = JSON.parse(raw); renderMyBets(); updateStats(); }
      } catch { }
    }

    function ingestBets(data) {
      let arr = [];
      if (Array.isArray(data)) arr = data;
      else if (data && Array.isArray(data.bets)) arr = data.bets;
      else if (data && Array.isArray(data.positions)) arr = data.positions;
      const incoming = arr.map(x => ({
        home_team: x.home_team || x.homeTeam || x.home || '',
        away_team: x.away_team || x.awayTeam || x.away || '',
        side: String(x.side || x.pick || '').toLowerCase(),
        team: x.team || x.teamName || '',
        stake: Number(x.stake || x.size || x.amount || 0),
        book: x.book || x.exchange || x.source || '',
        price: x.price != null ? Number(x.price) : (x.odds != null ? Number(x.odds) : null),
        result: x.result || 'pending',
      }));
      myBets = [...myBets, ...incoming];
      saveBets();
      renderMyBets();
      updateStats();
      alertPush('green', 'Bets loaded', `${incoming.length} bets added (${myBets.length} total)`);
    }

    function cycleBetResult(idx) {
      if (idx < 0 || idx >= myBets.length) return;
      const cur = myBets[idx].result || 'pending';
      const next = RESULT_CYCLE[(RESULT_CYCLE.indexOf(cur) + 1) % RESULT_CYCLE.length];
      myBets[idx].result = next;
      saveBets();
      renderMyBets();
      updateStats();
    }

    function deleteBet(idx) {
      if (idx < 0 || idx >= myBets.length) return;
      myBets.splice(idx, 1);
      saveBets();
      renderMyBets();
      updateStats();
    }

    function computePnl(bet) {
      const stake = bet.stake || 0;
      const price = bet.price;
      if (bet.result === 'win' && price != null) {
        if (price > 0) return stake * (price / 100);
        if (price < 0) return stake * (100 / Math.abs(price));
        return stake;
      }
      if (bet.result === 'loss') return -stake;
      return 0; // pending or push
    }

    function updateStats() {
      const settled = myBets.filter(b => b.result === 'win' || b.result === 'loss');
      const wins = myBets.filter(b => b.result === 'win').length;
      const losses = myBets.filter(b => b.result === 'loss').length;
      const live = myBets.filter(b => b.result === 'pending').length;
      const totalPnl = myBets.reduce((s, b) => s + computePnl(b), 0);
      const winRate = settled.length > 0 ? ((wins / settled.length) * 100).toFixed(0) : '--';

      const pnlEl = document.getElementById('statPnl');
      const wrEl = document.getElementById('statWinRate');
      const liveEl = document.getElementById('statLive');
      const kalEl = document.getElementById('statKalshi');

      if (pnlEl) {
        pnlEl.textContent = (totalPnl >= 0 ? '+' : '') + '$' + totalPnl.toFixed(2);
        pnlEl.style.color = totalPnl >= 0 ? 'var(--green)' : 'var(--red)';
      }
      if (wrEl) {
        wrEl.textContent = winRate + '%';
        const wr = parseFloat(winRate);
        wrEl.style.color = wr >= 55 ? 'var(--green)' : (wr < 45 ? 'var(--red)' : 'var(--yellow)');
      }
      if (liveEl) { liveEl.textContent = String(live); liveEl.style.color = live > 0 ? 'var(--yellow)' : 'var(--muted)'; }
      if (kalEl) { kalEl.textContent = '$' + kalshiValue.toFixed(0); kalEl.style.color = kalshiValue > 0 ? 'var(--green)' : 'var(--muted)'; }
    }

    function renderMyBets() {
      if (!myBetsEl) return;
      if (!myBets.length) { myBetsEl.innerHTML = '<div class="small" style="padding:8px 14px;">No bets. Click "+ Add Bet" or paste JSON.</div>'; return; }
      myBetsEl.innerHTML = myBets.map((b, i) => {
        const line = b.price != null ? (b.price > 0 ? ('+' + b.price) : String(b.price)) : '';
        const res = b.result || 'pending';
        const dotColor = RESULT_COLORS[res] || 'yellow';
        const resultLabel = res.charAt(0).toUpperCase() + res.slice(1);
        return `<div class="alert">
          <div class="dot ${dotColor}"></div>
          <div>
            <div class="title">${escapeHtml(b.away_team)} @ ${escapeHtml(b.home_team)}</div>
            <div class="desc">
              <strong>${escapeHtml(b.side || b.team || '')}</strong>
              ${b.book ? ' ¬∑ ' + escapeHtml(b.book) : ''}
              ${line ? ' ¬∑ ' + escapeHtml(line) : ''}
              ${b.stake ? ' ¬∑ $' + b.stake.toFixed(2) : ''}
            </div>
          </div>
          <div style="display:flex;flex-direction:column;align-items:flex-end;gap:4px;">
            <span class="badge ${dotColor}" style="cursor:pointer;" onclick="cycleBetResult(${i})" title="Click to cycle result">${escapeHtml(resultLabel)}</span>
            <span style="font-size:10px;color:var(--muted);cursor:pointer;" onclick="if(confirm('Delete bet?'))deleteBet(${i})">x</span>
          </div>
        </div>`;
      }).join('');
    }

    function showAddBetDialog() {
      const away = prompt('Away team:'); if (!away) return;
      const home = prompt('Home team:'); if (!home) return;
      const side = prompt('Your side (home/away/over/under):') || '';
      const stakeStr = prompt('Stake ($):') || '0';
      const priceStr = prompt('Odds (e.g. -110, +150):') || '';
      const book = prompt('Book (e.g. FanDuel, DraftKings):') || '';
      myBets.push({
        home_team: home, away_team: away, side: side.toLowerCase(), team: '',
        stake: parseFloat(stakeStr) || 0, book,
        price: priceStr ? parseFloat(priceStr) : null, result: 'pending',
      });
      saveBets(); renderMyBets(); updateStats();
      alertPush('green', 'Bet added', `${away} @ ${home}`);
    }

    async function tryLoadKalshi() {
      try {
        const res = await fetch(`${baseUrl()}/api/markets/kalshi/positions`, { cache: 'no-store' });
        if (!res.ok) { alertPush('yellow', 'Kalshi positions', `HTTP ${res.status}`); return; }
        const j = await res.json();
        // Extract portfolio value if available
        if (j.portfolio_value != null) kalshiValue = Number(j.portfolio_value) || 0;
        else if (j.totalValue != null) kalshiValue = Number(j.totalValue) || 0;
        else if (j.balance != null) kalshiValue = Number(j.balance) || 0;
        // Ingest positions as bets
        const positions = j.positions || j.data || (Array.isArray(j) ? j : []);
        if (positions.length) ingestBets({ bets: positions });
        updateStats();
        alertPush('green', 'Kalshi loaded', `Value: $${kalshiValue.toFixed(2)}, ${positions.length} positions`);
      } catch (e) { alertPush('yellow', 'Kalshi positions', String(e).slice(0, 80)); }
    }
    async function tryLoadPolymarket() {
      try {
        const res = await fetch(`${baseUrl()}/api/markets/polymarket/positions`, { cache: 'no-store' });
        if (!res.ok) return alertPush('yellow', 'Polymarket', `HTTP ${res.status}`);
        const j = await res.json();
        const positions = j.positions || j.data || (Array.isArray(j) ? j : []);
        if (positions.length) ingestBets({ bets: positions });
        alertPush('green', 'Polymarket loaded', `${positions.length} positions`);
      } catch (e) { alertPush('yellow', 'Polymarket', String(e).slice(0, 80)); }
    }

    // Load bets from localStorage on startup
    loadBetsFromStorage();

    // ---- Audio ----
    function ensureAudio() {
      if (audioReady) return;
      try { AC = AC || new (window.AudioContext || window.webkitAudioContext)(); AC.resume && AC.resume(); audioReady = true; }
      catch (_) { audioReady = false; }
    }

    function playTone(freq, seconds) {
      if (muted) return;
      ensureAudio();
      if (!audioReady || !AC) return;
      const o = AC.createOscillator(); const g = AC.createGain();
      o.type = 'sine'; o.frequency.value = freq;
      g.gain.value = 0.0001;
      o.connect(g); g.connect(AC.destination);
      const now = AC.currentTime;
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + Math.max(0.05, seconds));
      o.start(); o.stop(now + Math.max(0.1, seconds + 0.05));
    }

    // MP3 crowd/boo (fallback to synth if Audio fails)
    let crowdAudio = null; let booAudio = null;
    try {
      crowdAudio = new Audio('./crowd-cheer.mp3'); crowdAudio.preload = 'auto'; crowdAudio.volume = 0.4;
      booAudio = new Audio('./crowd-disappointment.mp3'); booAudio.preload = 'auto'; booAudio.volume = 0.45;
    } catch { }

    function playCrowd() {
      if (muted) return;
      if (crowdAudio) {
        try { crowdAudio.currentTime = 0; crowdAudio.play().catch(() => { }); return; } catch { }
      }
      ensureAudio(); if (!AC) return;
      const src = AC.createBufferSource();
      const buf = AC.createBuffer(1, AC.sampleRate * 0.7, AC.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) { const t = i / AC.sampleRate; data[i] = (Math.random() * 2 - 1) * Math.exp(-t / 0.5); }
      src.buffer = buf; const g = AC.createGain(); g.gain.value = 0.0001; src.connect(g); g.connect(AC.destination);
      const now = AC.currentTime; g.gain.exponentialRampToValueAtTime(0.15, now + 0.02); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);
      src.start();
    }

    function playBoo() {
      if (muted) return;
      if (booAudio) {
        try { booAudio.currentTime = 0; booAudio.play().catch(() => { }); return; } catch { }
      }
      ensureAudio(); if (!AC) return;
      const o = AC.createOscillator(); const g = AC.createGain();
      o.type = 'sawtooth'; o.frequency.value = 180; g.gain.value = 0.0001; o.connect(g); g.connect(AC.destination);
      const now = AC.currentTime; g.gain.exponentialRampToValueAtTime(0.1, now + 0.01); o.frequency.exponentialRampToValueAtTime(110, now + 0.45); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
      o.start(); o.stop(now + 0.55);
    }

    // ---- Controls & keys ----
    const addBetBtn = document.getElementById('addBetBtn');
    soundPill?.addEventListener('click', () => { muted = !muted; soundPill.textContent = (muted ? 'üîá Sound: Off' : 'üîä Sound: On'); });
    pasteBtn?.addEventListener('click', promptPicks);
    pasteBetsBtn?.addEventListener('click', () => {
      const txt = prompt('Paste bets JSON (supports {bets:[...]}, {positions:[...]}, or array)');
      if (!txt) return; try { const j = JSON.parse(txt); ingestBets(j); } catch (e) { alertPush('yellow', 'Invalid JSON', String(e).slice(0, 80)); }
    });
    addBetBtn?.addEventListener('click', showAddBetDialog);
    loadKalshiBtn?.addEventListener('click', tryLoadKalshi);
    loadPolyBtn?.addEventListener('click', tryLoadPolymarket);
    testBtn?.addEventListener('click', () => { alertPush('red', 'Test alert', 'This is only a test'); });
    loadTodayPredsBtn?.addEventListener('click', loadTodayPredictions);
    loadTodayEarlyBtn?.addEventListener('click', loadTodayEarlyLines);
    testAudioBtn?.addEventListener('click', () => { playCrowd(); setTimeout(() => playBoo(), 900); });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'm' || e.key === 'M') { muted = !muted; if (soundPill) soundPill.textContent = (muted ? 'üîá Sound: Off' : 'üîä Sound: On'); }
      if (e.key === 'p' || e.key === 'P') { promptPicks(); }
      if (e.key === 'b' || e.key === 'B') { const txt = prompt('Paste bets JSON'); if (!txt) return; try { ingestBets(JSON.parse(txt)); } catch (e2) { alertPush('yellow', 'Invalid JSON', String(e2).slice(0, 80)); } }
      if (e.key === 'a' || e.key === 'A') { showAddBetDialog(); }
      if (e.key === 't' || e.key === 'T') { alertPush('yellow', 'Test alert', 'Keyboard trigger'); }
      if (e.key === 'l' || e.key === 'L') { loadTodayPredictions(); }
      if (e.key === 'e' || e.key === 'E') { loadTodayEarlyLines(); }
      if (e.key === 'c' || e.key === 'C') { playCrowd(); setTimeout(() => playBoo(), 900); }
    });

    function escapeHtml(s) { if (s == null) return ''; const div = document.createElement('div'); div.textContent = String(s); return div.innerHTML; }
  </script>
</body>

</html>
