<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Sports War Terminal v2</title>

  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

  <style>
    body {
      margin: 0;
      background: #05070c;
      color: white;
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
    }

    .container {
      display: grid;
      grid-template-rows: 8vh 72vh 20vh;
      height: 100vh;
    }

    /* ---------------- TOP RIBBON ---------------- */
    .ribbon {
      background: #0b0f1a;
      border-bottom: 1px solid #111;
      display: flex;
      align-items: center;
      overflow: hidden;
    }

    .ribbon-track {
      white-space: nowrap;
      animation: scroll 30s linear infinite;
    }

    .ribbon-item {
      display: inline-block;
      margin-right: 80px;
      font-size: 2vh;
    }

    @keyframes scroll {
      from {
        transform: translateX(0);
      }

      to {
        transform: translateX(-50%);
      }
    }

    /* ---------------- GRID ---------------- */
    .grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 1px;
      background: #111;
    }

    .game-card {
      background: #0b0f1a;
      padding: 2vh;
      position: relative;
      transition: 0.4s;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .game-card.focus {
      grid-column: span 2;
      grid-row: span 2;
      font-size: 1.3em;
    }

    .score {
      font-size: 5vh;
    }

    .time {
      font-size: 2.5vh;
      opacity: 0.8;
    }

    .prob {
      font-size: 4vh;
      margin-top: 1vh;
    }

    .bar-container {
      width: 80%;
      height: 14px;
      background: #111;
      border-radius: 10px;
      margin-top: 1vh;
      overflow: hidden;
    }

    .bar {
      height: 100%;
      width: 50%;
      background: #00ff99;
      transition: 0.5s;
    }

    .edge-positive {
      box-shadow: 0 0 15px #00ff99;
    }

    .edge-negative {
      box-shadow: 0 0 15px #ff0033;
    }

    .edge-spike {
      box-shadow: 0 0 25px #00ffff;
    }

    /* ---------------- BOTTOM ---------------- */
    .bottom {
      background: #0b0f1a;
      border-top: 1px solid #111;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.5vh;
    }

    .flash-green {
      background: #002b1a !important;
    }

    .flash-red {
      background: #2b0000 !important;
    }
  </style>
</head>

<body>

  <div class="container">

    <!-- TOP RIBBON -->
    <div class="ribbon">
      <div class="ribbon-track" id="ribbonTrack"></div>
    </div>

    <!-- GAME GRID -->
    <div class="grid" id="gameGrid"></div>

    <!-- BOTTOM INTEL -->
    <div class="bottom" id="intelPanel">
      Bankroll: $12,340 | Today: +$284 | Exposure: 18%
    </div>

  </div>

  <script>

    const positiveSound = new Howl({ src: ['crowd-cheer.mp3'], volume: 0.7 });
    const booSound = new Howl({ src: ['croed-disappointment.mp3'], volume: 0.7 });

    let games = {};
    let focusGame = null;
    let lastAlertTime = 0;

    /* ---------------- CREATE GAME CARD ---------------- */
    function createGameCard(id) {
      const card = document.createElement("div");
      card.className = "game-card";
      card.id = "game-" + id;
      card.innerHTML = `
    <div class="score" id="score-${id}"></div>
    <div class="time" id="time-${id}"></div>
    <div class="prob" id="prob-${id}"></div>
    <div class="bar-container">
      <div class="bar" id="bar-${id}"></div>
    </div>
  `;
      document.getElementById("gameGrid").appendChild(card);
    }

    /* ---------------- UPDATE GAME ---------------- */
    function updateGame(data) {

      if (!games[data.id]) {
        games[data.id] = { lastProb: data.prob };
        createGameCard(data.id);
      }

      const lastProb = games[data.id].lastProb;

      document.getElementById(`score-${data.id}`).innerHTML =
        data.home + " " + data.homeScore + "<br>" +
        data.away + " " + data.awayScore;

      document.getElementById(`time-${data.id}`).innerText = data.time;
      document.getElementById(`prob-${data.id}`).innerText = data.prob + "%";
      document.getElementById(`bar-${data.id}`).style.width = data.prob + "%";

      const card = document.getElementById("game-" + data.id);
      card.classList.remove("edge-positive", "edge-negative", "edge-spike");

      if (data.edge > 3) card.classList.add("edge-positive");
      if (data.edge < 0) card.classList.add("edge-negative");
      if (data.edge > 6) card.classList.add("edge-spike");

      // SOUND LOGIC
      if (Date.now() - lastAlertTime > 10000) {
        if (data.prob > lastProb + 5) {
          positiveSound.play();
          flashGreen();
          lastAlertTime = Date.now();
        }
        if (data.prob < lastProb - 5) {
          booSound.play();
          flashRed();
          lastAlertTime = Date.now();
        }
      }

      games[data.id].lastProb = data.prob;

      // ENDGAME MODE
      if (data.time.includes("4Q") && parseInt(data.time) < 5) {
        setFocus(data.id);
      }

      updateRibbon();
    }

    /* ---------------- FOCUS MODE ---------------- */
    function setFocus(id) {
      focusGame = id;
      document.querySelectorAll(".game-card").forEach(c => c.classList.remove("focus"));
      document.getElementById("game-" + id).classList.add("focus");
    }

    /* ---------------- RIBBON UPDATE ---------------- */
    function updateRibbon() {
      const ribbon = document.getElementById("ribbonTrack");
      ribbon.innerHTML = "";
      Object.values(games).forEach((g, i) => {
        const item = document.createElement("span");
        item.className = "ribbon-item";
        item.innerText = `Game ${i + 1} | WP ${g.lastProb}%`;
        ribbon.appendChild(item);
      });
    }

    /* ---------------- FLASH EFFECTS ---------------- */
    function flashGreen() {
      document.body.classList.add("flash-green");
      setTimeout(() => document.body.classList.remove("flash-green"), 300);
    }

    function flashRed() {
      document.body.classList.add("flash-red");
      setTimeout(() => document.body.classList.remove("flash-red"), 300);
    }

    /* ---------------- ROTATING INTEL ---------------- */
    let intelIndex = 0;
    const intelMessages = [
      "Bankroll: $12,340 | Today: +$284 | Exposure: 18%",
      "Model Accuracy: 58% | ROI: +6.2%",
      "Closing Line Value: +2.1%",
      "Volatility: Moderate | Risk: Controlled"
    ];

    setInterval(() => {
      intelIndex = (intelIndex + 1) % intelMessages.length;
      document.getElementById("intelPanel").innerText = intelMessages[intelIndex];
    }, 7000);

    /* ---------------- MY PICKS FROM PROGNO ---------------- */
    const API = window.location.hostname === 'localhost'
      ? 'http://localhost:3008/api'
      : 'http://192.168.8.152:3008/api';

    let myPicks = [];

    function formatKickoff(iso) {
      if (!iso) return '';
      try {
        const d = new Date(iso);
        return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } catch { return ''; }
    }

    function confidenceColor(conf) {
      if (conf >= 75) return '#00ff99';
      if (conf >= 60) return '#ffcc00';
      return '#ff6644';
    }

    function renderPicks(picks) {
      const grid = document.getElementById('gameGrid');
      grid.innerHTML = '';
      games = {};

      if (!picks || picks.length === 0) {
        grid.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#555;font-size:3vh;">No picks for today yet ‚Äî run predictions first</div>';
        return;
      }

      picks.forEach((pick, i) => {
        const id = i + 1;
        const conf = pick.confidence || pick.confidencePct || 70;
        const edge = pick.value_bet_edge || pick.edge || pick.edgePct || 0;
        const prob = conf;
        const game = pick.away_team && pick.home_team
          ? `${pick.away_team} @ ${pick.home_team}`
          : (pick.game || 'Game ' + id);
        const sport = (pick.sport || pick.league || '').toUpperCase();
        const kickoff = formatKickoff(pick.commence_time || pick.kickoff || pick.game_time);
        const pickTeam = pick.pick || '';
        const color = confidenceColor(conf);

        const card = document.createElement('div');
        card.className = 'game-card' + (edge > 6 ? ' edge-spike' : edge > 3 ? ' edge-positive' : '');
        card.id = 'game-' + id;
        card.innerHTML = `
      <div style="font-size:1.8vh;opacity:0.6;margin-bottom:0.5vh;">${sport}${kickoff ? ' ¬∑ ' + kickoff : ''}</div>
      <div class="score" style="font-size:2.8vh;text-align:center;line-height:1.4;">${game}</div>
      <div class="prob" style="color:${color};margin-top:1vh;">üéØ ${pickTeam}</div>
      <div style="font-size:2vh;opacity:0.8;margin-top:0.5vh;">Conf: ${conf}% ¬∑ Edge: +${typeof edge === 'number' ? edge.toFixed(1) : edge}%</div>
      <div class="bar-container">
        <div class="bar" id="bar-${id}" style="width:${prob}%;background:${color};"></div>
      </div>
    `;
        grid.appendChild(card);
        games[id] = { lastProb: prob };
      });

      updateRibbon(picks);
    }

    function updateRibbon(picks) {
      const ribbon = document.getElementById('ribbonTrack');
      if (!picks || picks.length === 0) return;
      // Double the items so the scroll loop is seamless
      const items = [...picks, ...picks];
      ribbon.innerHTML = items.map(p => {
        const conf = p.confidence || p.confidencePct || 70;
        const edge = p.value_bet_edge || p.edge || p.edgePct || 0;
        const sport = (p.sport || '').toUpperCase();
        return `<span class="ribbon-item">${sport} ¬∑ ${p.pick || ''} ¬∑ ${conf}% conf ¬∑ +${typeof edge === 'number' ? edge.toFixed(1) : edge}% edge</span>`;
      }).join('');
    }

    function updateIntel(picks) {
      if (!picks || picks.length === 0) return;
      const avgConf = picks.reduce((s, p) => s + (p.confidence || p.confidencePct || 70), 0) / picks.length;
      const avgEdge = picks.reduce((s, p) => s + (p.value_bet_edge || p.edge || p.edgePct || 0), 0) / picks.length;
      const totalStake = picks.length * 5;
      intelMessages[0] = `My Picks: ${picks.length} ¬∑ Avg Conf: ${avgConf.toFixed(0)}% ¬∑ Avg Edge: +${avgEdge.toFixed(1)}%`;
      intelMessages[1] = `Kalshi Exposure: $${totalStake} ($5/pick) ¬∑ ${picks.length} active positions`;
      intelMessages[2] = `Best pick: ${picks[0]?.pick || '-'} ¬∑ ${picks[0]?.confidence || picks[0]?.confidencePct || '-'}% confidence`;
      intelMessages[3] = `Sports: ${[...new Set(picks.map(p => p.sport || ''))].filter(Boolean).join(', ')}`;
    }

    async function fetchMyPicks() {
      try {
        const today = new Date().toISOString().split('T')[0];
        const res = await fetch(`${API}/cron/daily-predictions?date=${today}`, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });

        // The cron endpoint doesn't serve picks directly ‚Äî read the predictions file via a dedicated endpoint
        // Fall back to reading the predictions JSON directly
        const fileRes = await fetch(`${API}/progno/predictions-file?date=${today}&type=regular`);
        if (fileRes.ok) {
          const data = await fileRes.json();
          myPicks = data.picks || [];
        } else {
          // Last resort: try picks/today
          const picksRes = await fetch(`${API}/picks/today`);
          if (picksRes.ok) {
            const data = await picksRes.json();
            // Flatten all tiers into one list
            myPicks = [...(data.picks || []), ...(data.free || []), ...(data.pro || []), ...(data.elite || [])];
            // Deduplicate by game_id
            const seen = new Set();
            myPicks = myPicks.filter(p => {
              const key = p.game_id || p.gameId || p.id || JSON.stringify(p);
              if (seen.has(key)) return false;
              seen.add(key);
              return true;
            });
          }
        }

        renderPicks(myPicks);
        updateIntel(myPicks);
      } catch (err) {
        console.error('Failed to fetch picks:', err);
        document.getElementById('gameGrid').innerHTML =
          '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#555;font-size:2.5vh;">‚ö†Ô∏è Could not load picks ‚Äî check progno is running on port 3008</div>';
      }
    }

    // Load immediately, then refresh every 5 minutes
    fetchMyPicks();
    setInterval(fetchMyPicks, 5 * 60 * 1000);

  </script>
</body>

</html>
