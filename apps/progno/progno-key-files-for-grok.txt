Exporting key PROGNO files for Grok...


=== FILENAME: app/page.tsx ===
=== START CONTENT ===
'use client';

import { useState, useEffect } from 'react';

export default function LiveDashboard() {
  const [mounted, setMounted] = useState(false);
  const [sport, setSport] = useState('nhl');
  const [games, setGames] = useState<any[]>([]);
  const [scores, setScores] = useState<any[]>([]);
  const [predictions, setPredictions] = useState<Record<string, any>>({});
  const [watchlist, setWatchlist] = useState<string[]>(() => {
    if (typeof window !== 'undefined') {
      return JSON.parse(localStorage.getItem('prognoWatchlist') || '[]');
    }
    return [];
  });
  const [darkMode, setDarkMode] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [todayBets, setTodayBets] = useState<any[]>([]);

  // Cache predictions to prevent duplicate calls
  const predictionCache = new Map<string, any>();

  useEffect(() => {
    setMounted(true);
    const savedDarkMode = localStorage.getItem('darkMode') === 'true';
    setDarkMode(savedDarkMode);
    document.documentElement.classList.toggle('dark', savedDarkMode);
  }, []);

  const toggleDarkMode = () => {
    const newMode = !darkMode;
    setDarkMode(newMode);
    localStorage.setItem('darkMode', String(newMode));
    document.documentElement.classList.toggle('dark', newMode);
  };

  const fetchData = async (forceSport = sport) => {
    setLoading(true);
    setError(null);
    setGames([]);
    setScores([]);
    setTodayBets([]);

    if (forceSport === 'today') {
      await loadTodayBestBets();
      setLoading(false);
      return;
    }

    try {
      const gamesRes = await fetch(`/api/progno/v2?action=games&sport=${forceSport}`);
      const gamesData = await gamesRes.json();
      if (!gamesData.success) throw new Error(gamesData.error?.message || 'Failed to load games');
      setGames(gamesData.data || []);

      const scoresRes = await fetch(`/api/progno/v2?action=live-scores&sport=${forceSport}`);
      const scoresData = await scoresRes.json();
      if (!scoresData.success) throw new Error(scoresData.error?.message || 'Failed to load scores');
      setScores(scoresData.data || []);
    } catch (err: any) {
      setError(err.message || 'Error loading data');
    } finally {
      setLoading(false);
    }
  };

  const loadTodayBestBets = async () => {
    const leagues = ['nhl', 'ncaab', 'nba', 'nfl', 'ncaaf', 'mlb'];
    let allBets = [];

    for (const league of leagues) {
      try {
        const res = await fetch(`/api/progno/v2?action=games&sport=${league}`);
        const data = await res.json();
        if (data.success && data.data && data.data.length > 0) {
          for (const game of data.data.slice(0, 10)) { // stricter limit: only 10 games per league
            let predData = predictionCache.get(game.id);

            if (!predData) {
              const predRes = await fetch(`/api/progno/v2?action=prediction&gameId=${game.id}`);
              const pred = await predRes.json();
              if (pred.success && pred.data) {
                predData = pred.data;
                predictionCache.set(game.id, predData); // cache it
              }
            }

            if (predData && predData.confidence > 0.60) { // higher threshold to reduce calls
              const edge = predData.confidence - (Math.abs(game.odds?.moneyline?.home || 0) / 100);
              if (edge > 3) {
                allBets.push({
                  ...game,
                  league,
                  prediction: predData,
                  edge: edge.toFixed(2)
                });
              }
            }
          }
        }
      } catch (e) {
        console.error(`Error in ${league}:`, e);
      }
    }

    allBets.sort((a, b) => parseFloat(b.edge) - parseFloat(a.edge));
    setTodayBets(allBets.slice(0, 10));
  };

  const predictGame = async (gameId: string) => {
    try {
      const res = await fetch(`/api/progno/v2?action=prediction&gameId=${gameId}`);
      const data = await res.json();

      if (data.success) {
        setPredictions(prev => ({
          ...prev,
          [gameId]: data.data
        }));
      } else {
        alert(`Prediction failed: ${data.error?.message || 'Unknown error'}`);
      }
    } catch (err) {
      alert('Error running prediction');
    }
  };

  const saveToWatchlist = (gameId: string) => {
    setWatchlist(prev => {
      if (prev.includes(gameId)) return prev;
      const updated = [...prev, gameId];
      localStorage.setItem('prognoWatchlist', JSON.stringify(updated));
      return updated;
    });
  };

  const removeFromWatchlist = (gameId: string) => {
    setWatchlist(prev => {
      const updated = prev.filter(id => id !== gameId);
      localStorage.setItem('prognoWatchlist', JSON.stringify(updated));
      return updated;
    });
  };

  useEffect(() => {
    if (mounted) {
      fetchData();
      const interval = setInterval(fetchData, 60000);
      return () => clearInterval(interval);
    }
  }, [sport, mounted]);

  const mergedGames = games.map(game => {
    const isLive = game.scoreInfo && !game.scoreInfo.completed;
    const isCompleted = game.scoreInfo?.completed;

    return {
      ...game,
      scoreInfo: scores.find(s => s.id === game.id),
      prediction: predictions[game.id],
      isSaved: watchlist.includes(game.id),
      hasPotentialArb: Math.abs((game.odds?.moneyline?.home ?? 0) - (game.odds?.moneyline?.away ?? 0)) > 20,
      isLive,
      isCompleted
    };
  });

  const clearPredictions = () => setPredictions({});

  if (!mounted) return null;

  const isTodayMode = sport === 'today';

  return (
    <div className={`min-h-screen ${darkMode ? 'bg-gray-900 text-white' : 'bg-gray-50 text-gray-900'}`}>
      <div className="max-w-none mx-auto p-6">
        <header className="flex flex-col md:flex-row justify-between items-start md:items-center mb-8 gap-4">
          <h1 className="text-4xl font-bold">PROGNO ‚Äî Live Sports Dashboard</h1>
          <button
            onClick={toggleDarkMode}
            className={`px-4 py-2 rounded-lg font-medium transition-colors ${
              darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-200 hover:bg-gray-300'
            }`}
          >
            {darkMode ? 'Light Mode' : 'Dark Mode'}
          </button>
        </header>

        <div className="flex flex-wrap items-center gap-4 mb-6">
          <label className="font-medium">View:</label>
          <select
            value={sport}
            onChange={e => {
              setSport(e.target.value);
              fetchData(e.target.value);
            }}
            className={`p-2 rounded-lg border ${
              darkMode ? 'bg-gray-800 border-gray-700 text-white' : 'bg-white border-gray-300'
            }`}
          >
            <option value="nhl">NHL</option>
            <option value="ncaab">NCAAB</option>
            <option value="nba">NBA</option>
            <option value="nfl">NFL</option>
            <option value="ncaaf">NCAAF</option>
            <option value="mlb">MLB</option>
            <option value="today">Today‚Äôs Best Bets</option>
          </select>

          <button
            onClick={() => fetchData()}
            disabled={loading}
            className={`px-4 py-2 rounded-lg font-medium transition-colors ${
              loading ? 'bg-gray-500 cursor-not-allowed text-white' : 'bg-blue-600 hover:bg-blue-700 text-white'
            }`}
          >
            {loading ? 'Refreshing...' : 'Refresh Now'}
          </button>

          <button
            onClick={clearPredictions}
            className="px-4 py-2 rounded-lg font-medium bg-red-600 hover:bg-red-700 text-white transition-colors"
          >
            Clear Predictions
          </button>
        </div>

        {error && (
          <p className="text-red-500 font-medium mb-6 p-4 bg-red-50 dark:bg-red-900/30 rounded-lg">
            {error}
          </p>
        )}

        {loading && <p className="text-gray-500 dark:text-gray-400 mb-6">Loading...</p>}

        {isTodayMode ? (
          <div>
            <h2 className="text-2xl font-bold mb-6">Today‚Äôs Best Bets (Top 10)</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {todayBets.length === 0 ? (
                <p className="col-span-full text-center text-gray-500 dark:text-gray-400 py-10">
                  No strong bets found today (higher threshold applied).
                </p>
              ) : (
                todayBets.map(bet => (
                  <div key={bet.id} className={`rounded-xl shadow-lg p-6 border ${darkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'}`}>
                    <div className="flex justify-between items-start mb-3">
                      <h3 className="text-xl font-bold">
                        {bet.homeTeam} vs {bet.awayTeam}
                      </h3>
                      <span className="text-xs px-2 py-1 bg-blue-600 text-white rounded">
                        {bet.league.toUpperCase()}
                      </span>
                    </div>

                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
                      {new Date(bet.startTime).toLocaleString()}
                    </p>

                    <div className={`p-4 rounded-lg mb-4 ${darkMode ? 'bg-gray-700' : 'bg-blue-50 border border-blue-200'}`}>
                      <strong className="block mb-2 text-lg">Prediction:</strong>
                      {bet.prediction.winner} wins<br />
                      <strong>Confidence:</strong> {(bet.prediction.confidence * 100).toFixed(1)}%<br />
                      <strong>Projected:</strong> {bet.prediction.score.home} - {bet.prediction.score.away}

                      {bet.prediction.keyFactors && (
                        <div className="mt-4">
                          <strong>Reasoning:</strong>
                          <ul className="list-disc ml-5 mt-1 text-sm space-y-1">
                            {bet.prediction.keyFactors.map((f, i) => <li key={i}>{f}</li>)}
                          </ul>
                        </div>
                      )}
                    </div>

                    <div className="font-medium text-green-600 dark:text-green-400 mb-2">
                      Recommended Bets:
                    </div>
                    <ul className="text-sm space-y-1 mb-4">
                      {bet.prediction.confidence > 0.65 && <li>‚úÖ Moneyline on {bet.prediction.winner}</li>}
                      {Math.abs(bet.odds?.spread?.home || 0) > 3 && <li>‚úÖ Spread on favorite</li>}
                      {bet.odds?.total?.line && <li>‚úÖ Totals: Over/Under {bet.odds.total.line}</li>}
                      {bet.hasPotentialArb && <li>‚ö° Arbitrage opportunity detected!</li>}
                    </ul>

                    <div className="text-sm font-medium">
                      Recommended allocation: <span className="text-green-600">2.5% of bankroll</span>
                    </div>
                  </div>
                ))
              )}
            </div>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {mergedGames.length === 0 && !loading && (
              <p className="col-span-full text-center text-gray-500 dark:text-gray-400 py-10">
                No games or odds available for {sport.toUpperCase()} right now.
              </p>
            )}

            {mergedGames.map(game => {
              const isLive = game.scoreInfo && !game.scoreInfo.completed;
              const isCompleted = game.scoreInfo?.completed;

              return (
                <div
                  key={game.id}
                  className={`rounded-xl shadow-lg p-6 transition-all border w-full ${
                    darkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
                  }`}
                >
                  <div className="flex justify-between items-start mb-3">
                    <div className="flex items-center gap-2">
                      <h3 className="text-xl font-bold">
                        {game.homeTeam} vs {game.awayTeam}
                      </h3>
                      {game.hasPotentialArb && (
                        <span className="text-green-500 font-bold" title="Potential arbitrage opportunity">
                          ‚ö°
                        </span>
                      )}
                    </div>
                    {game.isSaved ? (
                      <button
                        onClick={() => removeFromWatchlist(game.id)}
                        className="text-yellow-500 hover:text-yellow-400 font-medium"
                      >
                        ‚òÖ Saved
                      </button>
                    ) : (
                      <button
                        onClick={() => saveToWatchlist(game.id)}
                        className="text-gray-400 hover:text-yellow-500 font-medium"
                      >
                        ‚òÜ Save
                      </button>
                    )}
                  </div>

                  <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-600'} mb-3`}>
                    {new Date(game.startTime).toLocaleString()} ‚Ä¢ {game.venue}
                  </p>

                  {isLive && (
                    <p className="text-2xl font-bold text-green-500 mb-4">
                      LIVE: {game.scoreInfo?.homeScore ?? '?'} - {game.scoreInfo?.awayScore ?? '?'}
                    </p>
                  )}
                  {isCompleted && (
                    <p className="text-2xl font-bold mb-4">
                      FINAL: {game.scoreInfo?.homeScore ?? '?'} - {game.scoreInfo?.awayScore ?? '?'}
                    </p>
                  )}

                  <div className="space-y-2 text-sm mb-5">
                    <div>
                      <strong>Moneyline:</strong><br />
                      {game.homeTeam}: {game.odds?.moneyline?.home ?? 'N/A'}<br />
                      {game.awayTeam}: {game.odds?.moneyline?.away ?? 'N/A'}
                    </div>
                    <div>
                      <strong>Spread:</strong> {game.homeTeam} {game.odds?.spread?.home ?? 'N/A'} ‚Ä¢ Total: {game.odds?.total?.line ?? 'N/A'}
                    </div>
                  </div>

                  {game.prediction ? (
                    <div className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-blue-50 border border-blue-200'}`}>
                      <strong className="block mb-2 text-lg">Prediction:</strong>
                      {game.prediction.winner} wins<br />
                      <strong>Confidence:</strong> {(game.prediction.confidence * 100).toFixed(1)}%<br />
                      <strong>Projected:</strong> {game.prediction.score.home} - {game.prediction.score.away}

                      {game.prediction.keyFactors && game.prediction.keyFactors.length > 0 && (
                        <div className="mt-4">
                          <strong>Key Factors:</strong>
                          <ul className="list-disc ml-5 mt-2 space-y-1 text-sm">
                            {game.prediction.keyFactors.map((factor: string, i: number) => (
                              <li key={i}>{factor}</li>
                            ))}
                          </ul>
                        </div>
                      )}
                    </div>
                  ) : (
                    <div className="flex flex-col sm:flex-row gap-3 mt-5">
                      <button
                        onClick={() => predictGame(game.id)}
                        disabled={loading}
                        className={`flex-1 py-3 rounded-lg font-medium text-white transition-colors ${
                          loading ? 'bg-gray-500 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'
                        }`}
                      >
                        Run Prediction
                      </button>
                      <button
                        onClick={() =>
                          alert(
                            `Arbitrage check for ${game.homeTeam} vs ${game.awayTeam}:\n` +
                            `Home ML: ${game.odds?.moneyline?.home ?? 'N/A'} | Away ML: ${game.odds?.moneyline?.away ?? 'N/A'}\n` +
                            `Spread: ${game.odds?.spread?.home ?? 'N/A'} | Total: ${game.odds?.total?.line ?? 'N/A'}\n` +
                            `No obvious +EV lines detected yet.`
                          )
                        }
                        className="px-6 py-3 rounded-lg bg-green-600 hover:bg-green-700 text-white font-medium transition-colors"
                      >
                        Arbitrage Check
                      </button>
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        )}

        {watchlist.length > 0 && (
          <div className="mt-12">
            <h2 className="text-2xl font-bold mb-4">
              Watchlist ({watchlist.length})
            </h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {mergedGames
                .filter(game => watchlist.includes(game.id))
                .map(game => (
                  <div
                    key={game.id}
                    className={`p-4 rounded-lg border ${
                      darkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'
                    }`}
                  >
                    <div className="flex justify-between items-center">
                      <h4 className="font-semibold">
                        {game.homeTeam} vs {game.awayTeam}
                      </h4>
                      <button
                        onClick={() => removeFromWatchlist(game.id)}
                        className="text-red-500 hover:text-red-700"
                      >
                        Remove
                      </button>
                    </div>
                    {game.prediction && (
                      <p className="mt-2 text-sm">
                        Prediction: {game.prediction.winner} ({(game.prediction.confidence * 100).toFixed(1)}%)
                      </p>
                    )}
                  </div>
                ))}
            </div>
          </div>
        )}

        <footer className="mt-16 text-center text-sm text-gray-500 dark:text-gray-400">
          ¬© 2026 PROGNO ‚Ä¢ Cevict Flux v2.0 ‚Ä¢ Claude Effect Engine<br />
          For entertainment purposes only. Gamble responsibly.
        </footer>
      </div>
    </div>
  );
}

=== END CONTENT ===


=== FILE NOT FOUND: app/(marketing)/page.tsx (and alternatives) ===


=== FILENAME: app/accuracy/page.tsx ===
=== START CONTENT ===
'use client';

/**
 * Accuracy Dashboard Page
 * 
 * Shows our AI's historical performance metrics
 * Competitors like Leans AI show ~71.3% accuracy - we show EVERYTHING
 */

import AccuracyDashboard from '../components/AccuracyDashboard';
import { useRouter } from 'next/navigation';

export default function AccuracyPage() {
  const router = useRouter();

  return (
    <div style={{
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%)',
      padding: '2rem',
    }}>
      <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
        {/* Header */}
        <div style={{ marginBottom: '2rem' }}>
          <button
            onClick={() => router.push('/')}
            style={{
              background: 'rgba(255, 255, 255, 0.1)',
              border: 'none',
              padding: '0.75rem 1.5rem',
              borderRadius: '8px',
              color: 'white',
              cursor: 'pointer',
              marginBottom: '1.5rem',
              fontSize: '1rem',
            }}
          >
            ‚Üê Back to Home
          </button>
          
          <h1 style={{
            fontSize: '2.5rem',
            fontWeight: 'bold',
            color: 'white',
            marginBottom: '0.5rem',
          }}>
            üìä AI Accuracy Dashboard
          </h1>
          <p style={{
            fontSize: '1.125rem',
            color: 'rgba(255, 255, 255, 0.7)',
          }}>
            Comprehensive performance metrics for Cevict Flex AI predictions
          </p>
        </div>

        {/* Main Dashboard */}
        <AccuracyDashboard />

        {/* Footer Info */}
        <div style={{
          marginTop: '2rem',
          padding: '1.5rem',
          background: 'rgba(255, 255, 255, 0.05)',
          borderRadius: '12px',
          textAlign: 'center',
          color: 'rgba(255, 255, 255, 0.6)',
          fontSize: '0.875rem',
        }}>
          <p style={{ marginBottom: '0.5rem' }}>
            <strong style={{ color: 'white' }}>How We Compare:</strong>
          </p>
          <p>
            Rithmm: Basic AI Model ‚Ä¢ Leans AI: 71.3% Accuracy Claim ‚Ä¢ Juice Reel: ML Picks ‚Ä¢ OddsTrader: Computer Analysis
          </p>
          <p style={{ marginTop: '1rem', color: '#10b981' }}>
            <strong>Cevict Flex: 7-Dimensional Claude Effect + Monte Carlo Simulations + Value Betting Detection</strong>
          </p>
        </div>
      </div>
    </div>
  );
}



=== END CONTENT ===


=== FILENAME: app/api/progno/v2/route.ts ===
=== START CONTENT ===
// app/api/progno/v2/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { predictGameWithEnrichment } from '@/lib/data-sources/predict-with-enrichment';
import { OddsService } from '@/lib/odds-service';
import { getDisclaimer } from '@/lib/legal-disclaimers';

const API_VERSION = '2.0.0';
const API_NAME = 'Cevict Flux v2.0';

function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substring(7)}`;
}

function handleError(error: any): NextResponse {
  console.error('API Error:', error);
  return NextResponse.json({
    success: false,
    error: { code: 'INTERNAL_ERROR', message: error.message || 'An unexpected error occurred' },
  }, { status: 500 });
}

export async function GET(request: NextRequest) {
  const startTime = Date.now();
  const requestId = generateRequestId();
  const { searchParams } = new URL(request.url);
  const action = searchParams.get('action') || 'info';

  try {
    let response: NextResponse;

    switch (action) {
      case 'health':
        response = NextResponse.json({ 
          success: true, 
          data: { status: 'healthy', version: API_VERSION, timestamp: new Date().toISOString() } 
        });
        break;

      case 'info':
        response = NextResponse.json({ 
          success: true, 
          data: { name: API_NAME, version: API_VERSION, supportedSports: ['nfl', 'nba', 'mlb', 'nhl', 'ncaab', 'cfb'] }
        });
        break;

      case 'games':
        const sport = searchParams.get('sport');
        const date = searchParams.get('date');
        const games = await OddsService.getGames({ sport: sport || undefined, date: date || undefined });
        response = NextResponse.json({ success: true, data: games });
        break;

      case 'prediction':
        const gameId = searchParams.get('gameId');
        if (!gameId) {
          response = NextResponse.json({ success: false, error: { message: 'gameId required' } }, { status: 400 });
          break;
        }
        const game = await OddsService.getGame(gameId);
        if (!game) {
          response = NextResponse.json({ success: false, error: { message: 'Game not found' } }, { status: 404 });
          break;
        }
        const prediction = await predictGameWithEnrichment(game);
        response = NextResponse.json({ 
          success: true, 
          data: prediction,
          disclaimer: getDisclaimer('prediction')
        });
        break;

      case 'live-scores':
        const liveSport = searchParams.get('sport') || 'nhl';
        const liveData = await OddsService.getLiveScores(liveSport);
        response = NextResponse.json({ success: true, data: liveData });
        break;

      default:
        response = NextResponse.json({ 
          success: true, 
          data: { name: API_NAME, version: API_VERSION, message: 'Use ?action=games or ?action=prediction' }
        });
    }

    const duration = Date.now() - startTime;
    console.log(`[AUDIT] ${action} completed in ${duration}ms`);

    return response;
  } catch (error: any) {
    console.error(`[ERROR] ${action}:`, error);
    return handleError(error);
  }
}

=== END CONTENT ===


=== FILE NOT FOUND: app/api/progno/v2/elite-analyze/route.ts (and alternatives) ===


=== FILENAME (found alt): app/components/EnhancedPicksCard.tsx ===
=== START CONTENT ===
'use client';

/**
 * Enhanced Picks Card Component
 * 
 * Shows all bet types for a single game:
 * - Moneyline (who wins)
 * - Spread (point spread)
 * - Total (over/under)
 * 
 * Plus value betting indicators and Monte Carlo confidence
 */

import { useState } from 'react';

interface Pick {
  sport: string;
  home_team: string;
  away_team: string;
  game_time: string;
  confidence: number;
  is_premium: boolean;
  analysis: string;
  
  // Moneyline
  pick: string;
  odds: number;
  
  // Claude Effect
  claude_effect: number;
  sentiment_field: number;
  narrative_momentum: number;
  information_asymmetry: number;
  chaos_sensitivity: number;
  ai_confidence: string;
  
  // Monte Carlo
  mc_win_probability: number;
  mc_predicted_score: { home: number; away: number };
  mc_spread_probability: number;
  mc_total_probability: number;
  mc_iterations: number;
  
  // Value Bet
  value_bet_edge: number;
  value_bet_ev: number;
  has_value: boolean;
}

interface EnhancedPicksCardProps {
  pick: Pick;
  showDetails?: boolean;
}

export default function EnhancedPicksCard({ pick, showDetails = true }: EnhancedPicksCardProps) {
  const [activeTab, setActiveTab] = useState<'moneyline' | 'spread' | 'total'>('moneyline');
  const [expanded, setExpanded] = useState(false);

  const gameTime = new Date(pick.game_time);
  const timeStr = gameTime.toLocaleTimeString('en-US', { 
    hour: 'numeric', 
    minute: '2-digit',
    hour12: true 
  });
  const dateStr = gameTime.toLocaleDateString('en-US', { 
    weekday: 'short', 
    month: 'short', 
    day: 'numeric' 
  });

  const winProb = pick.mc_win_probability || (pick.confidence / 100);
  const spreadProb = pick.mc_spread_probability || 0.5;
  const totalProb = pick.mc_total_probability || 0.5;

  return (
    <div style={{
      background: 'rgba(255, 255, 255, 0.05)',
      borderRadius: '16px',
      overflow: 'hidden',
      border: pick.is_premium 
        ? '2px solid rgba(245, 158, 11, 0.5)' 
        : pick.has_value 
          ? '1px solid rgba(16, 185, 129, 0.3)'
          : '1px solid rgba(255, 255, 255, 0.1)',
    }}>
      {/* Header */}
      <div style={{
        padding: '1rem 1.5rem',
        background: pick.is_premium 
          ? 'linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(234, 179, 8, 0.1) 100%)'
          : 'rgba(255, 255, 255, 0.02)',
        borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
      }}>
        <div>
          <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
            <span style={{ fontSize: '1.5rem' }}>{getSportEmoji(pick.sport)}</span>
            <div>
              <div style={{ 
                fontSize: '1.125rem', 
                fontWeight: 'bold', 
                color: 'white' 
              }}>
                {pick.away_team} @ {pick.home_team}
              </div>
              <div style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.6)' }}>
                {pick.sport} ‚Ä¢ {dateStr} ‚Ä¢ {timeStr}
              </div>
            </div>
          </div>
        </div>
        <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
          {pick.is_premium && (
            <span style={{
              background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
              color: 'white',
              padding: '0.25rem 0.75rem',
              borderRadius: '9999px',
              fontSize: '0.75rem',
              fontWeight: 'bold',
            }}>
              ‚≠ê PREMIUM
            </span>
          )}
          {pick.has_value && (
            <span style={{
              background: 'rgba(16, 185, 129, 0.2)',
              color: '#10b981',
              padding: '0.25rem 0.75rem',
              borderRadius: '9999px',
              fontSize: '0.75rem',
              fontWeight: 'bold',
              border: '1px solid rgba(16, 185, 129, 0.3)',
            }}>
              üí∞ VALUE
            </span>
          )}
          <div style={{
            background: getConfidenceColor(pick.confidence),
            color: 'white',
            padding: '0.5rem 1rem',
            borderRadius: '8px',
            fontSize: '1.25rem',
            fontWeight: 'bold',
          }}>
            {pick.confidence}%
          </div>
        </div>
      </div>

      {/* Bet Type Tabs */}
      <div style={{
        display: 'flex',
        borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
      }}>
        {(['moneyline', 'spread', 'total'] as const).map((tab) => (
          <button
            key={tab}
            onClick={() => setActiveTab(tab)}
            style={{
              flex: 1,
              padding: '1rem',
              background: activeTab === tab ? 'rgba(79, 70, 229, 0.2)' : 'transparent',
              border: 'none',
              borderBottom: activeTab === tab ? '2px solid #4f46e5' : '2px solid transparent',
              color: activeTab === tab ? 'white' : 'rgba(255, 255, 255, 0.6)',
              cursor: 'pointer',
              fontSize: '0.875rem',
              fontWeight: activeTab === tab ? 'bold' : 'normal',
              transition: 'all 0.2s',
            }}
          >
            {tab === 'moneyline' ? 'üíµ Moneyline' : tab === 'spread' ? 'üìä Spread' : 'üìà Total'}
          </button>
        ))}
      </div>

      {/* Tab Content */}
      <div style={{ padding: '1.5rem' }}>
        {activeTab === 'moneyline' && (
          <BetTypeContent
            title="Moneyline Pick"
            pick={pick.pick}
            probability={winProb}
            odds={pick.odds}
            edge={pick.value_bet_edge}
            ev={pick.value_bet_ev}
            predictedScore={pick.mc_predicted_score}
            reasoning={`Win probability: ${(winProb * 100).toFixed(1)}% based on ${pick.mc_iterations || 1000}+ simulations`}
          />
        )}
        {activeTab === 'spread' && (
          <BetTypeContent
            title="Spread Pick"
            pick={`${pick.pick} (spread TBD)`}
            probability={spreadProb}
            odds={-110}
            edge={spreadProb > 0.52 ? (spreadProb - 0.52) * 100 : 0}
            ev={spreadProb > 0.52 ? (spreadProb * 91 - (1 - spreadProb) * 100) : 0}
            predictedScore={pick.mc_predicted_score}
            reasoning={`Cover probability: ${(spreadProb * 100).toFixed(1)}%`}
          />
        )}
        {activeTab === 'total' && (
          <BetTypeContent
            title="Total Pick"
            pick={totalProb > 0.5 ? 'Over' : 'Under'}
            probability={Math.max(totalProb, 1 - totalProb)}
            odds={-110}
            edge={(Math.max(totalProb, 1 - totalProb) - 0.52) * 100}
            ev={0}
            predictedScore={pick.mc_predicted_score}
            reasoning={`${totalProb > 0.5 ? 'Over' : 'Under'} probability: ${(Math.max(totalProb, 1 - totalProb) * 100).toFixed(1)}%`}
          />
        )}
      </div>

      {/* Claude Effect Section (Expandable) */}
      {showDetails && (
        <div style={{
          borderTop: '1px solid rgba(255, 255, 255, 0.1)',
        }}>
          <button
            onClick={() => setExpanded(!expanded)}
            style={{
              width: '100%',
              padding: '1rem 1.5rem',
              background: 'rgba(255, 255, 255, 0.02)',
              border: 'none',
              color: 'rgba(255, 255, 255, 0.7)',
              cursor: 'pointer',
              fontSize: '0.875rem',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
            }}
          >
            <span>ü§ñ Claude Effect AI Details</span>
            <span>{expanded ? '‚ñ≤' : '‚ñº'}</span>
          </button>
          
          {expanded && (
            <div style={{ padding: '1rem 1.5rem', paddingTop: 0 }}>
              <div style={{ 
                display: 'grid', 
                gridTemplateColumns: 'repeat(auto-fit, minmax(120px, 1fr))', 
                gap: '1rem',
                marginBottom: '1rem',
              }}>
                <ClaudeEffectMeter label="Sentiment" value={pick.sentiment_field} />
                <ClaudeEffectMeter label="Narrative" value={pick.narrative_momentum} />
                <ClaudeEffectMeter label="Sharp Money" value={pick.information_asymmetry} />
                <ClaudeEffectMeter label="Chaos Risk" value={pick.chaos_sensitivity} />
              </div>
              
              <div style={{
                background: 'rgba(255, 255, 255, 0.05)',
                borderRadius: '8px',
                padding: '1rem',
                fontSize: '0.875rem',
                color: 'rgba(255, 255, 255, 0.8)',
              }}>
                <strong>AI Analysis:</strong> {pick.analysis}
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

function BetTypeContent({
  title,
  pick,
  probability,
  odds,
  edge,
  ev,
  predictedScore,
  reasoning,
}: {
  title: string;
  pick: string;
  probability: number;
  odds: number;
  edge: number;
  ev: number;
  predictedScore?: { home: number; away: number };
  reasoning: string;
}) {
  return (
    <div>
      <div style={{ 
        display: 'flex', 
        justifyContent: 'space-between', 
        alignItems: 'flex-start',
        marginBottom: '1.5rem',
      }}>
        <div>
          <div style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.6)', marginBottom: '0.25rem' }}>
            {title}
          </div>
          <div style={{ fontSize: '1.75rem', fontWeight: 'bold', color: 'white' }}>
            {pick}
          </div>
          <div style={{ fontSize: '1rem', color: '#60a5fa' }}>
            {odds > 0 ? `+${odds}` : odds}
          </div>
        </div>
        
        {predictedScore && (
          <div style={{ textAlign: 'right' }}>
            <div style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.6)', marginBottom: '0.25rem' }}>
              Predicted Score
            </div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'white' }}>
              {predictedScore.home} - {predictedScore.away}
            </div>
          </div>
        )}
      </div>

      {/* Probability Bar */}
      <div style={{ marginBottom: '1rem' }}>
        <div style={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          fontSize: '0.875rem',
          marginBottom: '0.5rem',
        }}>
          <span style={{ color: 'rgba(255, 255, 255, 0.6)' }}>Win Probability</span>
          <span style={{ color: '#10b981', fontWeight: 'bold' }}>{(probability * 100).toFixed(1)}%</span>
        </div>
        <div style={{
          height: '8px',
          background: 'rgba(255, 255, 255, 0.1)',
          borderRadius: '4px',
          overflow: 'hidden',
        }}>
          <div style={{
            height: '100%',
            width: `${probability * 100}%`,
            background: probability > 0.65 
              ? 'linear-gradient(90deg, #10b981, #34d399)'
              : probability > 0.55
                ? 'linear-gradient(90deg, #fbbf24, #f59e0b)'
                : 'linear-gradient(90deg, #60a5fa, #3b82f6)',
            borderRadius: '4px',
          }} />
        </div>
      </div>

      {/* Edge & EV */}
      <div style={{ 
        display: 'grid', 
        gridTemplateColumns: '1fr 1fr', 
        gap: '1rem',
        marginBottom: '1rem',
      }}>
        <div style={{
          background: edge > 3 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(255, 255, 255, 0.05)',
          borderRadius: '8px',
          padding: '1rem',
          border: edge > 3 ? '1px solid rgba(16, 185, 129, 0.3)' : 'none',
        }}>
          <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>Edge</div>
          <div style={{ 
            fontSize: '1.25rem', 
            fontWeight: 'bold', 
            color: edge > 3 ? '#10b981' : 'white' 
          }}>
            {edge > 0 ? '+' : ''}{edge.toFixed(1)}%
          </div>
        </div>
        <div style={{
          background: ev > 0 ? 'rgba(245, 158, 11, 0.1)' : 'rgba(255, 255, 255, 0.05)',
          borderRadius: '8px',
          padding: '1rem',
          border: ev > 0 ? '1px solid rgba(245, 158, 11, 0.3)' : 'none',
        }}>
          <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>Expected Value</div>
          <div style={{ 
            fontSize: '1.25rem', 
            fontWeight: 'bold', 
            color: ev > 0 ? '#f59e0b' : 'white' 
          }}>
            {ev >= 0 ? '+' : ''}${ev.toFixed(0)}/bet
          </div>
        </div>
      </div>

      <div style={{
        fontSize: '0.875rem',
        color: 'rgba(255, 255, 255, 0.6)',
        fontStyle: 'italic',
      }}>
        {reasoning}
      </div>
    </div>
  );
}

function ClaudeEffectMeter({ label, value }: { label: string; value: number }) {
  const normalized = Math.min(1, Math.max(-1, value * 5)); // Scale to -1 to 1
  const percentage = (normalized + 1) / 2 * 100; // Convert to 0-100

  return (
    <div>
      <div style={{ 
        fontSize: '0.75rem', 
        color: 'rgba(255, 255, 255, 0.6)',
        marginBottom: '0.25rem',
      }}>
        {label}
      </div>
      <div style={{
        height: '6px',
        background: 'rgba(255, 255, 255, 0.1)',
        borderRadius: '3px',
        overflow: 'hidden',
        position: 'relative',
      }}>
        {/* Center marker */}
        <div style={{
          position: 'absolute',
          left: '50%',
          top: 0,
          bottom: 0,
          width: '2px',
          background: 'rgba(255, 255, 255, 0.3)',
        }} />
        {/* Value indicator */}
        <div style={{
          position: 'absolute',
          left: `${Math.min(percentage, 50)}%`,
          width: `${Math.abs(percentage - 50)}%`,
          height: '100%',
          background: value > 0 
            ? 'linear-gradient(90deg, transparent, #10b981)'
            : 'linear-gradient(270deg, transparent, #ef4444)',
        }} />
      </div>
      <div style={{
        fontSize: '0.75rem',
        fontWeight: 'bold',
        color: value > 0 ? '#10b981' : value < 0 ? '#ef4444' : 'rgba(255, 255, 255, 0.6)',
        marginTop: '0.25rem',
      }}>
        {value > 0 ? '+' : ''}{(value * 100).toFixed(0)}%
      </div>
    </div>
  );
}

function getSportEmoji(sport: string): string {
  const emojis: Record<string, string> = {
    NFL: 'üèà',
    NCAAF: 'üèà',
    NBA: 'üèÄ',
    NCAAB: 'üèÄ',
    NHL: 'üèí',
    MLB: '‚öæ',
  };
  return emojis[sport?.toUpperCase()] || 'üéØ';
}

function getConfidenceColor(confidence: number): string {
  if (confidence >= 80) return 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
  if (confidence >= 70) return 'linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%)';
  if (confidence >= 60) return 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
  return 'linear-gradient(135deg, #6b7280 0%, #4b5563 100%)';
}



=== END CONTENT ===


=== FILENAME (found alt): app/components/ClaudeEffectCard.tsx ===
=== START CONTENT ===
/**
 * Claude Effect Visualization Component
 * Displays all 7 dimensions in a card format
 */

'use client';

import React from 'react';

interface ClaudeEffectScores {
  sentimentField: number;
  narrativeMomentum: number;
  informationAsymmetry: number;
  chaosSensitivity: number;
  networkInfluence: number;
  temporalDecay: number;
  emergentPattern: number;
}

interface ClaudeEffectCardProps {
  scores: ClaudeEffectScores;
  adjustedProbability: number;
  adjustedConfidence: number;
  reasoning?: string[];
  warnings?: string[];
  recommendations?: {
    betSize: 'small' | 'medium' | 'large' | 'avoid';
    reason: string;
  };
}

export default function ClaudeEffectCard({
  scores,
  adjustedProbability,
  adjustedConfidence,
  reasoning = [],
  warnings = [],
  recommendations,
}: ClaudeEffectCardProps) {
  const formatScore = (score: number, range: number = 0.2) => {
    const percentage = (score / range) * 100;
    return `${percentage >= 0 ? '+' : ''}${percentage.toFixed(1)}%`;
  };

  const getScoreColor = (score: number, isChaos: boolean = false) => {
    if (isChaos) {
      // CSI: higher = worse (red), lower = better (green)
      if (score > 0.6) return 'text-red-500';
      if (score > 0.4) return 'text-orange-500';
      if (score > 0.2) return 'text-yellow-500';
      return 'text-green-500';
    } else {
      // Other dimensions: positive = green, negative = red
      if (score > 0.05) return 'text-green-500';
      if (score < -0.05) return 'text-red-500';
      return 'text-gray-400';
    }
  };

  const getBetSizeColor = (size: string) => {
    switch (size) {
      case 'large': return 'bg-green-500';
      case 'medium': return 'bg-yellow-500';
      case 'small': return 'bg-orange-500';
      case 'avoid': return 'bg-red-500';
      default: return 'bg-gray-500';
    }
  };

  return (
    <div className="bg-gradient-to-br from-purple-900 via-pink-900 to-red-900 rounded-lg p-6 text-white shadow-xl">
      <h2 className="text-2xl font-bold mb-4">üéØ The Claude Effect</h2>

      {/* Main Metrics */}
      <div className="grid grid-cols-2 gap-4 mb-6">
        <div className="bg-black/30 rounded-lg p-4">
          <div className="text-sm text-gray-300 mb-1">Adjusted Probability</div>
          <div className="text-3xl font-bold text-green-400">
            {(adjustedProbability * 100).toFixed(1)}%
          </div>
        </div>
        <div className="bg-black/30 rounded-lg p-4">
          <div className="text-sm text-gray-300 mb-1">Adjusted Confidence</div>
          <div className="text-3xl font-bold text-blue-400">
            {(adjustedConfidence * 100).toFixed(1)}%
          </div>
        </div>
      </div>

      {/* Dimension Scores */}
      <div className="space-y-3 mb-6">
        <div className="flex justify-between items-center">
          <span className="text-sm">üé≠ Sentiment Field</span>
          <span className={`font-bold ${getScoreColor(scores.sentimentField)}`}>
            {formatScore(scores.sentimentField)}
          </span>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-sm">üìñ Narrative Momentum</span>
          <span className={`font-bold ${getScoreColor(scores.narrativeMomentum)}`}>
            {formatScore(scores.narrativeMomentum, 0.3)}
          </span>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-sm">üïµÔ∏è Information Asymmetry</span>
          <span className={`font-bold ${getScoreColor(scores.informationAsymmetry)}`}>
            {formatScore(scores.informationAsymmetry)}
          </span>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-sm">üåÄ Chaos Sensitivity</span>
          <span className={`font-bold ${getScoreColor(scores.chaosSensitivity, true)}`}>
            {(scores.chaosSensitivity * 100).toFixed(0)}%
          </span>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-sm">üîó Network Influence</span>
          <span className={`font-bold ${getScoreColor(scores.networkInfluence)}`}>
            {formatScore(scores.networkInfluence)}
          </span>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-sm">‚è±Ô∏è Temporal Decay</span>
          <span className="font-bold text-gray-400">
            {(scores.temporalDecay * 100).toFixed(0)}%
          </span>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-sm">üß¨ Emergent Patterns</span>
          <span className={`font-bold ${getScoreColor(scores.emergentPattern)}`}>
            {formatScore(scores.emergentPattern)}
          </span>
        </div>
      </div>

      {/* Recommendations */}
      {recommendations && (
        <div className={`${getBetSizeColor(recommendations.betSize)} rounded-lg p-3 mb-4`}>
          <div className="font-bold text-lg mb-1">
            Recommendation: {recommendations.betSize.toUpperCase()}
          </div>
          <div className="text-sm opacity-90">{recommendations.reason}</div>
        </div>
      )}

      {/* Warnings */}
      {warnings.length > 0 && (
        <div className="bg-red-900/50 rounded-lg p-3 mb-4">
          <div className="font-bold mb-2">‚ö†Ô∏è Warnings</div>
          <ul className="text-sm space-y-1">
            {warnings.map((warning, i) => (
              <li key={i}>‚Ä¢ {warning}</li>
            ))}
          </ul>
        </div>
      )}

      {/* Reasoning */}
      {reasoning.length > 0 && (
        <div className="bg-black/30 rounded-lg p-3">
          <div className="font-bold mb-2 text-sm">üí° Insights</div>
          <ul className="text-sm space-y-1">
            {reasoning.slice(0, 3).map((reason, i) => (
              <li key={i}>‚Ä¢ {reason}</li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}



=== END CONTENT ===


=== FILENAME: components/SharpMoneyIndicator.tsx ===
=== START CONTENT ===
'use client';

/**
 * Sharp Money Indicator
 * Shows professional betting activity - reverse line movement, steam moves
 * Competitor feature: Action Network PRO
 */

import { useState, useEffect } from 'react';

interface SharpMoneyData {
  sharpSide: 'home' | 'away' | 'over' | 'under' | null;
  confidence: number;
  indicators: string[];
  steamMove: boolean;
  reverseLineMove: boolean;
}

interface PublicBettingData {
  spreadPublic: { home: number; away: number };
  moneylinePublic: { home: number; away: number };
  totalPublic: { over: number; under: number };
  ticketCount: number;
  moneyPercentage: { home: number; away: number };
}

interface Props {
  gameId: string;
  homeTeam: string;
  awayTeam: string;
}

export default function SharpMoneyIndicator({ gameId, homeTeam, awayTeam }: Props) {
  const [data, setData] = useState<{
    sharp: SharpMoneyData;
    public: PublicBettingData;
  } | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchData();
  }, [gameId]);

  const fetchData = async () => {
    try {
      const res = await fetch(`/api/odds/live?league=NFL&analysis=true`);
      if (res.ok) {
        const result = await res.json();
        const game = result.games?.find((g: any) => g.gameId === gameId);
        if (game?.analysis) {
          setData({
            sharp: game.analysis.sharpMoney,
            public: game.analysis.publicBetting,
          });
        }
      }
    } catch (error) {
      console.error('Error fetching sharp money data:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="animate-pulse bg-white/5 rounded-xl p-4">
        <div className="h-4 bg-white/10 rounded w-1/3 mb-2" />
        <div className="h-20 bg-white/10 rounded" />
      </div>
    );
  }

  if (!data) return null;

  const { sharp, public: publicData } = data;

  return (
    <div className="bg-gradient-to-br from-slate-900 to-slate-800 rounded-2xl overflow-hidden border border-white/10">
      {/* Header */}
      <div className="p-4 border-b border-white/10 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <span className="text-xl">ü¶à</span>
          <h3 className="font-bold text-white">Sharp Money Analysis</h3>
        </div>
        {sharp.steamMove && (
          <span className="px-2 py-1 bg-red-500/20 text-red-400 text-xs font-bold rounded-full animate-pulse">
            üî• STEAM MOVE
          </span>
        )}
      </div>

      <div className="p-4 space-y-4">
        {/* Public vs Money Split */}
        <div>
          <div className="text-xs text-white/50 mb-2">PUBLIC BETTING vs MONEY</div>
          <div className="grid grid-cols-2 gap-4">
            {/* Spread */}
            <div className="bg-white/5 rounded-xl p-3">
              <div className="text-xs text-white/40 mb-2">SPREAD</div>
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm text-white">{awayTeam}</span>
                <span className="text-sm font-mono text-white">{publicData.spreadPublic.away}%</span>
              </div>
              <div className="h-2 bg-white/10 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-blue-500 to-cyan-500 rounded-full"
                  style={{ width: `${publicData.spreadPublic.away}%` }}
                />
              </div>
              <div className="flex items-center justify-between mt-1">
                <span className="text-sm text-white">{homeTeam}</span>
                <span className="text-sm font-mono text-white">{publicData.spreadPublic.home}%</span>
              </div>
            </div>

            {/* Moneyline */}
            <div className="bg-white/5 rounded-xl p-3">
              <div className="text-xs text-white/40 mb-2">MONEYLINE</div>
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm text-white">{awayTeam}</span>
                <span className="text-sm font-mono text-white">{publicData.moneylinePublic.away}%</span>
              </div>
              <div className="h-2 bg-white/10 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-purple-500 to-pink-500 rounded-full"
                  style={{ width: `${publicData.moneylinePublic.away}%` }}
                />
              </div>
              <div className="flex items-center justify-between mt-1">
                <span className="text-sm text-white">{homeTeam}</span>
                <span className="text-sm font-mono text-white">{publicData.moneylinePublic.home}%</span>
              </div>
            </div>
          </div>
        </div>

        {/* Sharp Money Confidence */}
        {sharp.sharpSide && (
          <div className={`rounded-xl p-4 ${
            sharp.confidence > 70 ? 'bg-emerald-500/20 border border-emerald-500/30' :
            sharp.confidence > 40 ? 'bg-yellow-500/20 border border-yellow-500/30' :
            'bg-white/5 border border-white/10'
          }`}>
            <div className="flex items-center justify-between mb-2">
              <span className="font-bold text-white">Sharp Side</span>
              <span className={`text-2xl font-black ${
                sharp.confidence > 70 ? 'text-emerald-400' :
                sharp.confidence > 40 ? 'text-yellow-400' :
                'text-white/60'
              }`}>
                {sharp.confidence}%
              </span>
            </div>
            <div className="text-lg font-bold text-white mb-2">
              {sharp.sharpSide === 'home' ? homeTeam : 
               sharp.sharpSide === 'away' ? awayTeam :
               sharp.sharpSide === 'over' ? 'Over' : 'Under'}
            </div>
            <div className="flex gap-2 flex-wrap">
              {sharp.reverseLineMove && (
                <span className="px-2 py-1 bg-yellow-500/20 text-yellow-400 text-xs rounded-full">
                  ‚Ü©Ô∏è Reverse Line
                </span>
              )}
              {sharp.steamMove && (
                <span className="px-2 py-1 bg-red-500/20 text-red-400 text-xs rounded-full">
                  üî• Steam
                </span>
              )}
            </div>
          </div>
        )}

        {/* Indicators */}
        {sharp.indicators.length > 0 && (
          <div>
            <div className="text-xs text-white/50 mb-2">INDICATORS</div>
            <div className="space-y-2">
              {sharp.indicators.map((indicator, i) => (
                <div 
                  key={i}
                  className="flex items-start gap-2 text-sm text-white/70"
                >
                  <span className="text-emerald-400">‚Ä¢</span>
                  {indicator}
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Ticket Count */}
        <div className="flex items-center justify-between text-sm">
          <span className="text-white/50">Total Tickets</span>
          <span className="text-white font-mono">
            {publicData.ticketCount.toLocaleString()}
          </span>
        </div>
      </div>

      {/* Footer */}
      <div className="px-4 py-3 bg-white/5 text-center">
        <p className="text-xs text-white/40">
          üí° Sharp money = Professional bettors. Follow the money, not the public.
        </p>
      </div>
    </div>
  );
}



=== END CONTENT ===


=== FILENAME (found alt): app/components/AccuracyDashboard.tsx ===
=== START CONTENT ===
'use client';

/**
 * Accuracy Dashboard Component
 * 
 * Displays comprehensive accuracy metrics like competitors show:
 * - Big win rate headline (like "71.3% Accuracy")
 * - Sport-by-sport breakdown
 * - Confidence calibration
 * - Streak tracking
 * - ROI metrics
 * 
 * This is what sets us apart from Rithmm, Leans AI, Juice Reel, etc.
 */

import { useState, useEffect } from 'react';

interface AccuracyData {
  overall: {
    totalPredictions: number;
    completedPredictions: number;
    pendingPredictions: number;
    winRate: number;
    roi: number;
    avgConfidence: number;
    avgEdge: number;
    units: number;
  };
  bySport: {
    [sport: string]: {
      predictions: number;
      wins: number;
      winRate: number;
      roi: number;
      streak: number;
    };
  };
  byConfidence: {
    [range: string]: {
      predictions: number;
      wins: number;
      winRate: number;
      expectedWinRate: number;
      calibration: number;
    };
  };
  timePeriods: {
    last7Days: { predictions: number; wins: number; winRate: number; roi: number };
    last30Days: { predictions: number; wins: number; winRate: number; roi: number };
    last90Days: { predictions: number; wins: number; winRate: number; roi: number };
    allTime: { predictions: number; wins: number; winRate: number; roi: number };
  };
  streaks: {
    currentStreak: number;
    currentStreakType: 'win' | 'loss' | 'none';
    longestWinStreak: number;
    longestLossStreak: number;
  };
  valueBetting: {
    totalValueBets: number;
    valueBetWins: number;
    valueBetWinRate: number;
    avgEdge: number;
    totalEdgeCapture: number;
  };
  comparisons?: {
    vsRithmm: { competitor: string; difference: number; status: string };
    vsLeansAI: { competitor: string; difference: number; status: string };
    vsJuiceReel: { competitor: string; difference: number; status: string };
  };
}

export default function AccuracyDashboard() {
  const [data, setData] = useState<AccuracyData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedPeriod, setSelectedPeriod] = useState<'last7Days' | 'last30Days' | 'last90Days' | 'allTime'>('allTime');

  useEffect(() => {
    fetchAccuracyData();
  }, []);

  const fetchAccuracyData = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/accuracy');
      const result = await response.json();
      
      if (result.success) {
        setData(result.data);
      } else {
        setError(result.error || 'Failed to fetch accuracy data');
      }
    } catch (err: any) {
      setError(err.message || 'Network error');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div style={{ padding: '2rem', textAlign: 'center', color: '#9ca3af' }}>
        <div style={{ fontSize: '2rem', marginBottom: '1rem' }}>üìä</div>
        Loading accuracy metrics...
      </div>
    );
  }

  if (error || !data) {
    return (
      <div style={{ padding: '2rem', textAlign: 'center', color: '#ef4444' }}>
        <div style={{ fontSize: '2rem', marginBottom: '1rem' }}>‚ö†Ô∏è</div>
        {error || 'No data available'}
      </div>
    );
  }

  const winRatePercent = (data.overall.winRate * 100).toFixed(1);
  const periodData = data.timePeriods[selectedPeriod];

  return (
    <div style={{
      padding: '2rem',
      background: 'linear-gradient(135deg, #1e1b4b 0%, #312e81 50%, #4c1d95 100%)',
      borderRadius: '16px',
      color: 'white',
    }}>
      {/* Hero Section - Big Win Rate */}
      <div style={{
        textAlign: 'center',
        marginBottom: '3rem',
        padding: '2rem',
        background: 'rgba(255, 255, 255, 0.05)',
        borderRadius: '16px',
        border: '1px solid rgba(255, 255, 255, 0.1)',
      }}>
        <div style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.6)', marginBottom: '0.5rem' }}>
          CEVICT FLEX AI ACCURACY
        </div>
        <div style={{
          fontSize: '5rem',
          fontWeight: 'bold',
          background: 'linear-gradient(135deg, #10b981 0%, #34d399 100%)',
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
          lineHeight: 1,
        }}>
          {winRatePercent}%
        </div>
        <div style={{ fontSize: '1.25rem', color: 'rgba(255, 255, 255, 0.8)', marginTop: '0.5rem' }}>
          Win Rate ‚Ä¢ {data.overall.completedPredictions.toLocaleString()} Predictions
        </div>
        
        {/* Streak Badge */}
        {data.streaks.currentStreak > 0 && (
          <div style={{
            display: 'inline-block',
            marginTop: '1rem',
            padding: '0.5rem 1rem',
            background: data.streaks.currentStreakType === 'win' 
              ? 'rgba(16, 185, 129, 0.2)' 
              : 'rgba(239, 68, 68, 0.2)',
            border: `1px solid ${data.streaks.currentStreakType === 'win' ? '#10b981' : '#ef4444'}`,
            borderRadius: '9999px',
            fontSize: '0.875rem',
          }}>
            {data.streaks.currentStreakType === 'win' ? 'üî•' : '‚ùÑÔ∏è'} {data.streaks.currentStreak} Game {data.streaks.currentStreakType === 'win' ? 'Win' : 'Loss'} Streak
          </div>
        )}
      </div>

      {/* Key Metrics Row */}
      <div style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))',
        gap: '1rem',
        marginBottom: '2rem',
      }}>
        <MetricCard 
          label="ROI" 
          value={`${data.overall.roi >= 0 ? '+' : ''}${data.overall.roi.toFixed(1)}%`}
          color={data.overall.roi >= 0 ? '#10b981' : '#ef4444'}
        />
        <MetricCard 
          label="Units Won" 
          value={`${data.overall.units >= 0 ? '+' : ''}${data.overall.units.toFixed(1)}`}
          color={data.overall.units >= 0 ? '#10b981' : '#ef4444'}
        />
        <MetricCard 
          label="Avg Confidence" 
          value={`${(data.overall.avgConfidence * 100).toFixed(0)}%`}
          color="#60a5fa"
        />
        <MetricCard 
          label="Avg Edge" 
          value={`+${data.overall.avgEdge.toFixed(1)}%`}
          color="#a78bfa"
        />
      </div>

      {/* Time Period Selector */}
      <div style={{
        display: 'flex',
        gap: '0.5rem',
        marginBottom: '2rem',
        flexWrap: 'wrap',
      }}>
        {(['last7Days', 'last30Days', 'last90Days', 'allTime'] as const).map((period) => (
          <button
            key={period}
            onClick={() => setSelectedPeriod(period)}
            style={{
              padding: '0.5rem 1rem',
              borderRadius: '8px',
              border: 'none',
              background: selectedPeriod === period ? '#4f46e5' : 'rgba(255, 255, 255, 0.1)',
              color: 'white',
              cursor: 'pointer',
              fontSize: '0.875rem',
            }}
          >
            {period === 'last7Days' ? '7 Days' : 
             period === 'last30Days' ? '30 Days' : 
             period === 'last90Days' ? '90 Days' : 'All Time'}
          </button>
        ))}
      </div>

      {/* Selected Period Stats */}
      <div style={{
        background: 'rgba(255, 255, 255, 0.05)',
        borderRadius: '12px',
        padding: '1.5rem',
        marginBottom: '2rem',
      }}>
        <h3 style={{ margin: '0 0 1rem 0', fontSize: '1.125rem' }}>
          {selectedPeriod === 'allTime' ? 'All Time' : `Last ${selectedPeriod.replace('last', '').replace('Days', ' Days')}`} Performance
        </h3>
        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem' }}>
          <div>
            <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>Predictions</div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>{periodData.predictions}</div>
          </div>
          <div>
            <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>Wins</div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#10b981' }}>{periodData.wins}</div>
          </div>
          <div>
            <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>Win Rate</div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>{(periodData.winRate * 100).toFixed(1)}%</div>
          </div>
          <div>
            <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>ROI</div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: periodData.roi >= 0 ? '#10b981' : '#ef4444' }}>
              {periodData.roi >= 0 ? '+' : ''}{periodData.roi.toFixed(1)}%
            </div>
          </div>
        </div>
      </div>

      {/* Sport Breakdown */}
      <div style={{
        background: 'rgba(255, 255, 255, 0.05)',
        borderRadius: '12px',
        padding: '1.5rem',
        marginBottom: '2rem',
      }}>
        <h3 style={{ margin: '0 0 1rem 0', fontSize: '1.125rem' }}>üìä Performance by Sport</h3>
        <div style={{ display: 'grid', gap: '0.75rem' }}>
          {Object.entries(data.bySport).map(([sport, stats]) => (
            <div key={sport} style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              padding: '0.75rem',
              background: 'rgba(255, 255, 255, 0.05)',
              borderRadius: '8px',
            }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
                <span style={{ fontSize: '1.25rem' }}>{getSportEmoji(sport)}</span>
                <span style={{ fontWeight: '600' }}>{sport}</span>
                <span style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.6)' }}>
                  ({stats.predictions} picks)
                </span>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '1.5rem' }}>
                <div style={{ textAlign: 'right' }}>
                  <div style={{ 
                    fontSize: '1.125rem', 
                    fontWeight: 'bold',
                    color: stats.winRate >= 0.7 ? '#10b981' : stats.winRate >= 0.6 ? '#fbbf24' : '#ef4444'
                  }}>
                    {(stats.winRate * 100).toFixed(1)}%
                  </div>
                  <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>
                    {stats.wins}W-{stats.predictions - stats.wins}L
                  </div>
                </div>
                {stats.streak !== 0 && (
                  <div style={{
                    padding: '0.25rem 0.5rem',
                    borderRadius: '4px',
                    background: stats.streak > 0 ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)',
                    fontSize: '0.75rem',
                    color: stats.streak > 0 ? '#10b981' : '#ef4444',
                  }}>
                    {stats.streak > 0 ? 'üî•' : '‚ùÑÔ∏è'} {Math.abs(stats.streak)}
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Confidence Calibration */}
      <div style={{
        background: 'rgba(255, 255, 255, 0.05)',
        borderRadius: '12px',
        padding: '1.5rem',
        marginBottom: '2rem',
      }}>
        <h3 style={{ margin: '0 0 1rem 0', fontSize: '1.125rem' }}>üéØ Confidence Calibration</h3>
        <p style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.6)', marginBottom: '1rem' }}>
          How accurate are we at each confidence level? (1.0 = perfectly calibrated)
        </p>
        <div style={{ display: 'grid', gap: '0.5rem' }}>
          {Object.entries(data.byConfidence).map(([range, stats]) => (
            <div key={range} style={{
              display: 'flex',
              alignItems: 'center',
              gap: '1rem',
            }}>
              <div style={{ width: '80px', fontSize: '0.875rem' }}>{range}</div>
              <div style={{ flex: 1, height: '24px', background: 'rgba(255, 255, 255, 0.1)', borderRadius: '4px', overflow: 'hidden' }}>
                <div style={{
                  height: '100%',
                  width: `${Math.min(stats.winRate * 100, 100)}%`,
                  background: stats.calibration >= 0.95 && stats.calibration <= 1.05 
                    ? 'linear-gradient(90deg, #10b981, #34d399)'
                    : stats.calibration > 1.05 
                      ? 'linear-gradient(90deg, #3b82f6, #60a5fa)'
                      : 'linear-gradient(90deg, #f59e0b, #fbbf24)',
                  borderRadius: '4px',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'flex-end',
                  paddingRight: '0.5rem',
                  fontSize: '0.75rem',
                  fontWeight: 'bold',
                }}>
                  {stats.predictions > 0 ? `${(stats.winRate * 100).toFixed(0)}%` : '‚Äî'}
                </div>
              </div>
              <div style={{ width: '60px', textAlign: 'right', fontSize: '0.875rem' }}>
                {stats.predictions > 0 ? (
                  <span style={{ 
                    color: stats.calibration >= 0.95 && stats.calibration <= 1.05 
                      ? '#10b981' 
                      : stats.calibration > 1.05 ? '#3b82f6' : '#f59e0b'
                  }}>
                    {stats.calibration.toFixed(2)}x
                  </span>
                ) : '‚Äî'}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Value Betting Performance */}
      <div style={{
        background: 'linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(234, 179, 8, 0.1) 100%)',
        borderRadius: '12px',
        padding: '1.5rem',
        marginBottom: '2rem',
        border: '1px solid rgba(245, 158, 11, 0.2)',
      }}>
        <h3 style={{ margin: '0 0 1rem 0', fontSize: '1.125rem' }}>üí∞ Value Betting Performance</h3>
        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(140px, 1fr))', gap: '1rem' }}>
          <div>
            <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>Value Bets</div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>{data.valueBetting.totalValueBets}</div>
          </div>
          <div>
            <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>Win Rate</div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#f59e0b' }}>
              {(data.valueBetting.valueBetWinRate * 100).toFixed(1)}%
            </div>
          </div>
          <div>
            <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>Avg Edge</div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>+{data.valueBetting.avgEdge.toFixed(1)}%</div>
          </div>
          <div>
            <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)' }}>Edge Capture</div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#10b981' }}>
              {(data.valueBetting.totalEdgeCapture * 100).toFixed(0)}%
            </div>
          </div>
        </div>
      </div>

      {/* Competitor Comparison */}
      {data.comparisons && (
        <div style={{
          background: 'rgba(255, 255, 255, 0.05)',
          borderRadius: '12px',
          padding: '1.5rem',
        }}>
          <h3 style={{ margin: '0 0 1rem 0', fontSize: '1.125rem' }}>üèÜ vs Competition</h3>
          <div style={{ display: 'grid', gap: '0.75rem' }}>
            {Object.values(data.comparisons).map((comp: any) => (
              <div key={comp.competitor} style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                padding: '0.75rem',
                background: 'rgba(255, 255, 255, 0.05)',
                borderRadius: '8px',
              }}>
                <span>{comp.competitor}</span>
                <span style={{ 
                  color: comp.difference > 0 ? '#10b981' : comp.difference === 0 ? '#fbbf24' : '#ef4444',
                  fontWeight: 'bold',
                }}>
                  {comp.status} {comp.difference > 0 ? `+${comp.difference.toFixed(1)}%` : comp.difference === 0 ? '' : `${comp.difference.toFixed(1)}%`}
                </span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

function MetricCard({ label, value, color }: { label: string; value: string; color: string }) {
  return (
    <div style={{
      background: 'rgba(255, 255, 255, 0.05)',
      borderRadius: '12px',
      padding: '1rem',
      textAlign: 'center',
    }}>
      <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)', marginBottom: '0.25rem' }}>
        {label}
      </div>
      <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color }}>
        {value}
      </div>
    </div>
  );
}

function getSportEmoji(sport: string): string {
  const emojis: Record<string, string> = {
    NFL: 'üèà',
    NCAAF: 'üèà',
    NBA: 'üèÄ',
    NCAAB: 'üèÄ',
    NHL: 'üèí',
    MLB: '‚öæ',
  };
  return emojis[sport] || 'üéØ';
}



=== END CONTENT ===


=== FILENAME (found alt): app/components/ConfidenceGauge.tsx ===
=== START CONTENT ===
"use client";


interface ConfidenceGaugeProps {
  confidence: number;
  size?: 'small' | 'medium' | 'large';
  showLabel?: boolean;
  color?: string;
}

export default function ConfidenceGauge({
  confidence,
  size = 'medium',
  showLabel = true,
  color
}: ConfidenceGaugeProps) {
  const normalizedConfidence = Math.max(0, Math.min(1, confidence));
  const percentage = Math.round(normalizedConfidence * 100);

  const sizeConfig = {
    small: { width: 60, height: 30, fontSize: 10 },
    medium: { width: 100, height: 50, fontSize: 12 },
    large: { width: 150, height: 75, fontSize: 14 }
  };

  const config = sizeConfig[size];

  const getColor = (value: number) => {
    if (color) return color;
    if (value >= 0.8) return '#10b981'; // green
    if (value >= 0.6) return '#f59e0b'; // yellow
    if (value >= 0.4) return '#f97316'; // orange
    return '#ef4444'; // red
  };

  const gaugeColor = getColor(normalizedConfidence);

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 4 }}>
      <svg width={config.width} height={config.height} viewBox="0 0 100 50">
        {/* Background arc */}
        <path
          d="M 10 40 A 40 40 0 0 1 90 40"
          fill="none"
          stroke="#e5e7eb"
          strokeWidth="8"
          strokeLinecap="round"
        />

        {/* Confidence arc */}
        <path
          d="M 10 40 A 40 40 0 0 1 90 40"
          fill="none"
          stroke={gaugeColor}
          strokeWidth="8"
          strokeLinecap="round"
          strokeDasharray={`${normalizedConfidence * 126} 126`}
          style={{
            transition: 'stroke-dasharray 0.5s ease-in-out'
          }}
        />

        {/* Center dot */}
        <circle
          cx="50"
          cy="40"
          r="4"
          fill={gaugeColor}
        />

        {/* Percentage text */}
        <text
          x="50"
          y="25"
          textAnchor="middle"
          fontSize={config.fontSize}
          fontWeight="bold"
          fill={gaugeColor}
        >
          {percentage}%
        </text>
      </svg>

      {showLabel && (
        <div style={{ fontSize: config.fontSize, color: '#6b7280' }}>
          Confidence
        </div>
      )}
    </div>
  );
}


=== END CONTENT ===


=== FILENAME: components/ExpertConsensus.tsx ===
=== START CONTENT ===
'use client';

/**
 * Expert Consensus Component
 * Shows aggregated expert picks and records
 * Competitor feature: Covers.com Expert Consensus
 */

interface ExpertPick {
  name: string;
  pick: string;
  record: string;
  roi: number;
}

interface ExpertConsensusData {
  total: number;
  home: number;
  away: number;
  over: number;
  under: number;
}

interface Props {
  homeTeam: string;
  awayTeam: string;
  expertPicks: ExpertConsensusData;
  topExperts: ExpertPick[];
  consensusPick: string;
  consensusConfidence: number;
}

export default function ExpertConsensus({
  homeTeam,
  awayTeam,
  expertPicks,
  topExperts,
  consensusPick,
  consensusConfidence,
}: Props) {
  const spreadTotal = expertPicks.home + expertPicks.away;
  const totalTotal = expertPicks.over + expertPicks.under;

  return (
    <div className="bg-gradient-to-br from-slate-900 to-slate-800 rounded-2xl overflow-hidden border border-white/10">
      {/* Header */}
      <div className="p-4 border-b border-white/10">
        <div className="flex items-center gap-2">
          <span className="text-xl">üéì</span>
          <h3 className="font-bold text-white">Expert Consensus</h3>
          <span className="text-xs text-white/40">({expertPicks.total} experts)</span>
        </div>
      </div>

      <div className="p-4 space-y-4">
        {/* Consensus Pick */}
        <div className="bg-gradient-to-r from-purple-500/20 to-pink-500/20 rounded-xl p-4 border border-purple-500/30">
          <div className="text-xs text-purple-300 mb-1">CONSENSUS PICK</div>
          <div className="text-xl font-bold text-white">{consensusPick}</div>
          <div className="flex items-center gap-2 mt-2">
            <div className="flex-1 h-2 bg-white/10 rounded-full overflow-hidden">
              <div 
                className="h-full bg-gradient-to-r from-purple-500 to-pink-500 rounded-full"
                style={{ width: `${consensusConfidence}%` }}
              />
            </div>
            <span className="text-sm font-bold text-purple-300">{consensusConfidence.toFixed(0)}%</span>
          </div>
        </div>

        {/* Spread Picks */}
        <div>
          <div className="text-xs text-white/50 mb-2">SPREAD PICKS</div>
          <div className="flex gap-2">
            <div className={`flex-1 p-3 rounded-xl ${
              expertPicks.away > expertPicks.home 
                ? 'bg-emerald-500/20 border border-emerald-500/30' 
                : 'bg-white/5'
            }`}>
              <div className="text-sm text-white/70">{awayTeam}</div>
              <div className="text-2xl font-bold text-white">{expertPicks.away}</div>
              <div className="text-xs text-white/40">
                {spreadTotal > 0 ? ((expertPicks.away / spreadTotal) * 100).toFixed(0) : 0}%
              </div>
            </div>
            <div className={`flex-1 p-3 rounded-xl ${
              expertPicks.home > expertPicks.away 
                ? 'bg-emerald-500/20 border border-emerald-500/30' 
                : 'bg-white/5'
            }`}>
              <div className="text-sm text-white/70">{homeTeam}</div>
              <div className="text-2xl font-bold text-white">{expertPicks.home}</div>
              <div className="text-xs text-white/40">
                {spreadTotal > 0 ? ((expertPicks.home / spreadTotal) * 100).toFixed(0) : 0}%
              </div>
            </div>
          </div>
        </div>

        {/* Total Picks */}
        <div>
          <div className="text-xs text-white/50 mb-2">TOTAL PICKS</div>
          <div className="flex gap-2">
            <div className={`flex-1 p-3 rounded-xl ${
              expertPicks.over > expertPicks.under 
                ? 'bg-blue-500/20 border border-blue-500/30' 
                : 'bg-white/5'
            }`}>
              <div className="text-sm text-white/70">Over</div>
              <div className="text-2xl font-bold text-white">{expertPicks.over}</div>
              <div className="text-xs text-white/40">
                {totalTotal > 0 ? ((expertPicks.over / totalTotal) * 100).toFixed(0) : 0}%
              </div>
            </div>
            <div className={`flex-1 p-3 rounded-xl ${
              expertPicks.under > expertPicks.over 
                ? 'bg-blue-500/20 border border-blue-500/30' 
                : 'bg-white/5'
            }`}>
              <div className="text-sm text-white/70">Under</div>
              <div className="text-2xl font-bold text-white">{expertPicks.under}</div>
              <div className="text-xs text-white/40">
                {totalTotal > 0 ? ((expertPicks.under / totalTotal) * 100).toFixed(0) : 0}%
              </div>
            </div>
          </div>
        </div>

        {/* Top Experts */}
        <div>
          <div className="text-xs text-white/50 mb-2">TOP EXPERTS</div>
          <div className="space-y-2">
            {topExperts.map((expert, i) => (
              <div 
                key={i}
                className="flex items-center justify-between p-3 bg-white/5 rounded-xl hover:bg-white/10 transition-all"
              >
                <div className="flex items-center gap-3">
                  <div className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold ${
                    i === 0 ? 'bg-yellow-500 text-black' :
                    i === 1 ? 'bg-slate-400 text-black' :
                    i === 2 ? 'bg-amber-700 text-white' :
                    'bg-white/20 text-white'
                  }`}>
                    {i + 1}
                  </div>
                  <div>
                    <div className="font-medium text-white">{expert.name}</div>
                    <div className="text-xs text-white/50">{expert.record}</div>
                  </div>
                </div>
                <div className="text-right">
                  <div className="text-sm font-bold text-white">{expert.pick}</div>
                  <div className={`text-xs ${expert.roi > 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                    {expert.roi > 0 ? '+' : ''}{expert.roi}% ROI
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}



=== END CONTENT ===


=== FILENAME: components/NotificationCenter.tsx ===
=== START CONTENT ===
'use client';

/**
 * Notification Center
 * Real-time alerts for high-value picks, line movements, and arbitrage opportunities
 */

import { useState, useEffect } from 'react';

interface Notification {
  id: string;
  type: 'pick' | 'movement' | 'arbitrage' | 'result' | 'system';
  title: string;
  message: string;
  timestamp: Date;
  read: boolean;
  priority: 'high' | 'medium' | 'low';
  actionUrl?: string;
}

export default function NotificationCenter() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [isOpen, setIsOpen] = useState(false);
  const [filter, setFilter] = useState<'all' | 'unread'>('all');

  useEffect(() => {
    // Load initial notifications
    setNotifications(getSampleNotifications());
    
    // Simulate real-time notifications
    const interval = setInterval(() => {
      if (Math.random() > 0.7) {
        addRandomNotification();
      }
    }, 30000);

    return () => clearInterval(interval);
  }, []);

  const getSampleNotifications = (): Notification[] => [
    {
      id: '1',
      type: 'pick',
      title: 'üî• High Confidence Pick',
      message: 'Chiefs -3 vs Raiders (82% confidence) - Value detected!',
      timestamp: new Date(Date.now() - 300000),
      read: false,
      priority: 'high',
      actionUrl: '/create-prediction'
    },
    {
      id: '2',
      type: 'arbitrage',
      title: 'üí∞ Arbitrage Opportunity',
      message: 'Bills ML: 2.3% guaranteed profit across DraftKings/FanDuel',
      timestamp: new Date(Date.now() - 600000),
      read: false,
      priority: 'high',
      actionUrl: '/arbitrage'
    },
    {
      id: '3',
      type: 'movement',
      title: 'üìà Line Movement Alert',
      message: 'Lakers spread moved from -2.5 to -4.0 - Sharp action detected',
      timestamp: new Date(Date.now() - 900000),
      read: true,
      priority: 'medium'
    },
    {
      id: '4',
      type: 'result',
      title: '‚úÖ Pick Result',
      message: 'Your pick won! Celtics -6.5 ‚úì Final: Celtics 118, Heat 105',
      timestamp: new Date(Date.now() - 1800000),
      read: true,
      priority: 'low'
    },
    {
      id: '5',
      type: 'system',
      title: 'ü§ñ Claude Effect Updated',
      message: 'New model trained on 10,000 additional games',
      timestamp: new Date(Date.now() - 3600000),
      read: true,
      priority: 'low'
    },
  ];

  const addRandomNotification = () => {
    const types: Array<Notification['type']> = ['pick', 'movement', 'arbitrage'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    const newNotifications: Record<Notification['type'], Partial<Notification>> = {
      pick: {
        title: 'üéØ New Pick Available',
        message: 'High confidence pick generated for tonight\'s games',
        priority: 'high' as const
      },
      movement: {
        title: 'üìä Line Movement',
        message: 'Significant line movement detected in NBA markets',
        priority: 'medium' as const
      },
      arbitrage: {
        title: 'üí∞ Arbitrage Alert',
        message: 'New arbitrage opportunity found!',
        priority: 'high' as const
      },
      result: {
        title: 'üìã Result',
        message: 'A recent pick has been graded',
        priority: 'low' as const
      },
      system: {
        title: '‚öôÔ∏è System Update',
        message: 'New features available',
        priority: 'low' as const
      }
    };

    const notification: Notification = {
      id: Date.now().toString(),
      type,
      ...newNotifications[type],
      title: newNotifications[type].title || 'Notification',
      message: newNotifications[type].message || '',
      timestamp: new Date(),
      read: false,
      priority: newNotifications[type].priority || 'medium'
    };

    setNotifications(prev => [notification, ...prev]);
  };

  const unreadCount = notifications.filter(n => !n.read).length;
  const filteredNotifications = filter === 'all' 
    ? notifications 
    : notifications.filter(n => !n.read);

  const markAsRead = (id: string) => {
    setNotifications(prev => 
      prev.map(n => n.id === id ? { ...n, read: true } : n)
    );
  };

  const markAllAsRead = () => {
    setNotifications(prev => prev.map(n => ({ ...n, read: true })));
  };

  const getTypeIcon = (type: Notification['type']) => {
    switch (type) {
      case 'pick': return 'üéØ';
      case 'movement': return 'üìà';
      case 'arbitrage': return 'üí∞';
      case 'result': return '‚úÖ';
      case 'system': return '‚öôÔ∏è';
      default: return 'üîî';
    }
  };

  const getTimeAgo = (date: Date) => {
    const seconds = Math.floor((new Date().getTime() - date.getTime()) / 1000);
    if (seconds < 60) return 'Just now';
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
    return `${Math.floor(seconds / 86400)}d ago`;
  };

  return (
    <div className="relative">
      {/* Bell Button */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-3 rounded-xl bg-white/10 hover:bg-white/20 transition-all"
      >
        <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
        </svg>
        {unreadCount > 0 && (
          <span className="absolute -top-1 -right-1 w-5 h-5 bg-red-500 text-white text-xs rounded-full flex items-center justify-center font-bold">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </button>

      {/* Dropdown */}
      {isOpen && (
        <>
          <div 
            className="fixed inset-0 z-40" 
            onClick={() => setIsOpen(false)}
          />
          <div className="absolute right-0 top-full mt-2 w-96 max-h-[500px] bg-slate-900 border border-white/10 rounded-2xl shadow-2xl z-50 overflow-hidden">
            {/* Header */}
            <div className="p-4 border-b border-white/10 flex items-center justify-between">
              <h3 className="font-bold text-white">Notifications</h3>
              <div className="flex items-center gap-2">
                <button
                  onClick={() => setFilter(filter === 'all' ? 'unread' : 'all')}
                  className="text-xs text-purple-400 hover:text-purple-300"
                >
                  {filter === 'all' ? 'Show Unread' : 'Show All'}
                </button>
                {unreadCount > 0 && (
                  <button
                    onClick={markAllAsRead}
                    className="text-xs text-white/40 hover:text-white/60"
                  >
                    Mark all read
                  </button>
                )}
              </div>
            </div>

            {/* Notifications List */}
            <div className="max-h-[380px] overflow-y-auto">
              {filteredNotifications.length === 0 ? (
                <div className="p-8 text-center text-white/40">
                  <div className="text-4xl mb-2">üîî</div>
                  <p>No notifications</p>
                </div>
              ) : (
                filteredNotifications.map(notification => (
                  <div
                    key={notification.id}
                    onClick={() => {
                      markAsRead(notification.id);
                      if (notification.actionUrl) {
                        window.location.href = notification.actionUrl;
                      }
                    }}
                    className={`p-4 border-b border-white/5 cursor-pointer transition-all hover:bg-white/5 ${
                      !notification.read ? 'bg-purple-500/10' : ''
                    }`}
                  >
                    <div className="flex gap-3">
                      <div className={`w-10 h-10 rounded-xl flex items-center justify-center text-xl ${
                        notification.priority === 'high' ? 'bg-red-500/20' :
                        notification.priority === 'medium' ? 'bg-yellow-500/20' :
                        'bg-white/10'
                      }`}>
                        {getTypeIcon(notification.type)}
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center justify-between">
                          <span className={`font-medium ${notification.read ? 'text-white/70' : 'text-white'}`}>
                            {notification.title}
                          </span>
                          {!notification.read && (
                            <span className="w-2 h-2 bg-purple-500 rounded-full" />
                          )}
                        </div>
                        <p className="text-sm text-white/50 truncate">{notification.message}</p>
                        <span className="text-xs text-white/30">{getTimeAgo(notification.timestamp)}</span>
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>

            {/* Footer */}
            <div className="p-3 border-t border-white/10 text-center">
              <button className="text-sm text-purple-400 hover:text-purple-300">
                View All Notifications
              </button>
            </div>
          </div>
        </>
      )}
    </div>
  );
}



=== END CONTENT ===


=== FILENAME (found alt): app/components/Gatekeeper.tsx ===
=== START CONTENT ===
/**
 * Gatekeeper Component
 * Legal consent modal with forced scroll for Alabama compliance
 * Users must scroll through full legal text before accepting
 */

'use client';

import { useState, useEffect, useRef } from 'react';
import { getConsentText, recordConsent } from '../lib/consent-manager';

interface GatekeeperProps {
  onConsent?: (consentTimestamp: string) => void;
  userId?: string;
  apiKey?: string;
}

export default function Gatekeeper({ onConsent, userId, apiKey }: GatekeeperProps) {
  const [show, setShow] = useState(false);
  const [hasScrolled, setHasScrolled] = useState(false);
  const [consentText, setConsentText] = useState('');
  const [userInput, setUserInput] = useState('');
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const requiredInput = 'I AGREE';

  useEffect(() => {
    // Check if consent already exists
    const checkConsent = () => {
      const consentCookie = document.cookie
        .split(';')
        .find(c => c.trim().startsWith('progno_consent='));

      if (consentCookie) {
        const timestamp = consentCookie.split('=')[1];
        const consentDate = new Date(timestamp);
        const daysSince = (Date.now() - consentDate.getTime()) / (1000 * 60 * 60 * 24);

        // Consent expires after 30 days
        if (daysSince < 30) {
          return; // Already consented, don't show
        }
      }

      // No valid consent, show gatekeeper
      setShow(true);
      setConsentText(getConsentText());
      // Lock body
      document.body.style.overflow = 'hidden';
      document.body.style.pointerEvents = 'none';
      document.body.setAttribute('data-gatekeeper-active', 'true');
    };

    checkConsent();
  }, []);

  const handleScroll = () => {
    if (!scrollContainerRef.current) return;

    const { scrollTop, scrollHeight, clientHeight } = scrollContainerRef.current;
    const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;

    // Require 95% scroll to enable acceptance
    if (scrollPercentage >= 0.95) {
      setHasScrolled(true);
    }
  };

  const handleAccept = async () => {
    if (userInput.trim() !== requiredInput) {
      alert(`Please type "${requiredInput}" exactly to confirm your agreement.`);
      return;
    }

    if (!hasScrolled) {
      alert('Please scroll through the entire legal text before accepting.');
      return;
    }

    try {
      const consentTimestamp = new Date().toISOString();

      // Record consent
      await recordConsent(
        userId || 'anonymous',
        consentText,
        {
          apiKey,
          ipAddress: undefined, // Will be set server-side
          userAgent: navigator.userAgent,
        }
      );

      // Set consent cookie (30 days expiry)
      const maxAge = 60 * 60 * 24 * 30; // 30 days
      const isProduction = window.location.protocol === 'https:';
      const secureFlag = isProduction ? '; secure' : '';
      document.cookie = `progno_consent=${consentTimestamp}; path=/; max-age=${maxAge}${secureFlag}; samesite=strict`;

      // Unlock body
      document.body.style.overflow = '';
      document.body.style.pointerEvents = '';
      document.body.removeAttribute('data-gatekeeper-active');

      setShow(false);
      onConsent?.(consentTimestamp);

      // Dispatch event for other components
      window.dispatchEvent(new CustomEvent('prognoConsent', {
        detail: { timestamp: consentTimestamp }
      }));
    } catch (error) {
      console.error('[Gatekeeper] Failed to record consent:', error);
      alert('Failed to record consent. Please try again.');
    }
  };

  const handleDecline = () => {
    alert('You must agree to the terms to use this service.');
    // Keep gatekeeper visible
  };

  if (!show) {
    // Ensure body is unlocked when not showing
    if (typeof document !== 'undefined') {
      document.body.style.overflow = '';
      document.body.style.pointerEvents = '';
      document.body.removeAttribute('data-gatekeeper-active');
    }
    return null;
  }

  return (
    <div
      className="fixed inset-0 z-[9999] flex items-center justify-center bg-black bg-opacity-90"
      style={{ pointerEvents: 'auto' }}
      onClick={(e) => e.stopPropagation()}
    >
      <div
        className="bg-white rounded-lg p-8 max-w-2xl mx-4 shadow-2xl max-h-[90vh] flex flex-col"
        onClick={(e) => e.stopPropagation()}
        style={{ pointerEvents: 'auto' }}
      >
        <h2 className="text-2xl font-bold mb-4 text-gray-900">
          Legal Acknowledgment Required
        </h2>

        <div className="mb-4 text-sm text-gray-600">
          <p className="font-semibold mb-2">
            Please read the following terms carefully. You must scroll through the entire text before accepting.
          </p>
          {!hasScrolled && (
            <p className="text-red-600 font-medium">
              ‚ö†Ô∏è Scroll to the bottom to enable the acceptance button.
            </p>
          )}
        </div>

        <div
          ref={scrollContainerRef}
          onScroll={handleScroll}
          className="flex-1 overflow-y-auto border-2 border-gray-300 rounded p-4 mb-4 bg-gray-50"
          style={{ maxHeight: '400px', minHeight: '300px' }}
        >
          <pre className="whitespace-pre-wrap font-mono text-xs text-gray-800 leading-relaxed">
            {consentText}
          </pre>
        </div>

        <div className="mb-4">
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Type &quot;{requiredInput}&quot; to confirm your agreement:
          </label>
          <input
            type="text"
            value={userInput}
            onChange={(e) => setUserInput(e.target.value)}
            className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none"
            placeholder={requiredInput}
            disabled={!hasScrolled}
          />
        </div>

        <div className="flex gap-4">
          <button
            onClick={handleAccept}
            disabled={!hasScrolled || userInput.trim() !== requiredInput}
            className={`flex-1 px-6 py-3 rounded-lg font-bold text-white transition-colors ${
              hasScrolled && userInput.trim() === requiredInput
                ? 'bg-green-600 hover:bg-green-700 cursor-pointer'
                : 'bg-gray-400 cursor-not-allowed'
            }`}
          >
            I Agree
          </button>
          <button
            onClick={handleDecline}
            className="px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 font-bold"
          >
            Decline
          </button>
        </div>

        <p className="text-xs text-gray-500 mt-4 text-center">
          This consent is valid for 30 days. You will be asked to renew after expiration.
        </p>
      </div>
    </div>
  );
}



=== END CONTENT ===


=== FILENAME (found alt): app/components/CevictFluxLanding.tsx ===
=== START CONTENT ===
'use client';

import React, { useState } from 'react';

/**
 * Cevict Flux v2.0 Landing Page Component
 * High-tech, sharp, and punchy design matching the Cevict brand
 */

export default function CevictFluxLanding() {
  const [activeTab, setActiveTab] = useState<'overview' | 'features' | 'api' | 'security'>('overview');

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white">
      {/* Hero Section */}
      <div className="container mx-auto px-4 py-16">
        <div className="text-center mb-16">
          <h1 className="text-6xl md:text-8xl font-bold mb-4 bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-600 bg-clip-text text-transparent">
            Cevict Flux v2.0
          </h1>
          <p className="text-2xl md:text-3xl text-slate-300 mb-6">
            The Statistical Engine for High-Conviction Sports Intelligence
          </p>
          <p className="text-lg text-slate-400 max-w-3xl mx-auto">
            Institutional-grade analytics, Monte Carlo simulation pathing, and arbitrage discovery
            for the 2025 sports landscape. Built for those who demand data integrity.
          </p>
        </div>

        {/* Navigation Tabs */}
        <div className="flex justify-center mb-12 border-b border-slate-700">
          <button
            onClick={() => setActiveTab('overview')}
            className={`px-6 py-3 font-semibold transition-colors ${
              activeTab === 'overview'
                ? 'text-cyan-400 border-b-2 border-cyan-400'
                : 'text-slate-400 hover:text-slate-200'
            }`}
          >
            Overview
          </button>
          <button
            onClick={() => setActiveTab('features')}
            className={`px-6 py-3 font-semibold transition-colors ${
              activeTab === 'features'
                ? 'text-cyan-400 border-b-2 border-cyan-400'
                : 'text-slate-400 hover:text-slate-200'
            }`}
          >
            Features
          </button>
          <button
            onClick={() => setActiveTab('api')}
            className={`px-6 py-3 font-semibold transition-colors ${
              activeTab === 'api'
                ? 'text-cyan-400 border-b-2 border-cyan-400'
                : 'text-slate-400 hover:text-slate-200'
            }`}
          >
            API
          </button>
          <button
            onClick={() => setActiveTab('security')}
            className={`px-6 py-3 font-semibold transition-colors ${
              activeTab === 'security'
                ? 'text-cyan-400 border-b-2 border-cyan-400'
                : 'text-slate-400 hover:text-slate-200'
            }`}
          >
            Security
          </button>
        </div>

        {/* Content Sections */}
        {activeTab === 'overview' && (
          <div className="max-w-4xl mx-auto space-y-8">
            <div className="bg-slate-800/50 backdrop-blur-sm rounded-lg p-8 border border-slate-700">
              <h2 className="text-3xl font-bold mb-4 text-cyan-400">Why Cevict Flux?</h2>
              <div className="grid md:grid-cols-2 gap-6">
                <div>
                  <h3 className="text-xl font-semibold mb-2 text-blue-400">üõ°Ô∏è Legal Shielding</h3>
                  <p className="text-slate-300">
                    Built-in dynamic disclaimers and consent-header requirements tailored for the 2025 Alabama regulatory environment.
                  </p>
                </div>
                <div>
                  <h3 className="text-xl font-semibold mb-2 text-purple-400">‚ö° Performance-First</h3>
                  <p className="text-slate-300">
                    Asynchronous job processing (BullMQ) ensures your UI never hangs while the engine grinds the numbers.
                  </p>
                </div>
                <div>
                  <h3 className="text-xl font-semibold mb-2 text-green-400">üìä Audit-Ready</h3>
                  <p className="text-slate-300">
                    Every prediction is logged with a unique HMAC hash, allowing for full back-testing and auditability.
                  </p>
                </div>
                <div>
                  <h3 className="text-xl font-semibold mb-2 text-yellow-400">üîê Security-First</h3>
                  <p className="text-slate-300">
                    API key scoping, tiered rate limiting, Zod input validation, and HMAC-signed performance tracking.
                  </p>
                </div>
              </div>
            </div>

            <div className="bg-slate-800/50 backdrop-blur-sm rounded-lg p-8 border border-slate-700">
              <h2 className="text-3xl font-bold mb-4 text-cyan-400">Quick Start</h2>
              <div className="bg-slate-900 rounded-lg p-6 overflow-x-auto">
                <pre className="text-sm text-slate-300">
{`import { FluxClient } from '@cevict/flux-sdk';

const flux = new FluxClient({
  apiKey: process.env.CEVICT_FLUX_KEY,
  requireConsent: true
});

const { jobId } = await flux.simulate({
  gameId: '2025-bama-vs-georgia',
  iterations: 50000,
  winProbability: 0.58
});`}
                </pre>
              </div>
            </div>
          </div>
        )}

        {activeTab === 'features' && (
          <div className="max-w-4xl mx-auto">
            <div className="grid md:grid-cols-2 gap-6">
              <div className="bg-slate-800/50 backdrop-blur-sm rounded-lg p-6 border border-slate-700">
                <h3 className="text-2xl font-bold mb-3 text-cyan-400">SimEngine</h3>
                <p className="text-slate-300 mb-4">Monte Carlo simulations with 100k+ iterations on-demand via background job queues (BullMQ)</p>
                <ul className="text-sm text-slate-400 space-y-2">
                  <li>‚Ä¢ Asynchronous processing</li>
                  <li>‚Ä¢ Progress tracking</li>
                  <li>‚Ä¢ Reproducible results (seeded)</li>
                </ul>
              </div>

              <div className="bg-slate-800/50 backdrop-blur-sm rounded-lg p-6 border border-slate-700">
                <h3 className="text-2xl font-bold mb-3 text-blue-400">ArbOptic</h3>
                <p className="text-slate-300 mb-4">Real-time cross-book discrepancy monitoring with input slop protection</p>
                <ul className="text-sm text-slate-400 space-y-2">
                  <li>‚Ä¢ Freshness timestamps</li>
                  <li>‚Ä¢ Stale data detection</li>
                  <li>‚Ä¢ Confidence scoring</li>
                </ul>
              </div>

              <div className="bg-slate-800/50 backdrop-blur-sm rounded-lg p-6 border border-slate-700">
                <h3 className="text-2xl font-bold mb-3 text-purple-400">Claude Effect</h3>
                <p className="text-slate-300 mb-4">7-dimensional AI-powered prediction enhancement</p>
                <ul className="text-sm text-slate-400 space-y-2">
                  <li>‚Ä¢ Sentiment Field</li>
                  <li>‚Ä¢ Narrative Momentum</li>
                  <li>‚Ä¢ Information Asymmetry</li>
                  <li>‚Ä¢ Chaos Sensitivity</li>
                  <li>‚Ä¢ Network Influence</li>
                  <li>‚Ä¢ Temporal Relevance Decay</li>
                  <li>‚Ä¢ Emergent Patterns</li>
                </ul>
              </div>

              <div className="bg-slate-800/50 backdrop-blur-sm rounded-lg p-6 border border-slate-700">
                <h3 className="text-2xl font-bold mb-3 text-green-400">VaultGuard</h3>
                <p className="text-slate-300 mb-4">HMAC-signed performance tracking and Zod-sanitized inputs</p>
                <ul className="text-sm text-slate-400 space-y-2">
                  <li>‚Ä¢ PII anonymization</li>
                  <li>‚Ä¢ Data integrity checks</li>
                  <li>‚Ä¢ Audit logging</li>
                </ul>
              </div>
            </div>
          </div>
        )}

        {activeTab === 'api' && (
          <div className="max-w-4xl mx-auto space-y-6">
            <div className="bg-slate-800/50 backdrop-blur-sm rounded-lg p-8 border border-slate-700">
              <h2 className="text-3xl font-bold mb-6 text-cyan-400">API Endpoints</h2>

              <div className="space-y-4">
                <div>
                  <h3 className="text-xl font-semibold mb-2 text-blue-400">Health & System</h3>
                  <code className="block bg-slate-900 rounded p-3 text-sm text-slate-300">
                    GET /api/progno/v2?action=health
                  </code>
                </div>

                <div>
                  <h3 className="text-xl font-semibold mb-2 text-purple-400">Predictions</h3>
                  <code className="block bg-slate-900 rounded p-3 text-sm text-slate-300">
                    GET /api/progno/v2?action=prediction&gameId=...
                  </code>
                </div>

                <div>
                  <h3 className="text-xl font-semibold mb-2 text-green-400">Simulations</h3>
                  <code className="block bg-slate-900 rounded p-3 text-sm text-slate-300">
                    POST /api/progno/v2?action=simulate
                  </code>
                </div>

                <div>
                  <h3 className="text-xl font-semibold mb-2 text-yellow-400">Arbitrage</h3>
                  <code className="block bg-slate-900 rounded p-3 text-sm text-slate-300">
                    GET /api/progno/v2?action=arbitrage&sport=nfl
                  </code>
                </div>
              </div>
            </div>

            <div className="bg-slate-800/50 backdrop-blur-sm rounded-lg p-8 border border-slate-700">
              <h2 className="text-3xl font-bold mb-4 text-cyan-400">Authentication</h2>
              <div className="bg-slate-900 rounded-lg p-6">
                <pre className="text-sm text-slate-300">
{`Authorization: Bearer YOUR_API_KEY
X-Progno-Consent: 2025-01-15T10:00:00Z`}
                </pre>
              </div>
            </div>
          </div>
        )}

        {activeTab === 'security' && (
          <div className="max-w-4xl mx-auto space-y-6">
            <div className="bg-slate-800/50 backdrop-blur-sm rounded-lg p-8 border border-slate-700">
              <h2 className="text-3xl font-bold mb-6 text-cyan-400">Security Features</h2>

              <div className="space-y-6">
                <div>
                  <h3 className="text-xl font-semibold mb-2 text-blue-400">API Key Scoping</h3>
                  <p className="text-slate-300">
                    12 permission scopes (predictions:read, simulations:write, etc.) for granular access control.
                  </p>
                </div>

                <div>
                  <h3 className="text-xl font-semibold mb-2 text-purple-400">Rate Limiting</h3>
                  <p className="text-slate-300 mb-2">Tiered limits based on subscription:</p>
                  <ul className="text-slate-400 space-y-1 ml-4">
                    <li>‚Ä¢ Free: 100 requests/hour</li>
                    <li>‚Ä¢ Pro: 1,000 requests/hour</li>
                    <li>‚Ä¢ Elite: 5,000 requests/hour</li>
                    <li>‚Ä¢ Enterprise: 10,000 requests/hour</li>
                  </ul>
                </div>

                <div>
                  <h3 className="text-xl font-semibold mb-2 text-green-400">Input Validation</h3>
                  <p className="text-slate-300">
                    Zod schemas prevent DoS attacks and invalid data from reaching core logic.
                  </p>
                </div>

                <div>
                  <h3 className="text-xl font-semibold mb-2 text-yellow-400">HMAC Signing</h3>
                  <p className="text-slate-300">
                    All performance data is cryptographically signed to ensure data integrity.
                  </p>
                </div>

                <div>
                  <h3 className="text-xl font-semibold mb-2 text-red-400">PII Anonymization</h3>
                  <p className="text-slate-300">
                    User IDs and betting IDs are anonymized using SHA-256 hashing to protect privacy.
                  </p>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* CTA Section */}
        <div className="mt-16 text-center">
          <div className="bg-gradient-to-r from-cyan-500/20 to-purple-500/20 rounded-lg p-8 border border-cyan-500/30">
            <h2 className="text-3xl font-bold mb-4">Ready to Get Started?</h2>
            <p className="text-slate-300 mb-6">
              Import the Postman collection or check out the full documentation
            </p>
            <div className="flex justify-center gap-4">
              <a
                href="/api/progno/v2?action=info"
                className="px-6 py-3 bg-cyan-500 hover:bg-cyan-600 rounded-lg font-semibold transition-colors"
              >
                View API Info
              </a>
              <a
                href="/cevict_flux_v2_postman.json"
                className="px-6 py-3 bg-purple-500 hover:bg-purple-600 rounded-lg font-semibold transition-colors"
              >
                Download Postman Collection
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}



=== END CONTENT ===


=== FILENAME: lib/bankroll-manager.ts ===
=== START CONTENT ===
export function calculateOptimalBetSize(data: any) { return { betSize: 10, riskLevel: 'balanced' }; }


=== END CONTENT ===


=== FILENAME (found alt): app/lib/claude-effect.ts ===
=== START CONTENT ===
/**
 * THE CLAUDE EFFECT
 * A Revolutionary Probability Framework
 *
 * Quantifies the "intangibles" - human psychology, narratives, information asymmetry,
 * chaos, team chemistry, temporal decay, and emergent patterns that traditional
 * algorithms miss.
 *
 * Formula: FINAL_PROBABILITY = BASE_PROBABILITY √ó (1 + CLAUDE_EFFECT)
 * CONFIDENCE = BASE_CONFIDENCE √ó (1 - |CSI|) √ó (1 + |IAI|)
 */

import { getWeightsForLeague } from './claude-effect-weights';

export interface ClaudeEffectScores {
  sentimentField: number;        // SF: -0.2 to +0.2
  narrativeMomentum: number;     // NM: -0.15 to +0.15
  informationAsymmetry: number;  // IAI: -0.1 to +0.1
  chaosSensitivity: number;       // CSI: 0 to 1 (higher = more chaotic)
  networkInfluence: number;       // NIG: -0.1 to +0.1
  temporalDecay: number;          // TRD: Applied as multiplier (0.5 to 1.0)
  emergentPattern: number;        // EPD: -0.1 to +0.1
}

export interface ClaudeEffectResult {
  scores: ClaudeEffectScores;
  claudeEffect: number;           // Combined weighted effect (-0.3 to +0.3)
  adjustedProbability: number;   // Base probability √ó (1 + claudeEffect)
  adjustedConfidence: number;     // Base confidence √ó (1 - |CSI|) √ó (1 + |IAI|)
  reasoning: string[];
  warnings: string[];
  recommendations: {
    betSize: 'small' | 'medium' | 'large' | 'avoid';
    reason: string;
  };
}

export interface NarrativeContext {
  type: 'revenge' | 'proving_doubters' | 'contract_year' | 'return_to_team' |
        'injured_teammate' | 'losing_streak' | 'underdog' | 'complacency' |
        'looking_ahead' | 'post_championship' | 'none';
  strength: number;  // 0 to 1
  team: 'home' | 'away' | 'both';
  description: string;
}

export interface SentimentData {
  playerInterviews: number;      // -1 to 1
  socialMedia: number;           // -1 to 1
  pressConferences: number;       // -1 to 1
  fanSentiment: number;          // -1 to 1
  beatReporterTone: number;      // -1 to 1
  timestamp: string;
}

export interface InformationAsymmetryData {
  publicBetPercentage: number;   // 0 to 1
  lineMovement: number;          // Movement in points
  lineMovementDirection: 'with_public' | 'against_public' | 'neutral';
  sharpMoneyDirection: 'home' | 'away' | 'neutral';
  reverseLineMovement: boolean;
  volume: number;                // Betting volume
}

export interface ChaosFactors {
  divisionRivalry: boolean;
  weatherImpact: number;         // 0 to 1
  shortWeek: boolean;
  newStarter: boolean;
  playoffImplications: boolean;
  trapGame: boolean;
  domeTeamOutdoors: boolean;
}

/**
 * Claude Effect Engine
 * Implements the 7-dimensional probability modifier
 */
export class ClaudeEffectEngine {
  // Base weights (fallback when getWeightsForLeague returns default)
  // NOTE: CSI and TRD are NOT in the main formula - they're applied separately
  private weights = {
    sentiment: 0.15,        // w‚ÇÅ - SF
    narrative: 0.12,        // w‚ÇÇ - NM
    information: 0.20,      // w‚ÇÉ - IAI
    network: 0.13,          // w‚ÇÖ - NIG
    emergent: 0.20,         // w‚Çá - EPD
  };

  // Sport-specific decay constants for temporal relevance
  private decayConstants = {
    nfl: 0.15,    // Weekly games, slower decay
    nba: 0.25,    // Daily games, faster decay
    mlb: 0.30,    // Daily games, very fast decay
    nhl: 0.25,
    ncaa: 0.20,
    default: 0.20,
  };

  /** League-specific weights from simulation (NHL Momentum, NFL Efficiency). Maps 7D to engine 5D; applies optional overrides. */
  private getEffectiveWeights(league?: string): { sentiment: number; narrative: number; information: number; network: number; emergent: number } {
    const W = getWeightsForLeague(league || '');
    const base = {
      sentiment: W.SF,
      narrative: W.NM,
      information: W.IAI,
      network: W.NIG,
      emergent: W.EPD,
    };
    return { ...base, ...this.weightOverrides };
  }

  /**
   * Calculate the complete Claude Effect for a game
   */
  async calculateClaudeEffect(
    baseProbability: number,
    baseConfidence: number,
    gameData: {
      homeTeam: string;
      awayTeam: string;
      league: string;
      sport: string;
      date?: string;
      venue?: string;
      weather?: { conditions?: string; windSpeed?: number };
      odds?: { home: number; away: number; spread?: number };
    },
    context?: {
      sentiment?: SentimentData;
      narratives?: NarrativeContext[];
      informationAsymmetry?: InformationAsymmetryData;
      chaosFactors?: ChaosFactors;
      chaosData?: { csiScore: number; confidencePenalty: number }; // Phase 4: CSI API result
      networkData?: { cohesion: number; leadership: number; integration: number };
      recentEvents?: Array<{ daysAgo: number; impact: number; type: string }>;
      emergentPatterns?: Array<{ score: number; description: string }>;
    }
  ): Promise<ClaudeEffectResult> {
    const scores: ClaudeEffectScores = {
      sentimentField: 0,
      narrativeMomentum: 0,
      informationAsymmetry: 0,
      chaosSensitivity: 0,
      networkInfluence: 0,
      temporalDecay: 1.0,
      emergentPattern: 0,
    };

    const reasoning: string[] = [];
    const warnings: string[] = [];

    // DIMENSION 1: Sentiment Field (SF)
    if (context?.sentiment) {
      scores.sentimentField = this.calculateSentimentField(context.sentiment);
      if (Math.abs(scores.sentimentField) > 0.05) {
        reasoning.push(
          `Sentiment: ${scores.sentimentField > 0 ? 'Positive' : 'Negative'} emotional state detected (${(scores.sentimentField * 100).toFixed(1)}%)`
        );
      }
    }

    // DIMENSION 2: Narrative Momentum (NM)
    if (context?.narratives && context.narratives.length > 0) {
      scores.narrativeMomentum = this.calculateNarrativeMomentum(context.narratives);
      if (Math.abs(scores.narrativeMomentum) > 0.03) {
        const topNarrative = context.narratives.reduce((a, b) =>
          Math.abs(a.strength) > Math.abs(b.strength) ? a : b
        );
        reasoning.push(
          `Narrative: ${this.formatNarrativeType(topNarrative.type)} affecting ${topNarrative.team} (${(scores.narrativeMomentum * 100).toFixed(1)}% impact)`
        );
      }
    }

    // DIMENSION 3: Information Asymmetry Index (IAI)
    if (context?.informationAsymmetry) {
      scores.informationAsymmetry = this.calculateInformationAsymmetry(
        context.informationAsymmetry
      );
      if (Math.abs(scores.informationAsymmetry) > 0.02) {
        reasoning.push(
          `Smart Money: ${scores.informationAsymmetry > 0 ? 'Favoring' : 'Fading'} this side (${(scores.informationAsymmetry * 100).toFixed(1)}% edge)`
        );
        if (context.informationAsymmetry.reverseLineMovement) {
          warnings.push('‚ö†Ô∏è Reverse line movement detected - sharp money disagrees with public');
        }
      }
    }

    // DIMENSION 4: Chaos Sensitivity Index (CSI)
    scores.chaosSensitivity = this.calculateChaosSensitivity(
      gameData,
      context?.chaosFactors
    );
    if (scores.chaosSensitivity > 0.35) {
      warnings.push(`üö® HIGH CHAOS (${(scores.chaosSensitivity * 100).toFixed(0)}%) - Reduce bet size or avoid`);
      reasoning.push(`Chaos Index: ${(scores.chaosSensitivity * 100).toFixed(0)}% - High volatility expected`);
    } else if (scores.chaosSensitivity > 0.25) {
      reasoning.push(`Chaos Index: ${(scores.chaosSensitivity * 100).toFixed(0)}% - Moderate volatility`);
    }

    // DIMENSION 5: Network Influence Graph (NIG)
    if (context?.networkData) {
      scores.networkInfluence = this.calculateNetworkInfluence(context.networkData);
      if (Math.abs(scores.networkInfluence) > 0.03) {
        reasoning.push(
          `Team Chemistry: ${scores.networkInfluence > 0 ? 'Strong' : 'Concerning'} cohesion (${(scores.networkInfluence * 100).toFixed(1)}%)`
        );
      }
    }

    // DIMENSION 6: Temporal Relevance Decay (TRD)
    if (context?.recentEvents && context.recentEvents.length > 0) {
      scores.temporalDecay = this.calculateTemporalDecay(
        context.recentEvents,
        gameData.sport || 'default'
      );
      if (scores.temporalDecay < 0.8) {
        reasoning.push(
          `Temporal Decay: Recent events weighted at ${(scores.temporalDecay * 100).toFixed(0)}% of original impact`
        );
      }
    }

    // DIMENSION 7: Emergent Pattern Detection (EPD)
    if (context?.emergentPatterns && context.emergentPatterns.length > 0) {
      scores.emergentPattern = this.calculateEmergentPattern(context.emergentPatterns);
      if (Math.abs(scores.emergentPattern) > 0.02) {
        reasoning.push(
          `Emergent Pattern: ${scores.emergentPattern > 0 ? 'Positive' : 'Negative'} ML-detected signal (${(scores.emergentPattern * 100).toFixed(1)}%)`
        );
      }
    }

    // Calculate combined Claude Effect (per complete guide spec)
    // Formula: CLAUDE_EFFECT = (w‚ÇÅ √ó SF) + (w‚ÇÇ √ó NM) + (w‚ÇÉ √ó IAI) + (w‚ÇÖ √ó NIG) + (w‚Çá √ó EPD)
    // NOTE: CSI and TRD are NOT in this formula - they're applied separately
    // Use league-specific weights when available (NHL: NM; NFL: IAI from simulation)
    const w = this.getEffectiveWeights(gameData.league);
    const claudeEffect =
      (w.sentiment * scores.sentimentField) +
      (w.narrative * scores.narrativeMomentum) +
      (w.information * scores.informationAsymmetry) +
      (w.network * scores.networkInfluence) +
      (w.emergent * scores.emergentPattern);

    // Clamp Claude Effect to reasonable bounds (¬±15% max impact per guide)
    const clampedEffect = Math.max(-0.15, Math.min(0.15, claudeEffect));

    // Calculate adjusted probability (per complete guide spec)
    // Formula: FINAL_PROBABILITY = BASE_PROBABILITY √ó (1 + CLAUDE_EFFECT) √ó TRD_MULTIPLIER
    const adjustedProbability = Math.max(0.01, Math.min(0.99,
      baseProbability * (1 + clampedEffect) * scores.temporalDecay
    ));

    // Calculate adjusted confidence (per complete guide spec)
    // Formula: FINAL_CONFIDENCE = BASE_CONFIDENCE √ó (1 - CSI_PENALTY) √ó (1 + |IAI|)
    // Phase 4: Use confidencePenalty from CSI API if available
    const csiPenalty = context?.chaosData?.confidencePenalty !== undefined
      ? context.chaosData.confidencePenalty
      : scores.chaosSensitivity; // CSI is 0-1, use directly as penalty

    const infoBoost = Math.abs(scores.informationAsymmetry);
    const adjustedConfidence = Math.max(0.1, Math.min(1.0,
      baseConfidence * (1 - csiPenalty) * (1 + infoBoost)
    ));

    // Generate recommendations
    const recommendations = this.generateRecommendations(
      adjustedProbability,
      adjustedConfidence,
      scores.chaosSensitivity,
      scores.informationAsymmetry,
      warnings
    );

    return {
      scores,
      claudeEffect: clampedEffect,
      adjustedProbability,
      adjustedConfidence,
      reasoning,
      warnings,
      recommendations,
    };
  }

  /**
   * DIMENSION 1: Sentiment Field (SF)
   * Analyzes emotional state from multiple sources
   *
   * Phase 1: Uses provided sentiment data
   * Phase 2: Will call Sentiment Field API for real-time analysis
   */
  private calculateSentimentField(sentiment: SentimentData): number {
    const weights = {
      playerInterviews: 0.30,
      socialMedia: 0.20,
      pressConferences: 0.25,
      fanSentiment: 0.15,
      beatReporterTone: 0.10,
    };

    const weightedSum =
      (sentiment.playerInterviews * weights.playerInterviews) +
      (sentiment.socialMedia * weights.socialMedia) +
      (sentiment.pressConferences * weights.pressConferences) +
      (sentiment.fanSentiment * weights.fanSentiment) +
      (sentiment.beatReporterTone * weights.beatReporterTone);

    // Normalize to -0.2 to +0.2 range
    return Math.max(-0.2, Math.min(0.2, weightedSum * 0.2));
  }

  /**
   * Calculate Sentiment Field from API (Phase 1 integration)
   */
  async calculateSentimentFieldFromAPI(
    teamId: string,
    teamName: string,
    gameId?: string
  ): Promise<number> {
    try {
      // Call sentiment API
      const baseUrl = process.env.NEXT_PUBLIC_PROGNO_URL || 'http://localhost:3000';
      const response = await fetch(`${baseUrl}/api/sentiment/calculate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          teamId,
          teamName,
          gameId: gameId || 'current',
          forceRefresh: false,
        }),
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.data) {
          return result.data.sentimentField || 0;
        }
      }
    } catch (error) {
      console.warn('[Claude Effect] Failed to fetch sentiment from API:', error);
    }

    // Fallback to 0 if API fails
    return 0;
  }

  /**
   * DIMENSION 2: Narrative Momentum (NM)
   * Quantifies the "story power" affecting a game
   *
   * Phase 1: Uses provided narrative context
   * Phase 2: Will call Narrative Momentum API for real-time analysis
   */
  private calculateNarrativeMomentum(narratives: NarrativeContext[]): number {
    const narrativeImpacts: Record<string, number> = {
      revenge: 0.08,
      proving_doubters: 0.05,
      contract_year: 0.04,
      return_to_team: 0.06,
      injured_teammate: 0.07,
      losing_streak: 0.03,
      underdog: 0.05,
      complacency: -0.04,
      looking_ahead: -0.06,
      post_championship: -0.08,
      none: 0.0,
    };

    let totalMomentum = 0;
    for (const narrative of narratives) {
      const baseImpact = narrativeImpacts[narrative.type] || 0;
      const adjustedImpact = baseImpact * narrative.strength;

      // Apply team direction (home = positive, away = negative, both = neutral)
      if (narrative.team === 'away') {
        totalMomentum -= adjustedImpact;
      } else if (narrative.team === 'home') {
        totalMomentum += adjustedImpact;
      }
      // 'both' doesn't change momentum (neutral)
    }

    // Normalize to -0.15 to +0.15 range
    return Math.max(-0.15, Math.min(0.15, totalMomentum));
  }

  /**
   * Calculate Narrative Momentum from API (Phase 2 integration)
   */
  async calculateNarrativeMomentumFromAPI(
    teamId: string,
    opponentId: string,
    gameId: string,
    context?: any
  ): Promise<number> {
    try {
      // Call narrative API
      const baseUrl = process.env.NEXT_PUBLIC_PROGNO_URL || 'http://localhost:3000';
      const response = await fetch(`${baseUrl}/api/narrative/calculate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          teamId,
          opponentId,
          gameId,
          context,
        }),
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.data) {
          return result.data.momentumScore || 0;
        }
      }
    } catch (error) {
      console.warn('[Claude Effect] Failed to fetch narrative momentum from API:', error);
    }

    // Fallback to 0 if API fails
    return 0;
  }

  /**
   * DIMENSION 3: Information Asymmetry Index (IAI)
   * Detects what sharp money knows
   *
   * Phase 1: Uses provided information asymmetry data
   * Phase 3: Will call IAI API for real-time analysis
   */
  private calculateInformationAsymmetry(data: InformationAsymmetryData): number {
    // Reverse Line Movement is the strongest signal
    if (data.reverseLineMovement) {
      const rlmScore = Math.abs(data.publicBetPercentage - 0.5) * Math.abs(data.lineMovement);
      const direction = data.lineMovementDirection === 'against_public' ? 1 : -1;
      return Math.max(-0.1, Math.min(0.1, rlmScore * direction * 0.1));
    }

    // Regular line movement with sharp money direction
    if (data.sharpMoneyDirection !== 'neutral' && Math.abs(data.lineMovement) > 0.5) {
      const direction = data.sharpMoneyDirection === 'home' ? 1 : -1;
      return Math.max(-0.1, Math.min(0.1, Math.abs(data.lineMovement) * direction * 0.05));
    }

    return 0;
  }

  /**
   * Calculate Information Asymmetry from API (Phase 3 integration)
   */
  async calculateInformationAsymmetryFromAPI(
    gameId: string,
    context: {
      openingLine: number;
      currentLine: number;
      isHomeFavorite: boolean;
      sport?: string;
      publicTicketPct: number;
      bettingSplits?: any[];
      recentMovements?: any[];
    }
  ): Promise<number> {
    try {
      // Call IAI API
      const baseUrl = process.env.NEXT_PUBLIC_PROGNO_URL || 'http://localhost:3000';
      const response = await fetch(`${baseUrl}/api/iai/calculate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          gameId,
          context,
        }),
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.data) {
          return result.data.iaiScore || 0;
        }
      }
    } catch (error) {
      console.warn('[Claude Effect] Failed to fetch IAI from API:', error);
    }

    // Fallback to 0 if API fails
    return 0;
  }

  /**
   * DIMENSION 4: Chaos Sensitivity Index (CSI)
   * Measures game volatility
   *
   * Phase 1: Uses provided chaos factors
   * Phase 4: Will call CSI API for comprehensive analysis
   */
  private calculateChaosSensitivity(
    gameData: any,
    factors?: ChaosFactors
  ): number {
    let baseVolatility = 0.15; // Base chaos for any game

    if (!factors) {
      // Estimate from available data
      if (gameData.weather?.conditions &&
          ['rain', 'snow', 'wind'].some(w => gameData.weather.conditions?.toLowerCase().includes(w))) {
        baseVolatility += 0.20;
      }
      if (gameData.league?.toLowerCase().includes('division')) {
        baseVolatility += 0.15;
      }
      return Math.min(1.0, baseVolatility);
    }

    // Division rivalry
    if (factors.divisionRivalry) baseVolatility += 0.15;

    // Weather impact
    if (factors.weatherImpact > 0) {
      baseVolatility += factors.weatherImpact * 0.20;
    }

    // Short week (Thursday games, etc.)
    if (factors.shortWeek) baseVolatility += 0.10;

    // New starter (backup QB, new coach, etc.)
    if (factors.newStarter) baseVolatility += 0.25;

    // Playoff implications
    if (factors.playoffImplications) baseVolatility += 0.12;

    // Trap game
    if (factors.trapGame) baseVolatility += 0.18;

    // Dome team playing outdoors
    if (factors.domeTeamOutdoors) baseVolatility += 0.15;

    return Math.min(1.0, baseVolatility);
  }

  /**
   * Calculate Chaos Sensitivity from API (Phase 4 integration)
   */
  async calculateChaosSensitivityFromAPI(
    gameId: string,
    context: {
      sport: string;
      weather?: any;
      schedule?: any;
      roster?: any;
      context?: any;
      rivalry?: any;
      external?: any;
    }
  ): Promise<{ csiScore: number; confidencePenalty: number }> {
    try {
      // Call CSI API
      const baseUrl = process.env.NEXT_PUBLIC_PROGNO_URL || 'http://localhost:3000';
      const response = await fetch(`${baseUrl}/api/csi/calculate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          gameId,
          context,
        }),
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.data) {
          return {
            csiScore: result.data.csiScore || 0,
            confidencePenalty: result.data.confidencePenalty || 0,
          };
        }
      }
    } catch (error) {
      console.warn('[Claude Effect] Failed to fetch CSI from API:', error);
    }

    // Fallback
    return { csiScore: 0.15, confidencePenalty: 0 };
  }

  /**
   * DIMENSION 5: Network Influence Graph (NIG)
   * Measures team chemistry and relationships
   *
   * Phase 1: Uses provided network data
   * Phase 5: Will call NIG API for comprehensive graph analysis
   */
  private calculateNetworkInfluence(data: {
    cohesion: number;      // 0 to 1
    leadership: number;   // 0 to 1
    integration: number;   // 0 to 1
  }): number {
    const nig = (data.cohesion * 0.4) + (data.leadership * 0.4) + (data.integration * 0.2);

    // Convert from 0-1 scale to -0.1 to +0.1 (centered at 0.5)
    return (nig - 0.5) * 0.2;
  }

  /**
   * Calculate Network Influence from API (Phase 5 integration)
   */
  async calculateNetworkInfluenceFromAPI(
    teamId: string,
    gameId: string,
    players: any[],
    relationships: any[]
  ): Promise<number> {
    try {
      // Call NIG API
      const baseUrl = process.env.NEXT_PUBLIC_PROGNO_URL || 'http://localhost:3000';
      const response = await fetch(`${baseUrl}/api/nig/calculate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          teamId,
          gameId,
          players,
          relationships,
        }),
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.data) {
          return result.data.networkInfluence || 0;
        }
      }
    } catch (error) {
      console.warn('[Claude Effect] Failed to fetch NIG from API:', error);
    }

    // Fallback to 0 if API fails
    return 0;
  }

  /**
   * DIMENSION 6: Temporal Relevance Decay (TRD)
   * Applies recency weighting to events
   *
   * Phase 1: Uses provided events
   * Phase 6: Will call Temporal Decay API for comprehensive analysis
   */
  private calculateTemporalDecay(
    events: Array<{ daysAgo: number; impact: number; type: string }>,
    sport: string
  ): number {
    const lambda = this.decayConstants[sport as keyof typeof this.decayConstants] ||
                   this.decayConstants.default;

    let totalDecayedImpact = 0;
    let totalOriginalImpact = 0;

    for (const event of events) {
      const decayFactor = Math.exp(-lambda * event.daysAgo);
      const decayedImpact = event.impact * decayFactor;
      totalDecayedImpact += decayedImpact;
      totalOriginalImpact += event.impact;
    }

    if (totalOriginalImpact === 0) return 1.0;

    // Return the ratio of decayed to original (0.5 to 1.0)
    const ratio = totalDecayedImpact / totalOriginalImpact;
    return Math.max(0.5, Math.min(1.0, ratio));
  }

  /**
   * Calculate Temporal Decay from API (Phase 6 integration)
   */
  async calculateTemporalDecayFromAPI(
    events: Array<{ daysAgo: number; impact: number; type: string; description?: string }>,
    sport: string
  ): Promise<number> {
    try {
      // Call Temporal API
      const baseUrl = process.env.NEXT_PUBLIC_PROGNO_URL || 'http://localhost:3000';
      const response = await fetch(`${baseUrl}/api/temporal/decay`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          events,
          sport,
        }),
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.data) {
          return result.data.decayFactor || 1.0;
        }
      }
    } catch (error) {
      console.warn('[Claude Effect] Failed to fetch temporal decay from API:', error);
    }

    // Fallback
    return 1.0;
  }

  /**
   * DIMENSION 7: Emergent Pattern Detection (EPD)
   * ML-discovered patterns
   *
   * Phase 1: Uses provided patterns
   * Phase 7: Will call Emergent Pattern API for ML-based detection
   */
  private calculateEmergentPattern(
    patterns: Array<{ score: number; description: string }>
  ): number {
    if (patterns.length === 0) return 0;

    // Average the pattern scores
    const avgScore = patterns.reduce((sum, p) => sum + p.score, 0) / patterns.length;

    // Normalize to -0.1 to +0.1
    return Math.max(-0.1, Math.min(0.1, avgScore));
  }

  /**
   * Calculate Emergent Pattern from API (Phase 7 integration)
   */
  async calculateEmergentPatternFromAPI(
    context: {
      teamId: string;
      opponentId: string;
      gameData: any;
    }
  ): Promise<number> {
    try {
      // Call Emergent Pattern API
      const baseUrl = process.env.NEXT_PUBLIC_PROGNO_URL || 'http://localhost:3000';
      const response = await fetch(`${baseUrl}/api/emergent/detect`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          context,
        }),
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.data) {
          return result.data.combinedScore || 0;
        }
      }
    } catch (error) {
      console.warn('[Claude Effect] Failed to fetch emergent patterns from API:', error);
    }

    // Fallback to 0 if API fails
    return 0;
  }

  /**
   * Generate betting recommendations based on Claude Effect
   */
  private generateRecommendations(
    probability: number,
    confidence: number,
    chaos: number,
    infoAsymmetry: number,
    warnings: string[]
  ): { betSize: 'small' | 'medium' | 'large' | 'avoid'; reason: string } {
    // High chaos = avoid or small bet
    if (chaos > 0.5) {
      return {
        betSize: 'avoid',
        reason: `Extremely high chaos (${(chaos * 100).toFixed(0)}%) - too unpredictable`,
      };
    }

    if (chaos > 0.35) {
      return {
        betSize: 'small',
        reason: `High chaos (${(chaos * 100).toFixed(0)}%) - reduce bet size`,
      };
    }

    // Low confidence = small bet
    if (confidence < 0.6) {
      return {
        betSize: 'small',
        reason: `Low confidence (${(confidence * 100).toFixed(0)}%) - small bet only`,
      };
    }

    // Strong sharp money signal = medium to large
    if (Math.abs(infoAsymmetry) > 0.05 && confidence > 0.7) {
      return {
        betSize: 'large',
        reason: `Sharp money signal + high confidence (${(confidence * 100).toFixed(0)}%)`,
      };
    }

    // High confidence, low chaos = medium to large
    if (confidence > 0.75 && chaos < 0.25) {
      return {
        betSize: 'large',
        reason: `High confidence (${(confidence * 100).toFixed(0)}%) with low chaos`,
      };
    }

    // Default medium
    return {
      betSize: 'medium',
      reason: `Standard bet size - confidence: ${(confidence * 100).toFixed(0)}%, chaos: ${(chaos * 100).toFixed(0)}%`,
    };
  }

  /**
   * Format narrative type for display
   */
  private formatNarrativeType(type: string): string {
    const formats: Record<string, string> = {
      revenge: 'Revenge Game',
      proving_doubters: 'Proving Doubters Wrong',
      contract_year: 'Contract Year',
      return_to_team: 'Return to Former Team',
      injured_teammate: 'Playing for Injured Teammate',
      losing_streak: 'Losing Streak Desperation',
      underdog: 'Nobody Believes in Us',
      complacency: 'Complacency (Heavy Favorite)',
      looking_ahead: 'Looking Ahead',
      post_championship: 'Post-Championship Hangover',
      none: 'No Narrative',
    };
    return formats[type] || type;
  }

  /**
   * Update weights based on backtesting results
   */
  updateWeights(newWeights: Partial<{ sentiment: number; narrative: number; information: number; network: number; emergent: number }>): void {
    this.weightOverrides = { ...this.weightOverrides, ...newWeights };
  }

  /**
   * Get current effective weights (default league + overrides; for fine-tuning UI)
   */
  getWeights(): { sentiment: number; narrative: number; information: number; network: number; emergent: number } {
    return this.getEffectiveWeights('');
  }
}



=== END CONTENT ===


=== FILENAME (found alt): app/lib/odds-helpers.ts ===
=== START CONTENT ===
/**
 * Odds Helper Functions
 * Shared utilities for odds processing and estimation
 */

// Convert American odds to decimal
export function americanToDecimal(americanOdds: number): number {
  if (americanOdds > 0) {
    return (americanOdds / 100) + 1;
  } else {
    return (100 / Math.abs(americanOdds)) + 1;
  }
}

// Convert American odds to implied probability
export function americanToImpliedProb(odds: number): number {
  if (odds > 0) {
    return 100 / (odds + 100);
  } else {
    return Math.abs(odds) / (Math.abs(odds) + 100);
  }
}

// Extract and average odds across all bookmakers
export function extractAveragedOdds(gameData: any): { home: number; away: number; spread?: number; total?: number } {
  const teamName = gameData.home_team;
  const awayTeamName = gameData.away_team;

  if (!gameData.bookmakers || gameData.bookmakers.length === 0) {
    return { home: -110, away: 110 }; // Default odds
  }

  const homeOdds: number[] = [];
  const awayOdds: number[] = [];
  const spreads: number[] = [];
  const totals: number[] = [];

  // Collect odds from all bookmakers
  for (const bookmaker of gameData.bookmakers) {
    if (!bookmaker.markets) continue;

    // Moneyline odds
    const h2hMarket = bookmaker.markets.find((m: any) => m.key === 'h2h');
    if (h2hMarket && h2hMarket.outcomes) {
      const homeOutcome = h2hMarket.outcomes.find((o: any) => o.name === teamName);
      const awayOutcome = h2hMarket.outcomes.find((o: any) => o.name === awayTeamName);
      if (homeOutcome?.price) homeOdds.push(homeOutcome.price);
      if (awayOutcome?.price) awayOdds.push(awayOutcome.price);
    }

    // Spread
    const spreadsMarket = bookmaker.markets.find((m: any) => m.key === 'spreads');
    if (spreadsMarket && spreadsMarket.outcomes) {
      const homeOutcome = spreadsMarket.outcomes.find((o: any) => o.name === teamName);
      if (homeOutcome?.point !== undefined) spreads.push(homeOutcome.point);
    }

    // Total
    const totalsMarket = bookmaker.markets.find((m: any) => m.key === 'totals');
    if (totalsMarket && totalsMarket.outcomes) {
      const overOutcome = totalsMarket.outcomes.find((o: any) => o.name === 'Over');
      if (overOutcome?.point !== undefined) totals.push(overOutcome.point);
    }
  }

  // Calculate averages
  const avgHome = homeOdds.length > 0 ? homeOdds.reduce((a, b) => a + b, 0) / homeOdds.length : -110;
  const avgAway = awayOdds.length > 0 ? awayOdds.reduce((a, b) => a + b, 0) / awayOdds.length : 110;
  const avgSpread = spreads.length > 0 ? spreads.reduce((a, b) => a + b, 0) / spreads.length : undefined;
  const avgTotal = totals.length > 0 ? totals.reduce((a, b) => a + b, 0) / totals.length : undefined;

  return {
    home: Math.round(avgHome),
    away: Math.round(avgAway),
    spread: avgSpread !== undefined ? Math.round(avgSpread * 10) / 10 : undefined,
    total: avgTotal !== undefined ? Math.round(avgTotal * 10) / 10 : undefined,
  };
}

// Estimate team stats from odds (more accurate than zeros)
export function estimateTeamStatsFromOdds(odds: { home: number; away: number; spread?: number; total?: number }, sport: string): {
  home: any;
  away: any;
} {
  // Convert American odds to implied probabilities
  const homeProb = americanToImpliedProb(odds.home);
  const awayProb = americanToImpliedProb(odds.away);

  // Estimate win percentages from odds
  const homeWinPct = homeProb / (homeProb + awayProb);
  const awayWinPct = 1 - homeWinPct;

  // Estimate season record (assuming ~16 game season for NFL, adjust for other sports)
  const gamesPerSeason = sport.includes('nfl') ? 17 : sport.includes('nba') ? 82 : sport.includes('mlb') ? 162 : 82;
  const homeWins = Math.round(homeWinPct * gamesPerSeason * 0.5); // Rough estimate
  const homeLosses = gamesPerSeason - homeWins;
  const awayWins = Math.round(awayWinPct * gamesPerSeason * 0.5);
  const awayLosses = gamesPerSeason - awayWins;

  // Estimate points from spread and total
  const spread = odds.spread || 0;
  const total = odds.total || (sport.includes('nfl') ? 45 : sport.includes('nba') ? 220 : 9);

  // Home team expected points = (total + spread) / 2
  const homeExpectedPoints = (total + spread) / 2;
  const awayExpectedPoints = (total - spread) / 2;

  // Estimate points for/against based on expected points and win percentage
  const homePointsFor = homeExpectedPoints * gamesPerSeason;
  const homePointsAgainst = awayExpectedPoints * gamesPerSeason;
  const awayPointsFor = awayExpectedPoints * gamesPerSeason;
  const awayPointsAgainst = homeExpectedPoints * gamesPerSeason;

  return {
    home: {
      wins: homeWins,
      losses: homeLosses,
      pointsFor: homePointsFor,
      pointsAgainst: homePointsAgainst,
      recentAvgPoints: homeExpectedPoints,
      recentAvgAllowed: awayExpectedPoints,
    },
    away: {
      wins: awayWins,
      losses: awayLosses,
      pointsFor: awayPointsFor,
      pointsAgainst: awayPointsAgainst,
      recentAvgPoints: awayExpectedPoints,
      recentAvgAllowed: homeExpectedPoints,
    },
  };
}

// Estimate recent form from odds (favorite = better form)
export function estimateRecentForm(odds: { home: number; away: number }): { home: string[]; away: string[] } {
  const homeProb = americanToImpliedProb(odds.home);
  const awayProb = americanToImpliedProb(odds.away);

  // If home team is favorite, they likely have better recent form
  const homeForm: string[] = [];
  const awayForm: string[] = [];

  // Generate 5-game form based on win probability
  for (let i = 0; i < 5; i++) {
    homeForm.push(Math.random() < homeProb ? 'W' : 'L');
    awayForm.push(Math.random() < awayProb ? 'W' : 'L');
  }

  return { home: homeForm, away: awayForm };
}



=== END CONTENT ===


=== FILENAME (found alt): app/lib/prediction-engine.ts ===
=== START CONTENT ===
/**
 * Advanced Prediction Engine
 * The best prediction engine this side of Vegas
 * Uses multiple calculation methods and learns from results
 */

import { savePrediction, recordOutcome, getWinPercentage } from './progno-db';

export interface GameData {
  homeTeam: string;
  awayTeam: string;
  league: string;
  sport: string;
  odds: {
    home: number;
    away: number;
    spread?: number;
    total?: number;
  };
  date?: string;
  venue?: string;
  weather?: {
    temperature?: number;
    conditions?: string;
    windSpeed?: number;
  };
  injuries?: {
    homeImpact?: number;
    awayImpact?: number;
  };
  teamStats?: {
    home: TeamStats;
    away: TeamStats;
  };
  recentForm?: {
    home: string[]; // ['W', 'L', 'W', ...]
    away: string[];
  };
  headToHead?: {
    homeWins: number;
    awayWins: number;
    draws?: number;
  };
}

export interface TeamStats {
  wins: number;
  losses: number;
  pointsFor: number;
  pointsAgainst: number;
  homeRecord?: { wins: number; losses: number };
  awayRecord?: { wins: number; losses: number };
  recentAvgPoints: number;
  recentAvgAllowed: number;
  strengthOfSchedule?: number;
  offensiveRating?: number;
  defensiveRating?: number;
}

export interface PredictionResult {
  predictedWinner: string;
  confidence: number; // 0-100
  edge: number; // Expected value percentage
  predictedScore?: {
    home: number;
    away: number;
  };
  methods: {
    name: string;
    confidence: number;
    weight: number;
  }[];
  reasoning: string[];
  riskFactors: string[];
  recommendedBet?: {
    type: 'moneyline' | 'spread' | 'total';
    side: string;
    value: number;
    confidence: number;
  };
}

export interface LearningData {
  method: string;
  confidence: number;
  actualOutcome: 'correct' | 'incorrect' | 'partial';
  accuracy: number;
  timestamp: string;
}

/**
 * Advanced Prediction Engine Class
 */
export class PredictionEngine {
  private learningWeights: Map<string, number> = new Map();
  private methodPerformance: Map<string, { correct: number; total: number; avgAccuracy: number }> = new Map();
  private weeklyLearningData: LearningData[] = [];

  constructor() {
    this.initializeWeights();
    this.loadHistoricalPerformance();
  }

  /**
   * Initialize default weights for prediction methods
   */
  private initializeWeights() {
    const defaultMethods = [
      'statistical-model',
      'elo-rating',
      'recent-form',
      'head-to-head',
      'market-efficiency',
      'weather-impact',
      'injury-impact',
      'home-advantage',
      'momentum',
      'machine-learning'
    ];

    defaultMethods.forEach(method => {
      this.learningWeights.set(method, 1.0);
      this.methodPerformance.set(method, { correct: 0, total: 0, avgAccuracy: 0 });
    });

    // Add new advanced methods
    const advancedMethods = [
      'poisson-distribution',
      'regression-model',
      'bayesian-update',
      'monte-carlo'
    ];

    advancedMethods.forEach(method => {
      this.learningWeights.set(method, 1.0);
      this.methodPerformance.set(method, { correct: 0, total: 0, avgAccuracy: 0 });
    });
  }

  /**
   * Set custom weights for prediction methods (for elite fine-tuning)
   * Returns a function to restore original weights
   */
  setCustomWeights(weights: Record<string, number>): () => void {
    const originalWeights = new Map(this.learningWeights);

    // Apply custom weights
    Object.entries(weights).forEach(([method, weight]) => {
      this.learningWeights.set(method, weight);
    });

    // Return restore function
    return () => {
      this.learningWeights = originalWeights;
    };
  }

  /**
   * Load historical performance from database
   */
  private async loadHistoricalPerformance() {
    try {
      // Load win percentages by method from database
      const stats = await getWinPercentage({ type: 'sports' });

      if (stats) {
        // Adjust weights based on historical performance
        const baseWeight = 1.0;
        const performanceMultiplier = stats.win_percentage / 50; // Normalize to 50% baseline

        this.learningWeights.forEach((weight, method) => {
          this.learningWeights.set(method, baseWeight * performanceMultiplier);
        });
      }
    } catch (error) {
      console.warn('[PredictionEngine] Could not load historical performance:', error);
    }
  }

  /**
   * Main prediction method - combines all calculation methods
   * @param gameData - Game data for prediction
   * @param forceMoneyline - If true, always recommend moneyline (for Kalshi games)
   */
  async predict(gameData: GameData, forceMoneyline: boolean = false): Promise<PredictionResult> {
    const methods: { name: string; confidence: number; weight: number }[] = [];
    const reasoning: string[] = [];
    const riskFactors: string[] = [];

    // 1. Statistical Model (Pythagorean Expectation + Advanced Metrics)
    const statisticalPred = this.statisticalModel(gameData);
    methods.push({
      name: 'statistical-model',
      confidence: statisticalPred.confidence,
      weight: this.learningWeights.get('statistical-model') || 1.0
    });
    reasoning.push(statisticalPred.reasoning);

    // 2. Enhanced ELO Rating System (tracks team strength over time)
    const eloPred = this.eloRatingEnhanced(gameData);
    methods.push({
      name: 'elo-rating',
      confidence: eloPred.confidence,
      weight: this.learningWeights.get('elo-rating') || 1.0
    });
    reasoning.push(eloPred.reasoning);

    // 3. Recent Form Analysis
    const formPred = this.recentFormAnalysis(gameData);
    methods.push({
      name: 'recent-form',
      confidence: formPred.confidence,
      weight: this.learningWeights.get('recent-form') || 1.0
    });
    reasoning.push(formPred.reasoning);

    // 4. Head-to-Head History
    const h2hPred = this.headToHeadAnalysis(gameData);
    if (h2hPred) {
      methods.push({
        name: 'head-to-head',
        confidence: h2hPred.confidence,
        weight: this.learningWeights.get('head-to-head') || 0.8
      });
      reasoning.push(h2hPred.reasoning);
    }

    // 5. Market Efficiency Analysis
    const marketPred = this.marketEfficiencyAnalysis(gameData);
    methods.push({
      name: 'market-efficiency',
      confidence: marketPred.confidence,
      weight: this.learningWeights.get('market-efficiency') || 1.2
    });
    reasoning.push(marketPred.reasoning);
    if (marketPred.edge > 0) {
      reasoning.push(`Market edge detected: ${marketPred.edge.toFixed(2)}%`);
    }

    // 6. Weather Impact
    if (gameData.weather) {
      const weatherPred = this.weatherImpactAnalysis(gameData);
      methods.push({
        name: 'weather-impact',
        confidence: weatherPred.confidence,
        weight: this.learningWeights.get('weather-impact') || 0.6
      });
      reasoning.push(weatherPred.reasoning);
      if (weatherPred.risk) {
        riskFactors.push(weatherPred.risk);
      }
    }

    // 7. Injury Impact
    if (gameData.injuries) {
      const injuryPred = this.injuryImpactAnalysis(gameData);
      methods.push({
        name: 'injury-impact',
        confidence: injuryPred.confidence,
        weight: this.learningWeights.get('injury-impact') || 0.8
      });
      reasoning.push(injuryPred.reasoning);
      if (injuryPred.risk) {
        riskFactors.push(injuryPred.risk);
      }
    }

    // 8. Home Advantage
    const homeAdvPred = this.homeAdvantageAnalysis(gameData);
    methods.push({
      name: 'home-advantage',
      confidence: homeAdvPred.confidence,
      weight: this.learningWeights.get('home-advantage') || 0.7
    });
    reasoning.push(homeAdvPred.reasoning);

    // 9. Momentum Analysis
    const momentumPred = this.momentumAnalysis(gameData);
    methods.push({
      name: 'momentum',
      confidence: momentumPred.confidence,
      weight: this.learningWeights.get('momentum') || 0.9
    });
    reasoning.push(momentumPred.reasoning);

    // 10. Machine Learning Model (if we have historical data)
    const mlPred = await this.machineLearningPrediction(gameData);
    if (mlPred) {
      methods.push({
        name: 'machine-learning',
        confidence: mlPred.confidence,
        weight: this.learningWeights.get('machine-learning') || 1.5
      });
      reasoning.push(mlPred.reasoning);
    }

    // 11. Poisson Distribution for Total Score Predictions
    if (gameData.odds.total) {
      const poissonPred = this.poissonDistribution(gameData);
      methods.push({
        name: 'poisson-distribution',
        confidence: poissonPred.confidence,
        weight: this.learningWeights.get('poisson-distribution') || 1.0
      });
      reasoning.push(poissonPred.reasoning);
    }

    // 12. Regression Model for Historical Trends
    const regressionPred = await this.regressionModel(gameData);
    if (regressionPred) {
      methods.push({
        name: 'regression-model',
        confidence: regressionPred.confidence,
        weight: this.learningWeights.get('regression-model') || 1.2
      });
      reasoning.push(regressionPred.reasoning);
    }

    // 13. Bayesian Update from Past Predictions
    const bayesianPred = await this.bayesianUpdate(gameData);
    if (bayesianPred) {
      methods.push({
        name: 'bayesian-update',
        confidence: bayesianPred.confidence,
        weight: this.learningWeights.get('bayesian-update') || 1.3
      });
      reasoning.push(bayesianPred.reasoning);
    }

    // Combine all methods using weighted average
    const combinedResult = this.combineMethods(methods, gameData);

    // Calculate expected value and edge
    const edge = this.calculateEdge(gameData, combinedResult);

    // Generate recommended bet (force moneyline for Kalshi games)
    const recommendedBet = this.generateBetRecommendation(gameData, combinedResult, edge, forceMoneyline);

    return {
      predictedWinner: combinedResult.winner,
      confidence: Math.round(combinedResult.confidence * 100) / 100,
      edge: Math.round(edge * 100) / 100,
      predictedScore: combinedResult.score,
      methods,
      reasoning: reasoning.filter(r => r),
      riskFactors,
      recommendedBet
    };
  }

  /**
   * Statistical Model - Pythagorean Expectation + Advanced Metrics
   */
  private statisticalModel(gameData: GameData): { confidence: number; reasoning: string; winner: string } {
    if (!gameData.teamStats) {
      return { confidence: 0.5, reasoning: 'Insufficient statistical data', winner: gameData.homeTeam };
    }

    const { home, away } = gameData.teamStats;

    // Pythagorean Expectation
    const homePythagorean = Math.pow(home.pointsFor, 2.37) /
      (Math.pow(home.pointsFor, 2.37) + Math.pow(home.pointsAgainst, 2.37));
    const awayPythagorean = Math.pow(away.pointsFor, 2.37) /
      (Math.pow(away.pointsFor, 2.37) + Math.pow(away.pointsAgainst, 2.37));

    // Win Percentage
    const homeWinPct = home.wins / (home.wins + home.losses);
    const awayWinPct = away.wins / (away.wins + away.losses);

    // Strength of Schedule adjustment
    const homeSOS = home.strengthOfSchedule || 0.5;
    const awaySOS = away.strengthOfSchedule || 0.5;
    const homeAdjusted = homePythagorean * (1 + (homeSOS - 0.5) * 0.1);
    const awayAdjusted = awayPythagorean * (1 + (awaySOS - 0.5) * 0.1);

    // Combined metric
    const homeStrength = (homeAdjusted * 0.6) + (homeWinPct * 0.4);
    const awayStrength = (awayAdjusted * 0.6) + (awayWinPct * 0.4);

    const homeWinProb = homeStrength / (homeStrength + awayStrength);
    const confidence = Math.abs(homeWinProb - 0.5) * 2; // Convert to 0-1 scale
    const winner = homeWinProb > 0.5 ? gameData.homeTeam : gameData.awayTeam;

    const reasoning = `Statistical model: ${winner} favored ${(Math.max(homeWinProb, 1 - homeWinProb) * 100).toFixed(1)}% based on Pythagorean expectation and win percentage`;

    return { confidence, reasoning, winner };
  }


  /**
   * Recent Form Analysis
   */
  private recentFormAnalysis(gameData: GameData): { confidence: number; reasoning: string; winner: string } {
    if (!gameData.recentForm || !gameData.recentForm.home || !gameData.recentForm.away) {
      return { confidence: 0.5, reasoning: 'Insufficient recent form data', winner: gameData.homeTeam };
    }

    const homeForm = gameData.recentForm.home;
    const awayForm = gameData.recentForm.away;

    // Calculate form score (W = 1, L = 0, D = 0.5)
    const homeFormScore = homeForm.reduce((sum, result) => {
      if (result === 'W') return sum + 1;
      if (result === 'D') return sum + 0.5;
      return sum;
    }, 0) / homeForm.length;

    const awayFormScore = awayForm.reduce((sum, result) => {
      if (result === 'W') return sum + 1;
      if (result === 'D') return sum + 0.5;
      return sum;
    }, 0) / awayForm.length;

    // Weight recent games more heavily
    const homeRecentWeight = homeForm.slice(0, 3).reduce((sum, result) => {
      if (result === 'W') return sum + 1;
      if (result === 'D') return sum + 0.5;
      return sum;
    }, 0) / 3;

    const awayRecentWeight = awayForm.slice(0, 3).reduce((sum, result) => {
      if (result === 'W') return sum + 1;
      if (result === 'D') return sum + 0.5;
      return sum;
    }, 0) / 3;

    const homeCombined = (homeFormScore * 0.6) + (homeRecentWeight * 0.4);
    const awayCombined = (awayFormScore * 0.6) + (awayRecentWeight * 0.4);

    const homeWinProb = homeCombined / (homeCombined + awayCombined);
    const confidence = Math.abs(homeWinProb - 0.5) * 2;
    const winner = homeWinProb > 0.5 ? gameData.homeTeam : gameData.awayTeam;

    const reasoning = `Recent form: ${winner} has better recent form (${(homeCombined * 100).toFixed(0)}% vs ${(awayCombined * 100).toFixed(0)}%)`;

    return { confidence, reasoning, winner };
  }

  /**
   * Head-to-Head Analysis
   */
  private headToHeadAnalysis(gameData: GameData): { confidence: number; reasoning: string; winner: string } | null {
    if (!gameData.headToHead) {
      return null;
    }

    const { homeWins, awayWins, draws } = gameData.headToHead;
    const total = homeWins + awayWins + (draws || 0);

    if (total === 0) {
      return null;
    }

    const homeH2HProb = (homeWins + (draws || 0) * 0.5) / total;
    const confidence = Math.min(Math.abs(homeH2HProb - 0.5) * 2, 0.8); // Cap at 0.8
    const winner = homeH2HProb > 0.5 ? gameData.homeTeam : gameData.awayTeam;

    const reasoning = `Head-to-head: ${winner} leads series ${homeWins}-${awayWins}${draws ? `-${draws}` : ''}`;

    return { confidence, reasoning, winner };
  }

  /**
   * Market Efficiency Analysis - Find value in odds
   */
  private marketEfficiencyAnalysis(gameData: GameData): {
    confidence: number;
    reasoning: string;
    winner: string;
    edge: number;
  } {
    const { odds } = gameData;

    // Convert American odds to implied probability
    const homeImpliedProb = this.americanToImplied(odds.home);
    const awayImpliedProb = this.americanToImplied(odds.away);

    // Calculate market efficiency (should sum to ~1.0)
    const marketEfficiency = homeImpliedProb + awayImpliedProb;
    const vig = marketEfficiency - 1.0;

    // Remove vig to get true probabilities
    const homeTrueProb = homeImpliedProb / marketEfficiency;
    const awayTrueProb = awayImpliedProb / marketEfficiency;

    // Compare to our model predictions (simplified - would use actual model)
    // For now, assume market is efficient, but look for value
    const homeValue = homeTrueProb > 0.5 ? (homeTrueProb - 0.5) * 2 : 0;
    const awayValue = awayTrueProb > 0.5 ? (awayTrueProb - 0.5) * 2 : 0;

    const edge = Math.max(homeValue, awayValue) * 100;
    const confidence = Math.abs(homeTrueProb - 0.5) * 2;
    const winner = homeTrueProb > 0.5 ? gameData.homeTeam : gameData.awayTeam;

    const reasoning = `Market analysis: ${winner} has ${edge.toFixed(1)}% edge based on implied probabilities`;

    return { confidence, reasoning, winner, edge };
  }

  /**
   * Weather Impact Analysis
   */
  private weatherImpactAnalysis(gameData: GameData): {
    confidence: number;
    reasoning: string;
    winner: string;
    risk?: string;
  } {
    if (!gameData.weather) {
      return { confidence: 0.5, reasoning: 'No weather data available', winner: gameData.homeTeam };
    }

    const { temperature, conditions, windSpeed } = gameData.weather;
    let impact = 0;
    let reasoning = 'Weather conditions: ';
    let risk: string | undefined;

    // Extreme weather impacts
    if (conditions?.toLowerCase().includes('snow') || conditions?.toLowerCase().includes('rain')) {
      impact += 0.1; // Favors running game / defense
      reasoning += 'Precipitation favors ground game. ';
      risk = 'Weather conditions may affect game flow';
    }

    if (windSpeed && windSpeed > 20) {
      impact += 0.15; // Favors running game
      reasoning += `High winds (${windSpeed}mph) favor running game. `;
      if (!risk) risk = 'High winds may impact passing game';
    }

    if (temperature && temperature < 20) {
      impact += 0.05; // Slight advantage to home team
      reasoning += `Cold temperatures (${temperature}¬∞F) may affect performance. `;
    }

    // Default: slight home advantage in bad weather
    const homeAdvantage = impact;
    const confidence = Math.min(impact * 5, 0.7);
    const winner = gameData.homeTeam; // Home team typically handles weather better

    reasoning += `Weather gives slight edge to home team.`;

    return { confidence, reasoning, winner, risk };
  }

  /**
   * Injury Impact Analysis
   */
  private injuryImpactAnalysis(gameData: GameData): {
    confidence: number;
    reasoning: string;
    winner: string;
    risk?: string;
  } {
    if (!gameData.injuries) {
      return { confidence: 0.5, reasoning: 'No injury data available', winner: gameData.homeTeam };
    }

    const { homeImpact, awayImpact } = gameData.injuries;
    const impactDiff = (awayImpact || 0) - (homeImpact || 0);

    let reasoning = 'Injury impact: ';
    let risk: string | undefined;

    if (Math.abs(impactDiff) > 0.1) {
      const affectedTeam = impactDiff > 0 ? gameData.awayTeam : gameData.homeTeam;
      const advantage = Math.abs(impactDiff);
      reasoning += `${affectedTeam} significantly impacted by injuries (${(advantage * 100).toFixed(0)}% reduction). `;
      risk = 'Key player injuries may affect game outcome';
    } else {
      reasoning += 'Injuries relatively balanced. ';
    }

    const confidence = Math.min(Math.abs(impactDiff) * 3, 0.8);
    const winner = impactDiff > 0 ? gameData.homeTeam : gameData.awayTeam;

    return { confidence, reasoning, winner, risk };
  }

  /**
   * Home Advantage Analysis
   */
  private homeAdvantageAnalysis(gameData: GameData): { confidence: number; reasoning: string; winner: string } {
    if (!gameData.teamStats?.home?.homeRecord) {
      return { confidence: 0.3, reasoning: 'Home advantage: Standard 3-point advantage', winner: gameData.homeTeam };
    }

    const homeRecord = gameData.teamStats.home.homeRecord;
    const homeWinPct = homeRecord.wins / (homeRecord.wins + homeRecord.losses);

    // Strong home teams get more advantage
    const homeAdvantage = 0.03 + (homeWinPct - 0.5) * 0.1; // 3-8% advantage
    const confidence = Math.min(homeAdvantage * 10, 0.6);
    const winner = gameData.homeTeam;

    const reasoning = `Home advantage: ${gameData.homeTeam} has ${(homeWinPct * 100).toFixed(0)}% home win rate, providing ${(homeAdvantage * 100).toFixed(1)}% advantage`;

    return { confidence, reasoning, winner };
  }

  /**
   * Momentum Analysis
   */
  private momentumAnalysis(gameData: GameData): { confidence: number; reasoning: string; winner: string } {
    if (!gameData.recentForm) {
      return { confidence: 0.5, reasoning: 'Insufficient momentum data', winner: gameData.homeTeam };
    }

    const homeForm = gameData.recentForm.home || [];
    const awayForm = gameData.recentForm.away || [];

    // Calculate momentum (recent wins weighted more)
    const homeMomentum = homeForm.slice(0, 3).reduce((sum, result, index) => {
      const weight = 3 - index; // Most recent = highest weight
      if (result === 'W') return sum + weight;
      if (result === 'L') return sum - weight;
      return sum;
    }, 0) / 6;

    const awayMomentum = awayForm.slice(0, 3).reduce((sum, result, index) => {
      const weight = 3 - index;
      if (result === 'W') return sum + weight;
      if (result === 'L') return sum - weight;
      return sum;
    }, 0) / 6;

    const momentumDiff = homeMomentum - awayMomentum;
    const confidence = Math.min(Math.abs(momentumDiff) * 0.3, 0.7);
    const winner = momentumDiff > 0 ? gameData.homeTeam : gameData.awayTeam;

    const reasoning = `Momentum: ${winner} has stronger recent momentum (${momentumDiff > 0 ? '+' : ''}${momentumDiff.toFixed(2)})`;

    return { confidence, reasoning, winner };
  }

  /**
   * Machine Learning Prediction (simplified - would use actual ML model)
   */
  private async machineLearningPrediction(gameData: GameData): Promise<{
    confidence: number;
    reasoning: string;
    winner: string;
  } | null> {
    // In production, this would use a trained ML model
    // For now, use weighted combination of historical performance

    try {
      // Get historical performance for similar games
      const stats = await getWinPercentage({
        type: 'sports',
        category: gameData.league
      });

      if (!stats || stats.total < 10) {
        return null; // Not enough data
      }

      // Adjust prediction based on historical accuracy
      const historicalAccuracy = stats.win_percentage / 100;
      const baseConfidence = 0.6;
      const adjustedConfidence = baseConfidence * historicalAccuracy;

      // Use statistical model as base, adjust with ML insights
      const statisticalPred = this.statisticalModel(gameData);
      const mlConfidence = (statisticalPred.confidence * 0.7) + (adjustedConfidence * 0.3);

      return {
        confidence: mlConfidence,
        reasoning: `ML model: Based on ${stats.total} historical predictions with ${stats.win_percentage.toFixed(1)}% accuracy`,
        winner: statisticalPred.winner
      };
    } catch (error) {
      console.warn('[PredictionEngine] ML prediction failed:', error);
      return null;
    }
  }

  /**
   * Combine all methods using weighted average
   */
  private combineMethods(
    methods: { name: string; confidence: number; weight: number }[],
    gameData: GameData
  ): { winner: string; confidence: number; score?: { home: number; away: number } } {
    // Group by predicted winner
    const homeVotes: number[] = [];
    const awayVotes: number[] = [];

    methods.forEach(method => {
      // For simplicity, assume methods predict home or away
      // In production, each method would return its prediction
      const vote = method.confidence * method.weight;

      // Simplified: assume higher confidence = home team (would be more sophisticated)
      if (method.confidence > 0.5) {
        homeVotes.push(vote);
      } else {
        awayVotes.push(vote);
      }
    });

    const homeTotal = homeVotes.reduce((sum, v) => sum + v, 0);
    const awayTotal = awayVotes.reduce((sum, v) => sum + v, 0);
    const total = homeTotal + awayTotal;

    const homeWinProb = total > 0 ? homeTotal / total : 0.5;
    const winner = homeWinProb > 0.5 ? gameData.homeTeam : gameData.awayTeam;
    const confidence = Math.abs(homeWinProb - 0.5) * 2;

    // Predict score (simplified)
    const score = this.predictScore(gameData, homeWinProb);

    return { winner, confidence, score };
  }

  /**
   * Predict game score
   */
  private predictScore(gameData: GameData, homeWinProb: number): { home: number; away: number } {
    if (!gameData.teamStats) {
      return { home: 24, away: 21 };
    }

    const { home, away } = gameData.teamStats;
    const avgHomeScore = home.recentAvgPoints || 24;
    const avgAwayScore = away.recentAvgPoints || 22;
    const avgHomeAllowed = home.recentAvgAllowed || 21;
    const avgAwayAllowed = away.recentAvgAllowed || 24;

    // Expected points = (own offense + opponent defense) / 2
    const homeExpected = (avgHomeScore + avgAwayAllowed) / 2;
    const awayExpected = (avgAwayScore + avgHomeAllowed) / 2;

    // Adjust based on win probability
    const homeScore = homeExpected + (homeWinProb - 0.5) * 4;
    const awayScore = awayExpected - (homeWinProb - 0.5) * 4;

    return {
      home: Math.round(homeScore),
      away: Math.round(awayScore)
    };
  }

  /**
   * Calculate expected value edge
   */
  private calculateEdge(gameData: GameData, result: { winner: string; confidence: number }): number {
    const { odds } = gameData;
    const isHomeWinner = result.winner === gameData.homeTeam;

    const impliedProb = isHomeWinner
      ? this.americanToImplied(odds.home)
      : this.americanToImplied(odds.away);

    const modelProb = result.confidence;
    const edge = (modelProb - impliedProb) * 100;

    return edge;
  }

  /**
   * Generate bet recommendation
   */
  private generateBetRecommendation(
    gameData: GameData,
    result: { winner: string; confidence: number },
    edge: number,
    forceMoneyline: boolean = false
  ): { type: 'moneyline' | 'spread' | 'total'; side: string; value: number; confidence: number } | undefined {
    if (edge < 2) {
      return undefined; // Not enough edge
    }

    const isHomeWinner = result.winner === gameData.homeTeam;
    const side = isHomeWinner ? gameData.homeTeam : gameData.awayTeam;

    // For Kalshi games, always use moneyline (outright winner)
    // For regular games, use probability-based logic
    const betType = forceMoneyline || result.confidence <= 0.65 ? 'moneyline' : 'spread';
    const value = isHomeWinner ? gameData.odds.home : gameData.odds.away;

    return {
      type: betType,
      side,
      value,
      confidence: result.confidence
    };
  }

  /**
   * Convert American odds to implied probability
   */
  private americanToImplied(odds: number): number {
    if (odds > 0) {
      return 100 / (odds + 100);
    } else {
      return Math.abs(odds) / (Math.abs(odds) + 100);
    }
  }

  /**
   * Learn from results - update method weights based on performance
   */
  async learnFromResult(
    predictionId: string,
    actualOutcome: 'correct' | 'incorrect' | 'partial',
    methods: { name: string; confidence: number; weight: number }[]
  ): Promise<void> {
    const accuracy = actualOutcome === 'correct' ? 1.0 : actualOutcome === 'partial' ? 0.5 : 0.0;

    // Update method performance
    methods.forEach(method => {
      const perf = this.methodPerformance.get(method.name) || { correct: 0, total: 0, avgAccuracy: 0 };
      perf.total += 1;
      if (actualOutcome === 'correct') perf.correct += 1;

      // Update average accuracy
      perf.avgAccuracy = (perf.avgAccuracy * (perf.total - 1) + accuracy) / perf.total;

      this.methodPerformance.set(method.name, perf);

      // Adjust weight based on performance
      const performanceRatio = perf.avgAccuracy;
      const currentWeight = this.learningWeights.get(method.name) || 1.0;
      const newWeight = currentWeight * (0.9 + performanceRatio * 0.2); // Adjust by ¬±10%

      this.learningWeights.set(method.name, Math.max(0.5, Math.min(2.0, newWeight))); // Clamp between 0.5 and 2.0
    });

    // Store learning data for weekly analysis
    this.weeklyLearningData.push({
      method: methods.map(m => m.name).join(','),
      confidence: methods.reduce((sum, m) => sum + m.confidence, 0) / methods.length,
      actualOutcome,
      accuracy,
      timestamp: new Date().toISOString()
    });

    // Record outcome in database
    await recordOutcome(predictionId, {
      status: actualOutcome,
      outcome_data: { methods, accuracy },
      is_correct: actualOutcome === 'correct',
      accuracy_score: accuracy * 100,
      confidence_accuracy: accuracy
    });
  }

  /**
   * Weekly learning cycle - analyze past week's performance and adjust
   */
  async weeklyLearningCycle(): Promise<void> {
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

    // Get all predictions from past week
    const stats = await getWinPercentage({
      startDate: oneWeekAgo.toISOString(),
      endDate: new Date().toISOString()
    });

    if (!stats || stats.total === 0) {
      console.log('[PredictionEngine] No data for weekly learning cycle');
      return;
    }

    // Analyze performance by method
    const methodStats = new Map<string, { correct: number; total: number; avgConfidence: number }>();

    this.weeklyLearningData.forEach(data => {
      const methods = data.method.split(',');
      methods.forEach(method => {
        const stat = methodStats.get(method) || { correct: 0, total: 0, avgConfidence: 0 };
        stat.total += 1;
        if (data.actualOutcome === 'correct') stat.correct += 1;
        stat.avgConfidence = (stat.avgConfidence * (stat.total - 1) + data.confidence) / stat.total;
        methodStats.set(method, stat);
      });
    });

    // Adjust weights based on weekly performance
    methodStats.forEach((stat, method) => {
      const winRate = stat.total > 0 ? stat.correct / stat.total : 0.5;
      const currentWeight = this.learningWeights.get(method) || 1.0;

      // Adjust weight: better performance = higher weight
      const adjustment = (winRate - 0.5) * 0.2; // ¬±10% adjustment
      const newWeight = currentWeight * (1 + adjustment);

      this.learningWeights.set(method, Math.max(0.5, Math.min(2.0, newWeight)));

      console.log(`[PredictionEngine] ${method}: ${(winRate * 100).toFixed(1)}% win rate, weight adjusted to ${newWeight.toFixed(2)}`);
    });

    // Clear weekly data for next cycle
    this.weeklyLearningData = [];

    console.log(`[PredictionEngine] Weekly learning cycle complete. Overall: ${stats.win_percentage.toFixed(1)}% win rate`);
  }

  /**
   * Get current method weights (for debugging/monitoring)
   */
  getMethodWeights(): Map<string, number> {
    return this.learningWeights;
  }

  /**
   * Set method weight (for tuning)
   */
  setMethodWeight(method: string, weight: number): void {
    this.learningWeights.set(method, Math.max(0.1, Math.min(3.0, weight)));
  }

  /**
   * Set all method weights (for tuning)
   */
  setMethodWeights(weights: Map<string, number>): void {
    weights.forEach((weight, method) => {
      this.setMethodWeight(method, weight);
    });
  }

  /**
   * Get method performance stats
   */
  getMethodPerformance(): Map<string, { correct: number; total: number; avgAccuracy: number }> {
    return new Map(this.methodPerformance);
  }

  /**
   * Poisson Distribution - For Total Score Predictions
   * Uses Poisson distribution to predict game totals based on team scoring rates
   */
  private poissonDistribution(gameData: GameData): {
    confidence: number;
    reasoning: string;
    winner: string;
    predictedTotal?: number;
  } {
    if (!gameData.teamStats || !gameData.odds.total) {
      return { confidence: 0.5, reasoning: 'Insufficient data for Poisson distribution', winner: gameData.homeTeam };
    }

    const { home, away } = gameData.teamStats;

    // Calculate expected goals/points per game (lambda)
    const homeLambda = home.recentAvgPoints || (home.pointsFor / (home.wins + home.losses)) || 20;
    const awayLambda = away.recentAvgPoints || (away.pointsFor / (away.wins + away.losses)) || 20;

    // Adjust for defensive ratings
    const homeDefense = away.recentAvgAllowed || (away.pointsAgainst / (away.wins + away.losses)) || 20;
    const awayDefense = home.recentAvgAllowed || (home.pointsAgainst / (home.wins + home.losses)) || 20;

    // Adjusted lambdas (offense vs opponent defense)
    const adjustedHomeLambda = (homeLambda * 0.7) + (homeLambda * (1 - (homeDefense / 30)) * 0.3);
    const adjustedAwayLambda = (awayLambda * 0.7) + (awayLambda * (1 - (awayDefense / 30)) * 0.3);

    // Expected total
    const expectedTotal = adjustedHomeLambda + adjustedAwayLambda;

    // Calculate probability of over/under using Poisson
    const overProb = this.poissonProbabilityOver(expectedTotal, gameData.odds.total);
    const underProb = 1 - overProb;

    // Confidence based on how far from 50/50
    const confidence = Math.abs(overProb - 0.5) * 2;

    // Determine if we favor over or under
    const favorsOver = overProb > 0.5;
    const reasoning = `Poisson distribution: Expected total ${expectedTotal.toFixed(1)} points. ${(Math.max(overProb, underProb) * 100).toFixed(1)}% probability ${favorsOver ? 'over' : 'under'} ${gameData.odds.total}`;

    return {
      confidence,
      reasoning,
      winner: gameData.homeTeam, // Winner doesn't apply to totals, but required by interface
      predictedTotal: expectedTotal
    };
  }

  /**
   * Calculate probability of going over a total using Poisson distribution
   */
  private poissonProbabilityOver(lambda: number, total: number): number {
    // Use Poisson CDF approximation
    // P(X > total) = 1 - P(X <= total)
    let cumulative = 0;
    for (let k = 0; k <= Math.floor(total); k++) {
      cumulative += Math.pow(lambda, k) * Math.exp(-lambda) / this.factorial(k);
    }
    return 1 - cumulative;
  }

  /**
   * Factorial helper for Poisson
   */
  private factorial(n: number): number {
    if (n <= 1) return 1;
    let result = 1;
    for (let i = 2; i <= n; i++) {
      result *= i;
    }
    return result;
  }

  /**
   * Regression Model - Factor in Historical Trends
   * Uses linear regression to identify trends in team performance
   */
  private async regressionModel(gameData: GameData): Promise<{
    confidence: number;
    reasoning: string;
    winner: string;
  } | null> {
    if (!gameData.teamStats) {
      return null;
    }

    const { home, away } = gameData.teamStats;

    // Simple linear regression on recent performance
    // Trend = (recentAvg - seasonAvg) / games
    const homeRecentAvg = home.recentAvgPoints || 0;
    const awayRecentAvg = away.recentAvgPoints || 0;

    const homeSeasonAvg = home.pointsFor / (home.wins + home.losses) || 0;
    const awaySeasonAvg = away.pointsFor / (away.wins + away.losses) || 0;

    // Calculate trend (positive = improving, negative = declining)
    const homeTrend = homeRecentAvg - homeSeasonAvg;
    const awayTrend = awayRecentAvg - awaySeasonAvg;

    // Trend strength (how significant is the change)
    const homeTrendStrength = Math.abs(homeTrend) / Math.max(homeSeasonAvg, 1);
    const awayTrendStrength = Math.abs(awayTrend) / Math.max(awaySeasonAvg, 1);

    // Combine trend with current strength
    const homeStrength = (homeSeasonAvg * 0.6) + (homeRecentAvg * 0.4) + (homeTrend * 0.2);
    const awayStrength = (awaySeasonAvg * 0.6) + (awayRecentAvg * 0.4) + (awayTrend * 0.2);

    const homeWinProb = homeStrength / (homeStrength + awayStrength);
    const confidence = Math.min(Math.abs(homeWinProb - 0.5) * 2, 0.8);
    const winner = homeWinProb > 0.5 ? gameData.homeTeam : gameData.awayTeam;

    const homeTrendDesc = homeTrend > 0 ? 'improving' : homeTrend < 0 ? 'declining' : 'stable';
    const awayTrendDesc = awayTrend > 0 ? 'improving' : awayTrend < 0 ? 'declining' : 'stable';

    const reasoning = `Regression model: ${winner} favored. Home team ${homeTrendDesc} (${homeTrend > 0 ? '+' : ''}${homeTrend.toFixed(1)}), Away team ${awayTrendDesc} (${awayTrend > 0 ? '+' : ''}${awayTrend.toFixed(1)})`;

    return { confidence, reasoning, winner };
  }

  /**
   * Bayesian Update - Learn from Past Predictions
   * Updates prior beliefs based on historical prediction accuracy
   */
  private async bayesianUpdate(gameData: GameData): Promise<{
    confidence: number;
    reasoning: string;
    winner: string;
  } | null> {
    try {
      // Get historical win percentage for similar games
      const historicalStats = await getWinPercentage({
        type: 'sports',
        category: gameData.league || gameData.sport
      });

      if (!historicalStats || historicalStats.total < 10) {
        return null; // Need at least 10 historical predictions
      }

      // Prior probability (from our model)
      const priorProb = 0.5; // Start with 50/50

      // Likelihood (historical accuracy for this type of game)
      const historicalAccuracy = historicalStats.win_percentage / 100;

      // Bayesian update: P(A|B) = P(B|A) * P(A) / P(B)
      // Simplified: posterior = (likelihood * prior) / evidence
      const evidence = (historicalAccuracy * priorProb) + ((1 - historicalAccuracy) * (1 - priorProb));
      const posteriorProb = (historicalAccuracy * priorProb) / evidence;

      // Adjust confidence based on historical performance
      const confidence = Math.min(posteriorProb * 2, 0.9); // Cap at 90%

      // Determine winner based on team stats (simplified)
      let winner = gameData.homeTeam;
      if (gameData.teamStats) {
        const homeStrength = gameData.teamStats.home.wins / (gameData.teamStats.home.wins + gameData.teamStats.home.losses);
        const awayStrength = gameData.teamStats.away.wins / (gameData.teamStats.away.wins + gameData.teamStats.away.losses);
        winner = homeStrength > awayStrength ? gameData.homeTeam : gameData.awayTeam;
      }

      const reasoning = `Bayesian update: Historical accuracy ${(historicalAccuracy * 100).toFixed(1)}% for ${gameData.league || gameData.sport}. Posterior probability adjusted to ${(posteriorProb * 100).toFixed(1)}%`;

      return { confidence, reasoning, winner };
    } catch (error) {
      console.warn('[PredictionEngine] Bayesian update failed:', error);
      return null;
    }
  }

  /**
   * Enhanced Monte Carlo Simulation
   * Run 10,000 game simulations for robust predictions
   */
  async monteCarloSimulation(
    gameData: GameData,
    iterations: number = 10000
  ): Promise<{
    winRate: number;
    confidence: number;
    averageScore: { home: number; away: number };
    stdDev: number;
    iterations: number;
  }> {
    if (!gameData.teamStats) {
      throw new Error('Team stats required for Monte Carlo simulation');
    }

    const { home, away } = gameData.teamStats;

    // Base scoring rates
    const homeOffense = home.recentAvgPoints || (home.pointsFor / (home.wins + home.losses)) || 20;
    const awayOffense = away.recentAvgPoints || (away.pointsFor / (away.wins + away.losses)) || 20;
    const homeDefense = home.recentAvgAllowed || (home.pointsAgainst / (home.wins + home.losses)) || 20;
    const awayDefense = away.recentAvgAllowed || (away.pointsAgainst / (away.wins + away.losses)) || 20;

    let homeWins = 0;
    let totalHomeScore = 0;
    let totalAwayScore = 0;
    const homeScores: number[] = [];
    const awayScores: number[] = [];

    // Run simulations
    for (let i = 0; i < iterations; i++) {
      // Simulate scores using normal distribution around expected values
      // Offense vs opponent defense
      const expectedHomeScore = (homeOffense * 0.6) + (homeOffense * (1 - (awayDefense / 30)) * 0.4);
      const expectedAwayScore = (awayOffense * 0.6) + (awayOffense * (1 - (homeDefense / 30)) * 0.4);

      // Add randomness (standard deviation ~10% of expected)
      const homeScore = Math.max(0, this.normalRandom(expectedHomeScore, expectedHomeScore * 0.1));
      const awayScore = Math.max(0, this.normalRandom(expectedAwayScore, expectedAwayScore * 0.1));

      homeScores.push(homeScore);
      awayScores.push(awayScore);
      totalHomeScore += homeScore;
      totalAwayScore += awayScore;

      if (homeScore > awayScore) {
        homeWins++;
      }
    }

    // Calculate statistics
    const winRate = homeWins / iterations;
    const avgHomeScore = totalHomeScore / iterations;
    const avgAwayScore = totalAwayScore / iterations;

    // Calculate standard deviation
    const homeVariance = homeScores.reduce((sum, score) => sum + Math.pow(score - avgHomeScore, 2), 0) / iterations;
    const awayVariance = awayScores.reduce((sum, score) => sum + Math.pow(score - avgAwayScore, 2), 0) / iterations;
    const stdDev = Math.sqrt((homeVariance + awayVariance) / 2);

    // Confidence based on win rate distance from 50%
    const confidence = Math.abs(winRate - 0.5) * 2;

    return {
      winRate,
      confidence,
      averageScore: {
        home: avgHomeScore,
        away: avgAwayScore
      },
      stdDev,
      iterations
    };
  }

  /**
   * Generate random number from normal distribution (Box-Muller transform)
   */
  private normalRandom(mean: number, stdDev: number): number {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + z0 * stdDev;
  }

  /**
   * Enhanced ELO Rating System - Track Team Strength Over Time
   * Maintains ELO ratings that update based on game results
   */
  private eloRatingEnhanced(gameData: GameData): {
    confidence: number;
    reasoning: string;
    winner: string;
    eloRatings: { home: number; away: number };
  } {
    if (!gameData.teamStats) {
      return {
        confidence: 0.5,
        reasoning: 'Insufficient data for ELO rating',
        winner: gameData.homeTeam,
        eloRatings: { home: 1500, away: 1500 }
      };
    }

    const { home, away } = gameData.teamStats;

    // Calculate base ELO from win percentage
    const homeWinPct = home.wins / (home.wins + home.losses);
    const awayWinPct = away.wins / (away.wins + away.losses);

    // Base ELO (1500 is average)
    let homeELO = 1500 + (homeWinPct - 0.5) * 400;
    let awayELO = 1500 + (awayWinPct - 0.5) * 400;

    // Adjust for recent form (recent games weighted more)
    if (home.recentAvgPoints && away.recentAvgPoints) {
      const homeRecentStrength = (home.recentAvgPoints / (home.recentAvgPoints + away.recentAvgAllowed)) || 0.5;
      const awayRecentStrength = (away.recentAvgPoints / (away.recentAvgPoints + home.recentAvgAllowed)) || 0.5;

      // Blend base ELO with recent form (70% base, 30% recent)
      homeELO = (homeELO * 0.7) + (1500 + (homeRecentStrength - 0.5) * 400) * 0.3;
      awayELO = (awayELO * 0.7) + (1500 + (awayRecentStrength - 0.5) * 400) * 0.3;
    }

    // Home advantage (typically +50 ELO points)
    const homeAdvantage = 50;
    const adjustedHomeELO = homeELO + homeAdvantage;

    // ELO difference
    const eloDiff = adjustedHomeELO - awayELO;

    // Win probability from ELO difference
    // Formula: P = 1 / (1 + 10^(-diff/400))
    const homeWinProb = 1 / (1 + Math.pow(10, -eloDiff / 400));
    const confidence = Math.abs(homeWinProb - 0.5) * 2;
    const winner = homeWinProb > 0.5 ? gameData.homeTeam : gameData.awayTeam;

    const reasoning = `Enhanced ELO: ${winner} favored (${adjustedHomeELO.toFixed(0)} vs ${awayELO.toFixed(0)}) with ${(homeWinProb * 100).toFixed(1)}% win probability. ELO difference: ${eloDiff > 0 ? '+' : ''}${eloDiff.toFixed(0)}`;

    return {
      confidence,
      reasoning,
      winner,
      eloRatings: {
        home: adjustedHomeELO,
        away: awayELO
      }
    };
  }
}

// Export singleton instance
export const predictionEngine = new PredictionEngine();



=== END CONTENT ===


=== FILENAME (found alt): app/lib/claude-effect-integration.ts ===
=== START CONTENT ===
/**
 * Claude Effect Integration Helper
 * Gathers data from all 7 phases and applies to predictions
 */

import { ClaudeEffectEngine } from './claude-effect';

export interface ClaudeEffectData {
  sentiment?: any;
  narratives?: any;
  informationAsymmetry?: any;
  chaosFactors?: any;
  network?: any;
  temporal?: any;
  emergent?: any;
}

/**
 * Gather Claude Effect data for a game
 */
export async function gatherClaudeEffectData(
  gameData: any,
  options: {
    includePhase1?: boolean;
    includePhase2?: boolean;
    includePhase3?: boolean;
    includePhase4?: boolean;
    includePhase5?: boolean;
    includePhase6?: boolean;
    includePhase7?: boolean;
  } = {}
): Promise<ClaudeEffectData> {
  const {
    includePhase1 = true,
    includePhase2 = true,
    includePhase3 = true,
    includePhase4 = true,
    includePhase5 = false, // Optional for now
    includePhase6 = false, // Optional for now
    includePhase7 = false, // Optional for now
  } = options;

  // Determine base URL for API calls
  let baseUrl = 'http://localhost:3000';
  if (process.env.NEXT_PUBLIC_PROGNO_URL) {
    baseUrl = process.env.NEXT_PUBLIC_PROGNO_URL;
  } else if (process.env.VERCEL_URL) {
    baseUrl = `https://${process.env.VERCEL_URL}`;
  } else if (typeof window !== 'undefined') {
    baseUrl = window.location.origin;
  } else if (process.env.PORT) {
    baseUrl = `http://localhost:${process.env.PORT}`;
  }

  const results: ClaudeEffectData = {};

  // Phase 1: Sentiment Field
  if (includePhase1) {
    try {
      // Try direct import first (server-side), fallback to API (client-side)
      if (typeof window === 'undefined') {
        try {
          const sentimentModule = require('./sentiment/scoring-engine');
          const sentimentData = await sentimentModule.calculateSentimentField(
            gameData.homeTeam?.toLowerCase().replace(/\s+/g, '-'),
            gameData.homeTeam,
            gameData.id || gameData.gameId
          );
          results.sentiment = sentimentData;
        } catch (directError) {
          // Fallback to API call
          const response = await fetch(`${baseUrl}/api/sentiment/calculate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              teamId: gameData.homeTeam?.toLowerCase().replace(/\s+/g, '-'),
              teamName: gameData.homeTeam,
              gameId: gameData.id || gameData.gameId,
            }),
          });
          if (response.ok) {
            const data = await response.json();
            results.sentiment = data.data;
          }
        }
      } else {
        // Client-side: use API
        const response = await fetch(`${baseUrl}/api/sentiment/calculate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            teamId: gameData.homeTeam?.toLowerCase().replace(/\s+/g, '-'),
            teamName: gameData.homeTeam,
            gameId: gameData.id || gameData.gameId,
          }),
        });
        if (response.ok) {
          const data = await response.json();
          results.sentiment = data.data;
        }
      }
    } catch (error) {
      console.warn('[Claude Effect] Phase 1 (SF) failed:', error);
    }
  }

  // Phase 2: Narrative Momentum
  if (includePhase2) {
    try {
      const response = await fetch(`${baseUrl}/api/narrative/calculate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          teamId: gameData.homeTeam?.toLowerCase().replace(/\s+/g, '-'),
          teamName: gameData.homeTeam,
          opponentId: gameData.awayTeam?.toLowerCase().replace(/\s+/g, '-'),
          opponentName: gameData.awayTeam,
          gameId: gameData.id || gameData.gameId,
          context: {
            gameDate: gameData.date || gameData.commence_time,
            schedule: gameData.schedule,
            roster: gameData.roster,
          },
        }),
      });
      if (response.ok) {
        const data = await response.json();
        results.narratives = data.data;
      }
    } catch (error) {
      console.warn('[Claude Effect] Phase 2 (NM) failed:', error);
    }
  }

  // Phase 3: Information Asymmetry Index
  if (includePhase3 && gameData.odds) {
    try {
      const response = await fetch(`${baseUrl}/api/iai/calculate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          gameId: gameData.id || gameData.gameId,
          context: {
            openingLine: gameData.odds.spread || 0,
            currentLine: gameData.odds.spread || 0,
            isHomeFavorite: (gameData.odds.home || 0) < (gameData.odds.away || 0),
            sport: gameData.league || 'NFL',
            publicTicketPct: gameData.betSplits?.public || 0.5,
            bettingSplits: gameData.betSplits,
            recentMovements: gameData.lineMovement,
          },
        }),
      });
      if (response.ok) {
        const data = await response.json();
        results.informationAsymmetry = data.data;
      }
    } catch (error) {
      console.warn('[Claude Effect] Phase 3 (IAI) failed:', error);
    }
  }

  // Phase 4: Chaos Sensitivity Index
  if (includePhase4) {
    try {
      const response = await fetch(`${baseUrl}/api/csi/calculate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          gameId: gameData.id || gameData.gameId,
          context: {
            sport: gameData.league || 'NFL',
            weather: gameData.weather,
            schedule: {
              isShortWeek: gameData.isShortWeek,
              isTrapGame: gameData.isTrapGame,
              daysRest: gameData.daysRest,
              travelLag: gameData.travelLag,
            },
            roster: {
              clusterInjuries: gameData.clusterInjuries,
              keyInjuries: gameData.keyInjuries,
            },
            rivalry: {
              isDivisionRivalry: gameData.isDivisionRivalry,
              isHistoricRivalry: gameData.isHistoricRivalry,
            },
            referee: gameData.referee,
          },
        }),
      });
      if (response.ok) {
        const data = await response.json();
        results.chaosFactors = data.data;
      }
    } catch (error) {
      console.warn('[Claude Effect] Phase 4 (CSI) failed:', error);
    }
  }

  // Phase 5: Network Influence Graph (optional)
  if (includePhase5 && gameData.players && gameData.relationships) {
    try {
      const response = await fetch(`${baseUrl}/api/nig/calculate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          teamId: gameData.homeTeam?.toLowerCase().replace(/\s+/g, '-'),
          gameId: gameData.id || gameData.gameId,
          players: gameData.players,
          relationships: gameData.relationships,
        }),
      });
      if (response.ok) {
        const data = await response.json();
        results.network = data.data;
      }
    } catch (error) {
      console.warn('[Claude Effect] Phase 5 (NIG) failed:', error);
    }
  }

  // Phase 6: Temporal Relevance Decay (optional)
  if (includePhase6 && gameData.recentEvents) {
    try {
      const response = await fetch(`${baseUrl}/api/temporal/decay`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sport: gameData.league || 'NFL',
          events: gameData.recentEvents,
        }),
      });
      if (response.ok) {
        const data = await response.json();
        results.temporal = data.data;
      }
    } catch (error) {
      console.warn('[Claude Effect] Phase 6 (TRD) failed:', error);
    }
  }

  // Phase 7: Emergent Pattern Detection (optional)
  if (includePhase7) {
    try {
      const response = await fetch(`${baseUrl}/api/emergent/detect`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          context: {
            teamId: gameData.homeTeam?.toLowerCase().replace(/\s+/g, '-'),
            opponentId: gameData.awayTeam?.toLowerCase().replace(/\s+/g, '-'),
            gameData: gameData,
          },
        }),
      });
      if (response.ok) {
        const data = await response.json();
        results.emergent = data.data;
      }
    } catch (error) {
      console.warn('[Claude Effect] Phase 7 (EPD) failed:', error);
    }
  }

  return results;
}

/**
 * Apply Claude Effect to a prediction
 */
export async function applyClaudeEffect(
  baseProbability: number,
  baseConfidence: number,
  gameData: any,
  claudeData: ClaudeEffectData
): Promise<{
  adjustedProbability: number;
  adjustedConfidence: number;
  claudeEffect: number;
  scores: any;
  reasoning: string[];
  warnings: string[];
  recommendations: any;
}> {
  const engine = new ClaudeEffectEngine();

  // Transform API responses to Claude Effect engine format
  const context: any = {};

  // Phase 1: Sentiment Field
  if (claudeData.sentiment) {
    context.sentiment = {
      playerInterviews: claudeData.sentiment.componentScores?.player || 0,
      socialMedia: claudeData.sentiment.componentScores?.social || 0,
      pressConferences: claudeData.sentiment.componentScores?.press || 0,
      fanSentiment: claudeData.sentiment.componentScores?.fan || 0,
      beatReporterTone: claudeData.sentiment.componentScores?.beatReporter || 0,
    };
  }

  // Phase 2: Narrative Momentum
  if (claudeData.narratives) {
    context.narratives = claudeData.narratives.detectedNarratives || [];
  }

  // Phase 3: Information Asymmetry
  if (claudeData.informationAsymmetry) {
    context.informationAsymmetry = {
      reverseLineMovement: claudeData.informationAsymmetry.signalsDetected?.rlm || null,
      steamMove: claudeData.informationAsymmetry.signalsDetected?.steam || null,
      proEdge: claudeData.informationAsymmetry.signalsDetected?.proEdge || null,
      lineFreeze: claudeData.informationAsymmetry.signalsDetected?.freeze || null,
    };
  }

  // Phase 4: Chaos Sensitivity
  if (claudeData.chaosFactors) {
    context.chaosFactors = {
      weather: gameData.weather,
      schedule: gameData.schedule,
      roster: gameData.roster,
      rivalry: gameData.rivalry,
    };
    context.chaosData = {
      csiScore: claudeData.chaosFactors.csiScore || 0,
      confidencePenalty: claudeData.chaosFactors.confidencePenalty || 0,
    };
  }

  // Phase 5: Network Influence
  if (claudeData.network) {
    context.networkData = {
      cohesion: claudeData.network.cohesion?.overall || 0,
      leadership: claudeData.network.leadership?.leadershipStrength || 0,
      integration: claudeData.network.integration?.integrationScore || 0,
    };
  }

  // Phase 6: Temporal Decay
  if (claudeData.temporal?.events) {
    context.recentEvents = claudeData.temporal.events;
  }

  // Phase 7: Emergent Patterns
  if (claudeData.emergent?.patterns) {
    context.emergentPatterns = claudeData.emergent.patterns
      .filter((p: any) => p.matched)
      .map((p: any) => ({
        score: p.score,
        description: p.pattern.description,
      }));
  }

  const result = await engine.calculateClaudeEffect(
    baseProbability,
    baseConfidence,
    gameData,
    context
  );

  return result;
}



=== END CONTENT ===


=== FILENAME (found alt): app/lib/claude-effect-weights.ts ===
=== START CONTENT ===
/**
 * Claude Effect weight configurations by league.
 * From simulation: NHL "Momentum" (NM + Rest); NFL "Efficiency" (IAI + CSI).
 * Use getWeightsForLeague(league) in ClaudeEffectEngine and offline backtest.
 */

export interface ClaudeEffectWeights7D {
  SF: number;   // Sentiment Field
  NM: number;   // Narrative Momentum
  IAI: number;  // Information Asymmetry Index
  CSI: number;  // Chaos Sensitivity Index
  NIG: number;  // Network Influence Graph
  TRD: number;  // Temporal Relevance Decay
  EPD: number;  // Emergent Pattern Detection
  REST?: number; // Rest/Travel (high impact in NHL; applied via CSI when no rest score)
}

/** NHL "Momentum" ‚Äì NM and Rest primary; identifies hot streaks before lines catch up. */
export const NHL_CLAUDE_WEIGHTS: ClaudeEffectWeights7D = {
  SF: 0.12,
  NM: 0.22,   // Primary driver
  IAI: 0.15,
  CSI: 0.18,
  NIG: 0.10,
  TRD: 0.08,
  EPD: 0.15,
  REST: 0.10, // High impact (travel exhaustion)
};

/** NFL "Efficiency" ‚Äì IAI (sharp money) and CSI (injury/weather); Vegas-aware, selective bets. */
export const NFL_CLAUDE_WEIGHTS: ClaudeEffectWeights7D = {
  SF: 0.10,
  NM: 0.12,
  IAI: 0.25,   // Sharp money
  CSI: 0.20,   // Injuries/weather
  NIG: 0.08,
  TRD: 0.10,
  EPD: 0.15,
};

/** Default when league has no override (current engine defaults). */
export const CLAUDE_EFFECT_WEIGHTS_DEFAULT: ClaudeEffectWeights7D = {
  SF: 0.12,
  NM: 0.18,
  IAI: 0.20,
  CSI: 0.10,
  NIG: 0.12,
  TRD: 0.08,
  EPD: 0.18,
};

/** Select weights by league. */
export function getWeightsForLeague(league: string): ClaudeEffectWeights7D {
  switch ((league || '').toUpperCase()) {
    case 'NHL':
      return { ...NHL_CLAUDE_WEIGHTS };
    case 'NFL':
      return { ...NFL_CLAUDE_WEIGHTS };
    default:
      return { ...CLAUDE_EFFECT_WEIGHTS_DEFAULT };
  }
}


=== END CONTENT ===


=== FILENAME (found alt): app/lib/monte-carlo-engine.ts ===
=== START CONTENT ===
/**
 * Monte Carlo Simulation Engine
 * Like Leans AI's "Remi" - runs thousands of simulations to remove human bias
 * 
 * Features:
 * - 1000-10000 simulations per game
 * - Multiple outcome distributions (normal, Poisson, beta)
 * - Injury-adjusted simulations
 * - Weather-adjusted simulations
 * - Spread/total probability distributions
 */

import { GameData, TeamStats } from './prediction-engine';

export interface MonteCarloConfig {
  iterations: number;        // Number of simulations (1000-10000)
  includeInjuries: boolean;  // Factor in injury impact
  includeWeather: boolean;   // Factor in weather impact
  homeAdvantage: number;     // Points advantage for home team (default: 3)
  varianceMultiplier: number; // How much randomness (default: 1.0)
}

export interface SimulationOutcome {
  homeScore: number;
  awayScore: number;
  homeWin: boolean;
  margin: number;
  total: number;
}

export interface MonteCarloResult {
  // Win probabilities
  homeWinProbability: number;
  awayWinProbability: number;
  
  // Spread analysis
  spreadProbabilities: {
    homeCovers: number;  // Probability home covers spread
    awayCovers: number;  // Probability away covers spread
    push: number;        // Probability of push
    averageMargin: number;
    marginStdDev: number;
  };
  
  // Total analysis
  totalProbabilities: {
    over: number;        // Probability over hits
    under: number;       // Probability under hits
    push: number;
    averageTotal: number;
    totalStdDev: number;
  };
  
  // Score predictions
  predictedScore: {
    home: number;
    away: number;
    homeRange: [number, number];  // 90% confidence interval
    awayRange: [number, number];
  };
  
  // Distribution data for charts
  scoreDistribution: {
    homeScores: number[];
    awayScores: number[];
    margins: number[];
    totals: number[];
  };
  
  // Metadata
  iterations: number;
  confidence: number;  // Based on win probability deviation from 50%
  simulationTime: number;
}

export interface ValueBet {
  type: 'moneyline' | 'spread' | 'total';
  side: string;
  line?: number;
  modelProbability: number;
  impliedProbability: number;
  edge: number;  // Edge percentage
  expectedValue: number;  // EV per $100 bet
  confidence: 'low' | 'medium' | 'high' | 'very_high';
  kellyFraction: number;  // Optimal bet size (Kelly Criterion)
  reasoning: string;
}

const DEFAULT_CONFIG: MonteCarloConfig = {
  iterations: 1000,
  includeInjuries: true,
  includeWeather: true,
  homeAdvantage: 3,
  varianceMultiplier: 1.0,
};

/**
 * Sport-specific scoring parameters
 */
const SPORT_PARAMS: Record<string, {
  avgScore: number;
  stdDev: number;
  minScore: number;
  maxScore: number;
  homeAdvantage: number;
}> = {
  NFL: { avgScore: 24, stdDev: 10, minScore: 0, maxScore: 60, homeAdvantage: 2.5 },
  NCAAF: { avgScore: 28, stdDev: 14, minScore: 0, maxScore: 70, homeAdvantage: 3.5 },
  NBA: { avgScore: 112, stdDev: 12, minScore: 70, maxScore: 150, homeAdvantage: 3.0 },
  NCAAB: { avgScore: 72, stdDev: 11, minScore: 40, maxScore: 110, homeAdvantage: 4.0 },
  NHL: { avgScore: 3, stdDev: 1.5, minScore: 0, maxScore: 10, homeAdvantage: 0.3 },
  MLB: { avgScore: 4.5, stdDev: 2.5, minScore: 0, maxScore: 15, homeAdvantage: 0.2 },
};

export class MonteCarloEngine {
  private config: MonteCarloConfig;

  constructor(config: Partial<MonteCarloConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Run full Monte Carlo simulation for a game
   */
  async simulate(
    gameData: GameData,
    spread?: number,
    total?: number,
    config?: Partial<MonteCarloConfig>
  ): Promise<MonteCarloResult> {
    const startTime = Date.now();
    const mergedConfig = { ...this.config, ...config };
    const iterations = mergedConfig.iterations;

    const sport = this.normalizeSport(gameData.sport || gameData.league);
    const params = SPORT_PARAMS[sport] || SPORT_PARAMS.NFL;

    // Calculate base scoring rates
    const { homeExpected, awayExpected, homeStdDev, awayStdDev } = 
      this.calculateBaseRates(gameData, params, mergedConfig);

    // Run simulations
    const outcomes: SimulationOutcome[] = [];
    
    for (let i = 0; i < iterations; i++) {
      const outcome = this.simulateSingleGame(
        homeExpected,
        awayExpected,
        homeStdDev,
        awayStdDev,
        params.minScore,
        params.maxScore
      );
      outcomes.push(outcome);
    }

    // Analyze results
    const result = this.analyzeOutcomes(
      outcomes,
      spread ?? gameData.odds?.spread ?? 0,
      total ?? gameData.odds?.total ?? params.avgScore * 2,
      iterations,
      startTime
    );

    return result;
  }

  /**
   * Calculate base scoring rates from team data
   */
  private calculateBaseRates(
    gameData: GameData,
    params: typeof SPORT_PARAMS.NFL,
    config: MonteCarloConfig
  ): {
    homeExpected: number;
    awayExpected: number;
    homeStdDev: number;
    awayStdDev: number;
  } {
    let homeExpected = params.avgScore;
    let awayExpected = params.avgScore;
    let homeStdDev = params.stdDev;
    let awayStdDev = params.stdDev;

    if (gameData.teamStats) {
      const { home, away } = gameData.teamStats;

      // Calculate offensive/defensive ratings
      const homeOffense = home.recentAvgPoints || 
        (home.pointsFor / Math.max(home.wins + home.losses, 1)) || 
        params.avgScore;
      const awayOffense = away.recentAvgPoints || 
        (away.pointsFor / Math.max(away.wins + away.losses, 1)) || 
        params.avgScore;
      const homeDefense = home.recentAvgAllowed || 
        (home.pointsAgainst / Math.max(home.wins + home.losses, 1)) || 
        params.avgScore;
      const awayDefense = away.recentAvgAllowed || 
        (away.pointsAgainst / Math.max(away.wins + away.losses, 1)) || 
        params.avgScore;

      // Expected points = (offensive rating + opponent's defensive rating) / 2
      homeExpected = (homeOffense + awayDefense) / 2;
      awayExpected = (awayOffense + homeDefense) / 2;

      // Adjust for ratings if available
      if (home.offensiveRating && home.defensiveRating) {
        homeExpected = homeExpected * (home.offensiveRating / 100);
      }
      if (away.offensiveRating && away.defensiveRating) {
        awayExpected = awayExpected * (away.offensiveRating / 100);
      }
    }

    // Apply home advantage
    homeExpected += config.homeAdvantage || params.homeAdvantage;

    // Apply injury adjustments
    if (config.includeInjuries && gameData.injuries) {
      const homeInjuryImpact = gameData.injuries.homeImpact || 0;
      const awayInjuryImpact = gameData.injuries.awayImpact || 0;
      
      homeExpected *= (1 - homeInjuryImpact);
      awayExpected *= (1 - awayInjuryImpact);
    }

    // Apply weather adjustments (reduces scoring in bad weather)
    if (config.includeWeather && gameData.weather) {
      const weatherImpact = this.calculateWeatherImpact(gameData.weather);
      homeExpected *= (1 - weatherImpact);
      awayExpected *= (1 - weatherImpact);
    }

    // Apply variance multiplier
    homeStdDev *= config.varianceMultiplier;
    awayStdDev *= config.varianceMultiplier;

    return { homeExpected, awayExpected, homeStdDev, awayStdDev };
  }

  /**
   * Calculate weather impact on scoring (0-0.2 reduction)
   */
  private calculateWeatherImpact(weather: GameData['weather']): number {
    if (!weather) return 0;

    let impact = 0;

    // Precipitation impact
    const conditions = (weather.conditions || '').toLowerCase();
    if (conditions.includes('rain') || conditions.includes('snow')) {
      impact += 0.08;
    }
    if (conditions.includes('heavy')) {
      impact += 0.05;
    }

    // Wind impact
    if (weather.windSpeed) {
      if (weather.windSpeed > 20) impact += 0.05;
      if (weather.windSpeed > 30) impact += 0.05;
    }

    // Temperature impact (extreme cold)
    if (weather.temperature && weather.temperature < 20) {
      impact += 0.03;
    }

    return Math.min(impact, 0.2);
  }

  /**
   * Simulate a single game outcome
   */
  private simulateSingleGame(
    homeExpected: number,
    awayExpected: number,
    homeStdDev: number,
    awayStdDev: number,
    minScore: number,
    maxScore: number
  ): SimulationOutcome {
    // Generate scores using normal distribution
    const homeScore = this.clamp(
      this.normalRandom(homeExpected, homeStdDev),
      minScore,
      maxScore
    );
    const awayScore = this.clamp(
      this.normalRandom(awayExpected, awayStdDev),
      minScore,
      maxScore
    );

    // Round to reasonable values
    const roundedHome = Math.round(homeScore);
    const roundedAway = Math.round(awayScore);

    return {
      homeScore: roundedHome,
      awayScore: roundedAway,
      homeWin: roundedHome > roundedAway,
      margin: roundedHome - roundedAway,
      total: roundedHome + roundedAway,
    };
  }

  /**
   * Analyze simulation outcomes
   */
  private analyzeOutcomes(
    outcomes: SimulationOutcome[],
    spread: number,
    total: number,
    iterations: number,
    startTime: number
  ): MonteCarloResult {
    const n = outcomes.length;

    // Win probabilities
    const homeWins = outcomes.filter(o => o.homeWin).length;
    const homeWinProb = homeWins / n;
    const awayWinProb = 1 - homeWinProb;

    // Extract arrays for analysis
    const margins = outcomes.map(o => o.margin);
    const totals = outcomes.map(o => o.total);
    const homeScores = outcomes.map(o => o.homeScore);
    const awayScores = outcomes.map(o => o.awayScore);

    // Spread analysis (positive spread means home is underdog)
    const homeCoversCount = outcomes.filter(o => o.margin > spread).length;
    const pushCount = outcomes.filter(o => o.margin === spread).length;
    const awayCoversCount = n - homeCoversCount - pushCount;

    // Total analysis
    const overCount = outcomes.filter(o => o.total > total).length;
    const totalPushCount = outcomes.filter(o => o.total === total).length;
    const underCount = n - overCount - totalPushCount;

    // Statistics
    const avgMargin = this.average(margins);
    const marginStdDev = this.standardDeviation(margins);
    const avgTotal = this.average(totals);
    const totalStdDev = this.standardDeviation(totals);
    const avgHome = this.average(homeScores);
    const avgAway = this.average(awayScores);

    // Confidence intervals (90%)
    const sortedHome = [...homeScores].sort((a, b) => a - b);
    const sortedAway = [...awayScores].sort((a, b) => a - b);
    const lowIdx = Math.floor(n * 0.05);
    const highIdx = Math.floor(n * 0.95);

    // Calculate confidence based on win probability
    const confidence = Math.abs(homeWinProb - 0.5) * 2;

    return {
      homeWinProbability: homeWinProb,
      awayWinProbability: awayWinProb,
      
      spreadProbabilities: {
        homeCovers: homeCoversCount / n,
        awayCovers: awayCoversCount / n,
        push: pushCount / n,
        averageMargin: avgMargin,
        marginStdDev: marginStdDev,
      },
      
      totalProbabilities: {
        over: overCount / n,
        under: underCount / n,
        push: totalPushCount / n,
        averageTotal: avgTotal,
        totalStdDev: totalStdDev,
      },
      
      predictedScore: {
        home: Math.round(avgHome),
        away: Math.round(avgAway),
        homeRange: [sortedHome[lowIdx], sortedHome[highIdx]],
        awayRange: [sortedAway[lowIdx], sortedAway[highIdx]],
      },
      
      scoreDistribution: {
        homeScores,
        awayScores,
        margins,
        totals,
      },
      
      iterations,
      confidence,
      simulationTime: Date.now() - startTime,
    };
  }

  /**
   * Detect value bets from simulation results
   */
  detectValueBets(
    result: MonteCarloResult,
    odds: GameData['odds'],
    homeTeam: string,
    awayTeam: string,
    spread?: number,
    total?: number
  ): ValueBet[] {
    const valueBets: ValueBet[] = [];

    // Check moneyline value
    const homeImplied = this.americanToImplied(odds.home);
    const awayImplied = this.americanToImplied(odds.away);
    
    // Home moneyline
    const homeEdge = (result.homeWinProbability - homeImplied) * 100;
    if (homeEdge > 3) {  // Minimum 3% edge
      valueBets.push({
        type: 'moneyline',
        side: homeTeam,
        modelProbability: result.homeWinProbability,
        impliedProbability: homeImplied,
        edge: homeEdge,
        expectedValue: this.calculateEV(result.homeWinProbability, odds.home),
        confidence: this.edgeToConfidence(homeEdge),
        kellyFraction: this.kellyFraction(result.homeWinProbability, odds.home),
        reasoning: `Model: ${(result.homeWinProbability * 100).toFixed(1)}% vs Market: ${(homeImplied * 100).toFixed(1)}%`,
      });
    }

    // Away moneyline
    const awayEdge = (result.awayWinProbability - awayImplied) * 100;
    if (awayEdge > 3) {
      valueBets.push({
        type: 'moneyline',
        side: awayTeam,
        modelProbability: result.awayWinProbability,
        impliedProbability: awayImplied,
        edge: awayEdge,
        expectedValue: this.calculateEV(result.awayWinProbability, odds.away),
        confidence: this.edgeToConfidence(awayEdge),
        kellyFraction: this.kellyFraction(result.awayWinProbability, odds.away),
        reasoning: `Model: ${(result.awayWinProbability * 100).toFixed(1)}% vs Market: ${(awayImplied * 100).toFixed(1)}%`,
      });
    }

    // Spread value (assuming -110 standard)
    const spreadOdds = -110;
    const spreadImplied = this.americanToImplied(spreadOdds);

    // Home covers spread
    const homeSpreadEdge = (result.spreadProbabilities.homeCovers - spreadImplied) * 100;
    if (homeSpreadEdge > 3) {
      valueBets.push({
        type: 'spread',
        side: homeTeam,
        line: spread ?? odds.spread ?? 0,
        modelProbability: result.spreadProbabilities.homeCovers,
        impliedProbability: spreadImplied,
        edge: homeSpreadEdge,
        expectedValue: this.calculateEV(result.spreadProbabilities.homeCovers, spreadOdds),
        confidence: this.edgeToConfidence(homeSpreadEdge),
        kellyFraction: this.kellyFraction(result.spreadProbabilities.homeCovers, spreadOdds),
        reasoning: `Model: ${(result.spreadProbabilities.homeCovers * 100).toFixed(1)}% to cover ${spread ?? odds.spread ?? 0}`,
      });
    }

    // Away covers spread
    const awaySpreadEdge = (result.spreadProbabilities.awayCovers - spreadImplied) * 100;
    if (awaySpreadEdge > 3) {
      valueBets.push({
        type: 'spread',
        side: awayTeam,
        line: -(spread ?? odds.spread ?? 0),
        modelProbability: result.spreadProbabilities.awayCovers,
        impliedProbability: spreadImplied,
        edge: awaySpreadEdge,
        expectedValue: this.calculateEV(result.spreadProbabilities.awayCovers, spreadOdds),
        confidence: this.edgeToConfidence(awaySpreadEdge),
        kellyFraction: this.kellyFraction(result.spreadProbabilities.awayCovers, spreadOdds),
        reasoning: `Model: ${(result.spreadProbabilities.awayCovers * 100).toFixed(1)}% to cover ${-(spread ?? odds.spread ?? 0)}`,
      });
    }

    // Over/Under value
    const totalLine = total ?? odds.total ?? 44;
    
    // Over
    const overEdge = (result.totalProbabilities.over - spreadImplied) * 100;
    if (overEdge > 3) {
      valueBets.push({
        type: 'total',
        side: 'Over',
        line: totalLine,
        modelProbability: result.totalProbabilities.over,
        impliedProbability: spreadImplied,
        edge: overEdge,
        expectedValue: this.calculateEV(result.totalProbabilities.over, spreadOdds),
        confidence: this.edgeToConfidence(overEdge),
        kellyFraction: this.kellyFraction(result.totalProbabilities.over, spreadOdds),
        reasoning: `Model: ${(result.totalProbabilities.over * 100).toFixed(1)}% over ${totalLine} (avg: ${result.totalProbabilities.averageTotal.toFixed(1)})`,
      });
    }

    // Under
    const underEdge = (result.totalProbabilities.under - spreadImplied) * 100;
    if (underEdge > 3) {
      valueBets.push({
        type: 'total',
        side: 'Under',
        line: totalLine,
        modelProbability: result.totalProbabilities.under,
        impliedProbability: spreadImplied,
        edge: underEdge,
        expectedValue: this.calculateEV(result.totalProbabilities.under, spreadOdds),
        confidence: this.edgeToConfidence(underEdge),
        kellyFraction: this.kellyFraction(result.totalProbabilities.under, spreadOdds),
        reasoning: `Model: ${(result.totalProbabilities.under * 100).toFixed(1)}% under ${totalLine} (avg: ${result.totalProbabilities.averageTotal.toFixed(1)})`,
      });
    }

    // Sort by edge (best value first)
    return valueBets.sort((a, b) => b.edge - a.edge);
  }

  // ========== Utility Functions ==========

  private normalRandom(mean: number, stdDev: number): number {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + z0 * stdDev;
  }

  private clamp(value: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, value));
  }

  private average(arr: number[]): number {
    return arr.reduce((a, b) => a + b, 0) / arr.length;
  }

  private standardDeviation(arr: number[]): number {
    const avg = this.average(arr);
    const variance = arr.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / arr.length;
    return Math.sqrt(variance);
  }

  private americanToImplied(odds: number): number {
    if (odds > 0) {
      return 100 / (odds + 100);
    } else {
      return Math.abs(odds) / (Math.abs(odds) + 100);
    }
  }

  private calculateEV(probability: number, odds: number): number {
    // EV = (probability * profit) - (1 - probability) * stake
    // For $100 bet
    let profit: number;
    if (odds > 0) {
      profit = odds;
    } else {
      profit = 100 / (Math.abs(odds) / 100);
    }
    return (probability * profit) - ((1 - probability) * 100);
  }

  private kellyFraction(probability: number, odds: number): number {
    // Kelly = (bp - q) / b
    // b = decimal odds - 1
    // p = probability of winning
    // q = 1 - p
    const decimalOdds = odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1;
    const b = decimalOdds - 1;
    const p = probability;
    const q = 1 - p;
    
    const kelly = (b * p - q) / b;
    // Cap at 25% of bankroll (quarter Kelly for safety)
    return Math.max(0, Math.min(kelly * 0.25, 0.25));
  }

  private edgeToConfidence(edge: number): 'low' | 'medium' | 'high' | 'very_high' {
    if (edge >= 10) return 'very_high';
    if (edge >= 7) return 'high';
    if (edge >= 5) return 'medium';
    return 'low';
  }

  private normalizeSport(sport: string): string {
    const upper = sport.toUpperCase();
    if (upper.includes('NCAAF') || upper.includes('CFB') || upper.includes('COLLEGE FOOTBALL')) {
      return 'NCAAF';
    }
    if (upper.includes('NCAAB') || upper.includes('CBB') || upper.includes('COLLEGE BASKETBALL')) {
      return 'NCAAB';
    }
    return upper;
  }
}

// Export singleton
export const monteCarloEngine = new MonteCarloEngine();



=== END CONTENT ===


=== FILENAME: app/elite-fine-tuner/page.tsx ===
=== START CONTENT ===
'use client';

import { useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';

interface MethodWeights {
  statisticalModel: number;
  eloRating: number;
  recentForm: number;
  headToHead: number;
  marketEfficiency: number;
  weatherImpact: number;
  injuryImpact: number;
  homeAdvantage: number;
  momentum: number;
  machineLearning: number;
}

interface SimulationSettings {
  simulationCount: number;
  varianceFactor: number;
  confidenceThreshold: number;
  edgeThreshold: number;
}

export default function EliteFineTunerPage() {
  const router = useRouter();
  const [userTier, setUserTier] = useState<'free' | 'pro' | 'elite' | 'checking'>('checking');
  const [league, setLeague] = useState('NFL');
  const [loading, setLoading] = useState(false);
  const [results, setResults] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<'fine-tune' | 'parlay' | 'teaser'>('fine-tune');

  // Method weights (0-200, default 100 = 1.0x)
  const [weights, setWeights] = useState<MethodWeights>({
    statisticalModel: 100,
    eloRating: 100,
    recentForm: 100,
    headToHead: 100,
    marketEfficiency: 120,
    weatherImpact: 60,
    injuryImpact: 80,
    homeAdvantage: 70,
    momentum: 90,
    machineLearning: 150,
  });

  // Simulation settings
  const [simSettings, setSimSettings] = useState<SimulationSettings>({
    simulationCount: 500,
    varianceFactor: 150, // 1.5x default
    confidenceThreshold: 60,
    edgeThreshold: 2.0,
  });

  // Parlay/Teaser settings
  const [parlayLegs, setParlayLegs] = useState(3);
  const [teaserLegs, setTeaserLegs] = useState(2);
  const [teaserPoints, setTeaserPoints] = useState(6);

  // Bankroll management
  const [bankroll, setBankroll] = useState('1000');
  const [riskProfile, setRiskProfile] = useState<'conservative' | 'balanced' | 'aggressive'>('balanced');

  const updateWeight = (key: keyof MethodWeights, value: number) => {
    setWeights(prev => ({ ...prev, [key]: value }));
  };

  const updateSimSetting = (key: keyof SimulationSettings, value: number) => {
    setSimSettings(prev => ({ ...prev, [key]: value }));
  };

  // Check user tier on mount
  useEffect(() => {
    async function checkUserTier() {
      try {
        // Try to get email from localStorage/sessionStorage (if coming from prognostication)
        const email = typeof window !== 'undefined'
          ? (localStorage.getItem('user_email') || sessionStorage.getItem('user_email'))
          : null;
        const sessionId = typeof window !== 'undefined'
          ? new URLSearchParams(window.location.search).get('session_id')
          : null;

        if (email || sessionId) {
          // Check with prognostication API if available
          const prognoUrl = process.env.NEXT_PUBLIC_PROGNO_BASE_URL || 'https://prognostication.com';
          const params = new URLSearchParams();
          if (email) params.set('email', email);
          if (sessionId) params.set('session_id', sessionId);

          try {
            const res = await fetch(`${prognoUrl}/api/user/tier?${params.toString()}`);
            const data = await res.json();
            if (data?.tier) {
              setUserTier(data.tier);
              if (data.tier !== 'elite') {
                // Not elite, show access denied
                return;
              }
            } else {
              setUserTier('free');
            }
          } catch (err) {
            console.warn('Could not verify tier, allowing access for development');
            setUserTier('elite'); // Allow in development
          }
        } else {
          // No auth info, assume free tier
          setUserTier('free');
        }
      } catch (err) {
        console.error('Error checking user tier:', err);
        setUserTier('free');
      }
    }
    checkUserTier();
  }, []);

  const handleFineTune = async () => {
    setLoading(true);
    setError(null);
    setResults(null);

    try {
      // Get today and tomorrow's games
      const today = new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const todayStr = today.toISOString().split('T')[0];
      const tomorrowStr = tomorrow.toISOString().split('T')[0];

      const sportMap: Record<string, string> = {
        'NFL': 'americanfootball_nfl',
        'NBA': 'basketball_nba',
        'MLB': 'baseball_mlb',
        'NHL': 'icehockey_nhl',
        'NCAAF': 'americanfootball_ncaaf',
        'NCAAB': 'basketball_ncaab',
      };

      const sportKey = sportMap[league] || 'americanfootball_nfl';

      // Fetch games
      const oddsResponse = await fetch(`/api/progno/odds?sport=${sportKey}&dateFrom=${todayStr}&dateTo=${tomorrowStr}`);
      if (!oddsResponse.ok) {
        throw new Error('Failed to fetch games');
      }

      const games = await oddsResponse.json();
      const filteredGames = games.filter((game: any) => {
        if (!game.commence_time) return false;
        const gameDate = new Date(game.commence_time).toISOString().split('T')[0];
        return gameDate === todayStr || gameDate === tomorrowStr;
      });

      if (filteredGames.length === 0) {
        throw new Error('No games found for selected dates');
      }

      // Analyze games with custom weights
      const analysisResults = [];
      for (const game of filteredGames.slice(0, 10)) { // Limit to 10 games for performance
        try {
          const analyzeResponse = await fetch('/api/progno/elite-analyze', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              gameData: game,
              simulationCount: simSettings.simulationCount,
              varianceFactor: simSettings.varianceFactor / 100, // Convert to decimal
              methodWeights: {
                'statistical-model': weights.statisticalModel / 100,
                'elo-rating': weights.eloRating / 100,
                'recent-form': weights.recentForm / 100,
                'head-to-head': weights.headToHead / 100,
                'market-efficiency': weights.marketEfficiency / 100,
                'weather-impact': weights.weatherImpact / 100,
                'injury-impact': weights.injuryImpact / 100,
                'home-advantage': weights.homeAdvantage / 100,
                'momentum': weights.momentum / 100,
                'machine-learning': weights.machineLearning / 100,
              },
              confidenceThreshold: simSettings.confidenceThreshold / 100,
              edgeThreshold: simSettings.edgeThreshold,
              bankroll: parseFloat(bankroll) || 1000,
              riskProfile: riskProfile,
            }),
          });

          if (analyzeResponse.ok) {
            const data = await analyzeResponse.json();
            if (data.confidence >= simSettings.confidenceThreshold && Math.abs(data.edge) >= simSettings.edgeThreshold) {
              analysisResults.push({
                game: `${game.away_team} @ ${game.home_team}`,
                ...data,
              });
            }
          }
        } catch (err) {
          console.error(`Error analyzing game ${game.id}:`, err);
        }
      }

      setResults({
        gamesAnalyzed: filteredGames.length,
        picksGenerated: analysisResults.length,
        picks: analysisResults.sort((a, b) => b.confidence - a.confidence),
      });
    } catch (err: any) {
      setError(err.message || 'Failed to analyze games');
    } finally {
      setLoading(false);
    }
  };

  const handleGetParlay = async () => {
    setLoading(true);
    setError(null);
    setResults(null);

    try {
      // Use new API v2.0 endpoint
      const response = await fetch('/api/progno/v2?action=parlay', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          numberOfLegs: parlayLegs,
          minConfidence: simSettings.confidenceThreshold,
          minEdge: simSettings.edgeThreshold,
        }),
      });

      const data = await response.json();
      if (data.success) {
        setResults(data);
      } else {
        setError(data.error || 'Failed to generate parlay');
      }
    } catch (err: any) {
      setError(err.message || 'Failed to get parlay suggestion');
    } finally {
      setLoading(false);
    }
  };

  const handleGetTeaser = async () => {
    setLoading(true);
    setError(null);
    setResults(null);

    try {
      // Use new API v2.0 endpoint
      const response = await fetch('/api/progno/v2?action=teaser', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          numberOfLegs: teaserLegs,
          points: teaserPoints,
          minConfidence: simSettings.confidenceThreshold,
        }),
      });

      const data = await response.json();
      if (data.success) {
        setResults(data);
      } else {
        setError(data.error || 'Failed to generate teaser');
      }
    } catch (err: any) {
      setError(err.message || 'Failed to get teaser suggestion');
    } finally {
      setLoading(false);
    }
  };

  // Show access denied for non-elite users
  if (userTier === 'checking') {
    return (
      <div style={{
        minHeight: '100vh',
        background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: 'white',
      }}>
        <div style={{ textAlign: 'center' }}>
          <div style={{ fontSize: '2rem', marginBottom: '1rem' }}>‚è≥</div>
          <div>Checking access...</div>
        </div>
      </div>
    );
  }

  if (userTier !== 'elite') {
    return (
      <div style={{
        minHeight: '100vh',
        background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: 'white',
        padding: '2rem',
      }}>
        <div style={{
          textAlign: 'center',
          maxWidth: '600px',
          background: 'rgba(0, 0, 0, 0.3)',
          padding: '3rem',
          borderRadius: '16px',
          border: '2px solid rgba(255, 107, 0, 0.5)',
        }}>
          <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>üîí</div>
          <h1 style={{ fontSize: '2.5rem', fontWeight: 'bold', marginBottom: '1rem' }}>
            Elite Access Required
          </h1>
          <p style={{ fontSize: '1.25rem', color: 'rgba(255, 255, 255, 0.8)', marginBottom: '2rem' }}>
            The Elite Bet Fine-Tuner is exclusively available for Elite tier subscribers.
          </p>
          <p style={{ fontSize: '1rem', color: 'rgba(255, 255, 255, 0.7)', marginBottom: '2rem' }}>
            Upgrade to Elite to unlock advanced prediction customization, factor weight adjustments, and unlimited simulations.
          </p>
          <a
            href="https://prognostication.com/pricing"
            target="_blank"
            rel="noopener noreferrer"
            style={{
              display: 'inline-block',
              background: 'linear-gradient(135deg, #ff6b00 0%, #ffab00 100%)',
              color: '#000',
              padding: '1rem 2rem',
              borderRadius: '8px',
              fontSize: '1.125rem',
              fontWeight: 'bold',
              textDecoration: 'none',
              boxShadow: '0 4px 6px rgba(0, 0, 0, 0.3)',
              cursor: 'pointer',
            }}
          >
            Upgrade to Elite ‚Üí
          </a>
        </div>
      </div>
    );
  }

  return (
    <div style={{
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%)',
      padding: '2rem',
      color: 'white',
    }}>
      <div style={{ maxWidth: '1400px', margin: '0 auto' }}>
        {/* Header */}
        <div style={{ marginBottom: '2rem' }}>
          <button
            onClick={() => router.push('/')}
            style={{
              background: 'rgba(255, 255, 255, 0.1)',
              border: 'none',
              padding: '0.75rem 1.5rem',
              borderRadius: '8px',
              color: 'white',
              cursor: 'pointer',
              marginBottom: '1rem',
            }}
          >
            ‚Üê Back to Home
          </button>
          <h1 style={{ fontSize: '3rem', fontWeight: 'bold', marginBottom: '0.5rem' }}>
            ‚ö° Elite Fine-Tuner
          </h1>
          <p style={{ fontSize: '1.125rem', color: 'rgba(255, 255, 255, 0.7)' }}>
            Advanced prediction engine tuning for Elite users only
          </p>
        </div>

        {/* Tab Navigation */}
        <div style={{
          display: 'flex',
          gap: '1rem',
          marginBottom: '2rem',
          borderBottom: '2px solid rgba(255, 255, 255, 0.1)',
        }}>
          {[
            { id: 'fine-tune', label: 'üéØ Fine-Tune Engine', icon: '‚öôÔ∏è' },
            { id: 'parlay', label: 'üé≤ Best Parlay', icon: 'üé≤' },
            { id: 'teaser', label: 'üéØ Best Teaser', icon: 'üéØ' },
          ].map(tab => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id as any)}
              style={{
                padding: '1rem 2rem',
                background: activeTab === tab.id
                  ? 'linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%)'
                  : 'transparent',
                border: 'none',
                borderRadius: '8px 8px 0 0',
                color: 'white',
                cursor: 'pointer',
                fontSize: '1rem',
                fontWeight: 'bold',
                borderBottom: activeTab === tab.id ? '3px solid #60a5fa' : 'none',
              }}
            >
              {tab.icon} {tab.label}
            </button>
          ))}
        </div>

        {/* Fine-Tune Tab */}
        {activeTab === 'fine-tune' && (
          <div style={{
            display: 'grid',
            gridTemplateColumns: '1fr 1fr',
            gap: '2rem',
          }}>
            {/* Left Column - Method Weights */}
            <div style={{
              background: 'rgba(255, 255, 255, 0.05)',
              borderRadius: '16px',
              padding: '2rem',
            }}>
              <h2 style={{ fontSize: '1.5rem', marginBottom: '1.5rem', color: '#60a5fa' }}>
                üìä Prediction Method Weights
              </h2>
              <p style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.6)', marginBottom: '1.5rem' }}>
                Adjust how much each prediction method influences the final result. 100 = default weight.
              </p>

              {Object.entries(weights).map(([key, value]) => (
                <div key={key} style={{ marginBottom: '1.5rem' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                    <label style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.9)' }}>
                      {key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}
                    </label>
                    <span style={{ fontSize: '0.875rem', color: '#60a5fa', fontWeight: 'bold' }}>
                      {value}%
                    </span>
                  </div>
                  <input
                    type="range"
                    min="0"
                    max="200"
                    value={value}
                    onChange={(e) => updateWeight(key as keyof MethodWeights, parseInt(e.target.value))}
                    style={{
                      width: '100%',
                      height: '8px',
                      borderRadius: '4px',
                      background: 'rgba(255, 255, 255, 0.2)',
                      outline: 'none',
                    }}
                  />
                  <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.5)', marginTop: '0.25rem' }}>
                    <span>0% (Disabled)</span>
                    <span>200% (2x Weight)</span>
                  </div>
                </div>
              ))}
            </div>

            {/* Right Column - Simulation Settings */}
            <div style={{
              background: 'rgba(255, 255, 255, 0.05)',
              borderRadius: '16px',
              padding: '2rem',
            }}>
              <h2 style={{ fontSize: '1.5rem', marginBottom: '1.5rem', color: '#10b981' }}>
                üé≤ Simulation Settings
              </h2>

              <div style={{ marginBottom: '1.5rem' }}>
                <label style={{ display: 'block', fontSize: '0.875rem', marginBottom: '0.5rem', color: 'rgba(255, 255, 255, 0.9)' }}>
                  League
                </label>
                <select
                  value={league}
                  onChange={(e) => setLeague(e.target.value)}
                  style={{
                    width: '100%',
                    padding: '0.75rem',
                    borderRadius: '8px',
                    border: '2px solid rgba(255, 255, 255, 0.2)',
                    background: 'rgba(255, 255, 255, 0.95)',
                    color: '#1a1a1a',
                    fontSize: '1rem',
                  }}
                >
                  <option value="NFL">NFL</option>
                  <option value="NBA">NBA</option>
                  <option value="MLB">MLB</option>
                  <option value="NHL">NHL</option>
                </select>
              </div>

              <div style={{ marginBottom: '1.5rem' }}>
                <label style={{ display: 'block', fontSize: '0.875rem', marginBottom: '0.5rem', color: 'rgba(255, 255, 255, 0.9)' }}>
                  Bankroll ($)
                </label>
                <input
                  type="number"
                  value={bankroll}
                  onChange={(e) => setBankroll(e.target.value)}
                  min="100"
                  step="100"
                  style={{
                    width: '100%',
                    padding: '0.75rem',
                    borderRadius: '8px',
                    border: '2px solid rgba(255, 255, 255, 0.2)',
                    background: 'rgba(255, 255, 255, 0.95)',
                    color: '#1a1a1a',
                    fontSize: '1rem',
                  }}
                />
                <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.5)', marginTop: '0.25rem' }}>
                  Total bankroll for bet sizing calculations
                </div>
              </div>

              <div style={{ marginBottom: '1.5rem' }}>
                <label style={{ display: 'block', fontSize: '0.875rem', marginBottom: '0.5rem', color: 'rgba(255, 255, 255, 0.9)' }}>
                  Risk Profile
                </label>
                <select
                  value={riskProfile}
                  onChange={(e) => setRiskProfile(e.target.value as any)}
                  style={{
                    width: '100%',
                    padding: '0.75rem',
                    borderRadius: '8px',
                    border: '2px solid rgba(255, 255, 255, 0.2)',
                    background: 'rgba(255, 255, 255, 0.95)',
                    color: '#1a1a1a',
                    fontSize: '1rem',
                  }}
                >
                  <option value="conservative">Conservative (25% Kelly)</option>
                  <option value="balanced">Balanced (50% Kelly)</option>
                  <option value="aggressive">Aggressive (75% Kelly)</option>
                </select>
                <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.5)', marginTop: '0.25rem' }}>
                  Controls bet size relative to Kelly Criterion
                </div>
              </div>

              {Object.entries(simSettings).map(([key, value]) => (
                <div key={key} style={{ marginBottom: '1.5rem' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                    <label style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.9)' }}>
                      {key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}
                    </label>
                    <span style={{ fontSize: '0.875rem', color: '#10b981', fontWeight: 'bold' }}>
                      {key === 'confidenceThreshold' || key === 'edgeThreshold'
                        ? (key === 'confidenceThreshold' ? `${value}%` : `${value}%`)
                        : key === 'varianceFactor' ? `${value}%` : value}
                    </span>
                  </div>
                  <input
                    type="range"
                    min={key === 'simulationCount' ? 10 : key === 'varianceFactor' ? 50 : key === 'confidenceThreshold' ? 50 : 0}
                    max={key === 'simulationCount' ? 1000 : key === 'varianceFactor' ? 300 : key === 'confidenceThreshold' ? 90 : key === 'edgeThreshold' ? 10 : 100}
                    step={key === 'simulationCount' ? 10 : key === 'varianceFactor' ? 5 : key === 'confidenceThreshold' ? 1 : key === 'edgeThreshold' ? 0.1 : 1}
                    value={value}
                    onChange={(e) => updateSimSetting(key as keyof SimulationSettings, parseFloat(e.target.value))}
                    style={{
                      width: '100%',
                      height: '8px',
                      borderRadius: '4px',
                      background: 'rgba(255, 255, 255, 0.2)',
                      outline: 'none',
                    }}
                  />
                  <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.5)', marginTop: '0.25rem' }}>
                    {key === 'simulationCount' && 'More simulations = more accurate but slower'}
                    {key === 'varianceFactor' && 'Higher variance = more diverse simulation outcomes'}
                    {key === 'confidenceThreshold' && 'Minimum confidence to include in picks'}
                    {key === 'edgeThreshold' && 'Minimum edge percentage to include'}
                  </div>
                </div>
              ))}

              <button
                onClick={handleFineTune}
                disabled={loading}
                style={{
                  width: '100%',
                  padding: '1rem',
                  fontSize: '1.125rem',
                  fontWeight: 'bold',
                  background: loading ? '#64748b' : 'linear-gradient(135deg, #10b981 0%, #059669 100%)',
                  color: 'white',
                  border: 'none',
                  borderRadius: '12px',
                  cursor: loading ? 'not-allowed' : 'pointer',
                  marginTop: '1rem',
                }}
              >
                {loading ? '‚è≥ Analyzing...' : 'üöÄ Run Fine-Tuned Analysis'}
              </button>
            </div>
          </div>
        )}

        {/* Parlay Tab */}
        {activeTab === 'parlay' && (
          <div style={{
            background: 'rgba(255, 255, 255, 0.05)',
            borderRadius: '16px',
            padding: '2rem',
          }}>
            <h2 style={{ fontSize: '1.5rem', marginBottom: '1.5rem', color: '#a78bfa' }}>
              üé≤ Best Parlay Recommendation
            </h2>
            <p style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.6)', marginBottom: '2rem' }}>
              Get Progno's best parlay recommendation based on your settings
            </p>

            <div style={{ marginBottom: '1.5rem' }}>
              <label style={{ display: 'block', fontSize: '0.875rem', marginBottom: '0.5rem', color: 'rgba(255, 255, 255, 0.9)' }}>
                Number of Legs: {parlayLegs}
              </label>
              <input
                type="range"
                min="2"
                max="5"
                value={parlayLegs}
                onChange={(e) => setParlayLegs(parseInt(e.target.value))}
                style={{
                  width: '100%',
                  height: '8px',
                  borderRadius: '4px',
                  background: 'rgba(255, 255, 255, 0.2)',
                  outline: 'none',
                }}
              />
              <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.5)', marginTop: '0.25rem' }}>
                <span>2 legs</span>
                <span>5 legs</span>
              </div>
            </div>

            <button
              onClick={handleGetParlay}
              disabled={loading}
              style={{
                width: '100%',
                padding: '1rem',
                fontSize: '1.125rem',
                fontWeight: 'bold',
                background: loading ? '#64748b' : 'linear-gradient(135deg, #a78bfa 0%, #7c3aed 100%)',
                color: 'white',
                border: 'none',
                borderRadius: '12px',
                cursor: loading ? 'not-allowed' : 'pointer',
              }}
            >
              {loading ? '‚è≥ Generating Parlay...' : 'üé≤ Get Best Parlay'}
            </button>
          </div>
        )}

        {/* Teaser Tab */}
        {activeTab === 'teaser' && (
          <div style={{
            background: 'rgba(255, 255, 255, 0.05)',
            borderRadius: '16px',
            padding: '2rem',
          }}>
            <h2 style={{ fontSize: '1.5rem', marginBottom: '1.5rem', color: '#f59e0b' }}>
              üéØ Best Teaser Recommendation
            </h2>
            <p style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.6)', marginBottom: '2rem' }}>
              Get Progno's best teaser recommendation with adjusted spreads/totals
            </p>

            <div style={{ marginBottom: '1.5rem' }}>
              <label style={{ display: 'block', fontSize: '0.875rem', marginBottom: '0.5rem', color: 'rgba(255, 255, 255, 0.9)' }}>
                Number of Legs: {teaserLegs}
              </label>
              <input
                type="range"
                min="2"
                max="4"
                value={teaserLegs}
                onChange={(e) => setTeaserLegs(parseInt(e.target.value))}
                style={{
                  width: '100%',
                  height: '8px',
                  borderRadius: '4px',
                  background: 'rgba(255, 255, 255, 0.2)',
                  outline: 'none',
                }}
              />
            </div>

            <div style={{ marginBottom: '1.5rem' }}>
              <label style={{ display: 'block', fontSize: '0.875rem', marginBottom: '0.5rem', color: 'rgba(255, 255, 255, 0.9)' }}>
                Teaser Points: {teaserPoints}
              </label>
              <input
                type="range"
                min="4"
                max="10"
                step="0.5"
                value={teaserPoints}
                onChange={(e) => setTeaserPoints(parseFloat(e.target.value))}
                style={{
                  width: '100%',
                  height: '8px',
                  borderRadius: '4px',
                  background: 'rgba(255, 255, 255, 0.2)',
                  outline: 'none',
                }}
              />
              <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.5)', marginTop: '0.25rem' }}>
                <span>4 points</span>
                <span>10 points</span>
              </div>
            </div>

            <button
              onClick={handleGetTeaser}
              disabled={loading}
              style={{
                width: '100%',
                padding: '1rem',
                fontSize: '1.125rem',
                fontWeight: 'bold',
                background: loading ? '#64748b' : 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                color: 'white',
                border: 'none',
                borderRadius: '12px',
                cursor: loading ? 'not-allowed' : 'pointer',
              }}
            >
              {loading ? '‚è≥ Generating Teaser...' : 'üéØ Get Best Teaser'}
            </button>
          </div>
        )}

        {/* Error Display */}
        {error && (
          <div style={{
            marginTop: '2rem',
            padding: '1rem',
            background: 'rgba(239, 68, 68, 0.2)',
            border: '1px solid rgba(239, 68, 68, 0.3)',
            borderRadius: '8px',
            color: '#fca5a5',
          }}>
            ‚ùå {error}
          </div>
        )}

        {/* Results Display */}
        {results && (
          <div style={{
            marginTop: '2rem',
            background: 'rgba(255, 255, 255, 0.05)',
            borderRadius: '16px',
            padding: '2rem',
          }}>
            {activeTab === 'fine-tune' && results.picks && (
              <>
                <h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', color: '#10b981' }}>
                  üìä Analysis Results
                </h2>
                <div style={{ marginBottom: '1.5rem', fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.7)' }}>
                  Analyzed {results.gamesAnalyzed} games ‚Ä¢ Generated {results.picksGenerated} picks
                </div>
                {results.picks.length > 0 ? (
                  <div style={{ display: 'grid', gap: '1rem' }}>
                    {results.picks.map((pick: any, index: number) => (
                      <div
                        key={index}
                        style={{
                          background: 'rgba(255, 255, 255, 0.1)',
                          borderRadius: '12px',
                          padding: '1.5rem',
                          border: '1px solid rgba(255, 255, 255, 0.2)',
                        }}
                      >
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '0.75rem' }}>
                          <div>
                            <div style={{ fontSize: '1.125rem', fontWeight: 'bold', marginBottom: '0.25rem' }}>
                              {pick.game}
                            </div>
                            <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#60a5fa' }}>
                              {pick.recommendedPick || 'TBD'}
                            </div>
                          </div>
                        </div>
                        <div style={{ display: 'flex', gap: '1.5rem', fontSize: '0.875rem', flexWrap: 'wrap' }}>
                          <div>
                            <span style={{ color: 'rgba(255, 255, 255, 0.6)' }}>Confidence: </span>
                            <span style={{ color: '#60a5fa', fontWeight: 'bold' }}>{pick.confidence}%</span>
                          </div>
                          <div>
                            <span style={{ color: 'rgba(255, 255, 255, 0.6)' }}>Edge: </span>
                            <span style={{ color: '#10b981', fontWeight: 'bold' }}>{pick.edge > 0 ? '+' : ''}{pick.edge}%</span>
                          </div>
                          <div>
                            <span style={{ color: 'rgba(255, 255, 255, 0.6)' }}>Quality: </span>
                            <span style={{ color: '#a78bfa', fontWeight: 'bold' }}>{pick.quality?.toFixed(1)}</span>
                          </div>
                          {pick.recommendedWager !== undefined && (
                            <div>
                              <span style={{ color: 'rgba(255, 255, 255, 0.6)' }}>Wager: </span>
                              <span style={{ color: '#f59e0b', fontWeight: 'bold', fontSize: '1rem' }}>
                                ${pick.recommendedWager?.toLocaleString()}
                              </span>
                            </div>
                          )}
                        </div>
                        {pick.betReasoning && (
                          <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.5)', marginTop: '0.5rem', fontStyle: 'italic' }}>
                            {pick.betReasoning}
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                ) : (
                  <div style={{ textAlign: 'center', padding: '2rem', color: 'rgba(255, 255, 255, 0.6)' }}>
                    No picks met your confidence and edge thresholds. Try lowering them.
                  </div>
                )}
              </>
            )}

            {activeTab === 'parlay' && results.legs && (
              <>
                <h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', color: '#a78bfa' }}>
                  üé≤ Recommended Parlay ({results.legs.length} legs)
                </h2>
                <div style={{ marginBottom: '1.5rem', display: 'flex', gap: '1rem', fontSize: '0.875rem' }}>
                  <div>
                    <span style={{ color: 'rgba(255, 255, 255, 0.6)' }}>Total Confidence: </span>
                    <span style={{ color: '#a78bfa', fontWeight: 'bold' }}>
                      {(results.totalConfidence * 100).toFixed(1)}%
                    </span>
                  </div>
                  <div>
                    <span style={{ color: 'rgba(255, 255, 255, 0.6)' }}>Potential Payout: </span>
                    <span style={{ color: '#10b981', fontWeight: 'bold' }}>
                      {results.potentialPayout.toFixed(1)}x
                    </span>
                  </div>
                </div>
                <div style={{ display: 'grid', gap: '1rem' }}>
                  {results.legs.map((leg: any, index: number) => (
                    <div
                      key={index}
                      style={{
                        background: 'rgba(255, 255, 255, 0.1)',
                        borderRadius: '12px',
                        padding: '1rem',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                      }}
                    >
                      <div style={{ fontWeight: 'bold', marginBottom: '0.5rem' }}>Leg {index + 1}</div>
                      <div style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.9)' }}>
                        {leg.game}
                      </div>
                      <div style={{ fontSize: '1rem', color: '#a78bfa', fontWeight: 'bold', marginTop: '0.25rem' }}>
                        {leg.pick}
                      </div>
                      <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)', marginTop: '0.25rem' }}>
                        Confidence: {(leg.confidence * 100).toFixed(1)}%
                      </div>
                    </div>
                  ))}
                </div>
              </>
            )}

            {activeTab === 'teaser' && results.legs && (
              <>
                <h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', color: '#f59e0b' }}>
                  üéØ Recommended Teaser ({results.legs.length} legs, {results.points} points)
                </h2>
                <div style={{ marginBottom: '1.5rem', fontSize: '0.875rem' }}>
                  <span style={{ color: 'rgba(255, 255, 255, 0.6)' }}>Total Confidence: </span>
                  <span style={{ color: '#f59e0b', fontWeight: 'bold' }}>
                    {(results.totalConfidence * 100).toFixed(1)}%
                  </span>
                </div>
                <div style={{ display: 'grid', gap: '1rem' }}>
                  {results.legs.map((leg: any, index: number) => (
                    <div
                      key={index}
                      style={{
                        background: 'rgba(255, 255, 255, 0.1)',
                        borderRadius: '12px',
                        padding: '1rem',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                      }}
                    >
                      <div style={{ fontWeight: 'bold', marginBottom: '0.5rem' }}>Leg {index + 1}</div>
                      <div style={{ fontSize: '0.875rem', color: 'rgba(255, 255, 255, 0.9)' }}>
                        {leg.game}
                      </div>
                      <div style={{ fontSize: '1rem', color: '#f59e0b', fontWeight: 'bold', marginTop: '0.25rem' }}>
                        {leg.pick}
                      </div>
                      {leg.adjustedSpread !== undefined && (
                        <div style={{ fontSize: '0.75rem', color: '#10b981', marginTop: '0.25rem' }}>
                          Adjusted: {leg.adjustedSpread > 0 ? '+' : ''}{leg.adjustedSpread.toFixed(1)}
                        </div>
                      )}
                      <div style={{ fontSize: '0.75rem', color: 'rgba(255, 255, 255, 0.6)', marginTop: '0.25rem' }}>
                        Confidence: {(leg.confidence * 100).toFixed(1)}%
                      </div>
                    </div>
                  ))}
                </div>
              </>
            )}
          </div>
        )}
      </div>
    </div>
  );
}



=== END CONTENT ===


=== FILE NOT FOUND: components/EliteFineTuner.tsx (and alternatives) ===


Export complete! File saved to: C:\cevict-live\apps\progno\progno-key-files-for-grok.txt
